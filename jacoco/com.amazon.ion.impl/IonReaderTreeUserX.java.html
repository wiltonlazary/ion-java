<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderTreeUserX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderTreeUserX.java</span></div><h1>IonReaderTreeUserX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import static com.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static com.amazon.ion.SystemSymbols.ION_1_0_SID;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE;

import com.amazon.ion.IonCatalog;
import com.amazon.ion.IonDatagram;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonSymbol;
import com.amazon.ion.IonType;
import com.amazon.ion.IonValue;
import com.amazon.ion.SeekableReader;
import com.amazon.ion.Span;
import com.amazon.ion.SpanProvider;
import com.amazon.ion.SymbolTable;


<span class="pc bpc" id="L35" title="1 of 2 branches missed.">final class IonReaderTreeUserX</span>
    extends IonReaderTreeSystem
    implements _Private_ReaderWriter
{

    private final _Private_LocalSymbolTableFactory _lstFactory;

    IonCatalog _catalog;
    private SymbolTable _symbols;

    public IonReaderTreeUserX(IonValue value, IonCatalog catalog, _Private_LocalSymbolTableFactory lstFactory)
    {
<span class="fc" id="L47">        super(value); // calls re_init</span>
<span class="fc" id="L48">        _catalog = catalog;</span>
<span class="fc" id="L49">        _lstFactory = lstFactory;</span>
<span class="fc" id="L50">    }</span>

    @Override
    void re_init(IonValue value, boolean hoisted)
    {
<span class="fc" id="L55">        super.re_init(value, hoisted);</span>
<span class="fc" id="L56">        _symbols = _system_symtab;</span>
<span class="fc" id="L57">    }</span>

    //========================================================================

    @Override
    public SymbolTable getSymbolTable()
    {
<span class="fc" id="L64">        return _symbols;</span>
    }

    @Override
    public boolean hasNext()
    {
<span class="fc" id="L70">        return next_helper_user();</span>
    }

    @Override
    public IonType next()
    {
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (!next_helper_user()) {</span>
<span class="fc" id="L77">            this._curr = null;</span>
<span class="fc" id="L78">            return null;</span>
        }
<span class="fc" id="L80">        this._curr = this._next;</span>
<span class="fc" id="L81">        this._next = null;</span>
<span class="fc" id="L82">        return this._curr.getType();</span>
    }

    boolean next_helper_user()
    {
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (_eof) return false;</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (_next != null) return true;</span>

<span class="fc" id="L90">        clear_system_value_stack();</span>

        // read values from the system
        // reader and if they are system values
        // process them.  Return when we've
        // read all the immediate system values
        IonType next_type;
        for (;;) {
<span class="fc" id="L98">            next_type = next_helper_system();</span>

<span class="fc bfc" id="L100" title="All 4 branches covered.">            if (_top == 0 &amp;&amp; _parent instanceof IonDatagram) {</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">                if (IonType.SYMBOL.equals(next_type)) {</span>
<span class="pc bpc" id="L102" title="2 of 4 branches missed.">                    assert(_next instanceof IonSymbol);</span>
<span class="fc" id="L103">                    IonSymbol sym = (IonSymbol)_next;</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                    if (sym.isNullValue()) {</span>
                        // there are no null values we will consume here
<span class="fc" id="L106">                        break;</span>
                    }
<span class="fc" id="L108">                    int sid = sym.getSymbolId();</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">                    if (sid == UNKNOWN_SYMBOL_ID) {</span>
<span class="fc" id="L110">                        String name = sym.stringValue();</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">                        if (name != null) {</span>
<span class="fc" id="L112">                            sid = _system_symtab.findSymbol(name);</span>
                        }
                    }
<span class="fc bfc" id="L115" title="All 2 branches covered.">                    if (sid == ION_1_0_SID</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">                        &amp;&amp; _next.getTypeAnnotationSymbols().length == 0) {</span>
                        // $ion_1_0 is read as an IVM only if it is not annotated
<span class="fc" id="L118">                        SymbolTable symbols = _system_symtab;</span>
<span class="fc" id="L119">                        _symbols = symbols;</span>
<span class="fc" id="L120">                        push_symbol_table(symbols);</span>
<span class="fc" id="L121">                        _next = null;</span>
<span class="fc" id="L122">                        continue;</span>
                    }
<span class="fc" id="L124">                }</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">                else if (IonType.STRUCT.equals(next_type)</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">                      &amp;&amp; _next.findTypeAnnotation(ION_SYMBOL_TABLE) == 0</span>
                ) {
<span class="pc bpc" id="L128" title="2 of 4 branches missed.">                    assert(_next instanceof IonStruct);</span>
                    // read a local symbol table
<span class="fc" id="L130">                    IonReader reader = new IonReaderTreeUserX(_next, _catalog, _lstFactory);</span>
<span class="fc" id="L131">                    SymbolTable symtab = _lstFactory.newLocalSymtab(_catalog, reader, false);</span>
<span class="fc" id="L132">                    _symbols = symtab;</span>
<span class="fc" id="L133">                    push_symbol_table(symtab);</span>
<span class="fc" id="L134">                    _next = null;</span>
<span class="fc" id="L135">                    continue;</span>
                }
            }
            // if we get here we didn't process a system
            // value, if we had we would have 'continue'd
            // so this is a value the user gets
            break;
        }
<span class="fc bfc" id="L143" title="All 2 branches covered.">        return (next_type != null);</span>
    }
    //
    //  This code handles the skipped symbol table
    //  support - it is cloned in IonReaderTextUserX
    //  and IonReaderBinaryUserX
    //
    //  SO ANY FIXES HERE WILL BE NEEDED IN THOSE
    //  TWO LOCATIONS AS WELL.
    //
<span class="fc" id="L153">    private int _symbol_table_top = 0;</span>
<span class="fc" id="L154">    private SymbolTable[] _symbol_table_stack = new SymbolTable[3]; // 3 is rare, IVM followed by a local sym tab with open content</span>
    private void clear_system_value_stack()
    {
<span class="fc bfc" id="L157" title="All 2 branches covered.">        while (_symbol_table_top &gt; 0) {</span>
<span class="fc" id="L158">            _symbol_table_top--;</span>
<span class="fc" id="L159">            _symbol_table_stack[_symbol_table_top] = null;</span>
        }
<span class="fc" id="L161">    }</span>
    private void push_symbol_table(SymbolTable symbols)
    {
<span class="pc bpc" id="L164" title="2 of 4 branches missed.">        assert(symbols != null);</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (_symbol_table_top &gt;= _symbol_table_stack.length) {</span>
<span class="nc" id="L166">            int new_len = _symbol_table_stack.length * 2;</span>
<span class="nc" id="L167">            SymbolTable[] temp = new SymbolTable[new_len];</span>
<span class="nc" id="L168">            System.arraycopy(_symbol_table_stack, 0, temp, 0, _symbol_table_stack.length);</span>
<span class="nc" id="L169">            _symbol_table_stack = temp;</span>
        }
<span class="fc" id="L171">        _symbol_table_stack[_symbol_table_top++] = symbols;</span>
<span class="fc" id="L172">    }</span>
    public SymbolTable pop_passed_symbol_table()
    {
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (_symbol_table_top &lt;= 0) {</span>
<span class="fc" id="L176">            return null;</span>
        }
<span class="fc" id="L178">        _symbol_table_top--;</span>
<span class="fc" id="L179">        SymbolTable symbols = _symbol_table_stack[_symbol_table_top];</span>
<span class="fc" id="L180">        _symbol_table_stack[_symbol_table_top] = null;</span>
<span class="fc" id="L181">        return symbols;</span>
    }


    private static final class TreeSpan
        extends DowncastingFaceted
        implements Span
    {
        IonValue _value;
    }

    private final Span currentSpanImpl()
    {
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (this._curr == null) {</span>
<span class="fc" id="L195">            throw new IllegalStateException(&quot;Reader has no current value&quot;);</span>
        }

<span class="fc" id="L198">        TreeSpan span = new TreeSpan();</span>
<span class="fc" id="L199">        span._value = this._curr;</span>

<span class="fc" id="L201">        return span;</span>
    }


    private void hoistImpl(Span span)
    {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (span instanceof TreeSpan) {</span>
<span class="fc" id="L208">            TreeSpan treeSpan = (TreeSpan)span;</span>
<span class="fc" id="L209">            this.re_init(treeSpan._value, /* hoisted */ true);</span>
<span class="fc" id="L210">        }</span>
        else {
            // TODO custom exception
<span class="nc" id="L213">            throw new IllegalArgumentException(&quot;Span not appropriate for this reader&quot;);</span>
        }
<span class="fc" id="L215">    }</span>


    //========================================================================
    // Facet support


    @Override
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
<span class="fc bfc" id="L225" title="All 4 branches covered.">        if ((facetType == SeekableReader.class) ||</span>
            (facetType == SpanProvider.class))
        {
<span class="fc" id="L228">            return facetType.cast(new SeekableReaderFacet());</span>
        }

<span class="fc" id="L231">        return super.asFacet(facetType);</span>
    }


<span class="fc" id="L235">    private class SeekableReaderFacet implements SeekableReader</span>
    {
        public Span currentSpan()
        {
<span class="fc" id="L239">            return currentSpanImpl();</span>
        }

        public void hoist(Span span)
        {
<span class="fc" id="L244">            hoistImpl(span);</span>
<span class="fc" id="L245">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>