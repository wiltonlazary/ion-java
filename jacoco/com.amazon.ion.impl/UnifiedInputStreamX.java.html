<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnifiedInputStreamX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">UnifiedInputStreamX.java</span></div><h1>UnifiedInputStreamX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import com.amazon.ion.impl.IonReaderTextRawTokensX.IonReaderTextTokenException;
import com.amazon.ion.impl.UnifiedSavePointManagerX.SavePoint;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;

/**
 * This is a local stream abstraction, and implementation, that
 * allows the calling code to operate over final methods even
 * when the original data source is an interface, such a
 * &lt;code&gt;Reader&lt;/code&gt;.
 *
 * When passed a users data buffer it simply operates of the
 * entire buffer directly.
 *
 * When the input source is a stream is creates it's own local
 * buffers, using {@link #UnifiedInputBufferX} and {@link #UnifiedDataPageX}.
 * These allocate pages and loads them, a page at a time, from
 * the stream using the highest bandwidth stream interface available.
 *
 * In this class the unread is only allowed to unread characters
 * that it actually read.  This is checked, when possible, when
 * the local {@link #_debug} is true.  This is checked when
 * the unread is bad into data that is present in the current
 * buffer.  When the unread crosses a buffer boundary the unread
 * value is simply written into the space at the beginning of the
 * block, which is reserved for that purpose.  On all system
 * allocated pages the user data starts at an offset in from
 * the front of the buffer,  The offset is set by {@link #UNREAD_LIMIT}.
 * This is not necessary at either the beginning of the input
 * or for a user supplied buffer since the entire input is a
 * single buffer.
 *
 */
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">abstract class UnifiedInputStreamX</span>
    implements Closeable
{
    public static final int      EOF = -1;

    private static final boolean _debug = false;
            static final int     UNREAD_LIMIT = 10;

    static int DEFAULT_PAGE_SIZE;
    static {
        if (_debug) {
            DEFAULT_PAGE_SIZE = 32;
        }
        else {
<span class="fc" id="L67">            DEFAULT_PAGE_SIZE = 32*1024;</span>
        }
<span class="fc" id="L69">    }</span>

    //
    // member variables
    //
    boolean                 _eof;
    boolean                 _is_byte_data;
    boolean                 _is_stream;

    UnifiedInputBufferX      _buffer;
    int                     _max_char_value;
    int                     _pos;
    int                     _limit;

    // only 1 of these will be filled in depending on whether this is a byte
    // source or a character source
    Reader                  _reader;
    InputStream             _stream;
    byte[]                  _bytes;
    char[]                  _chars;


    UnifiedSavePointManagerX _save_points;


    // factories to construct an appropriate input stream
    // based on the input source
    public static UnifiedInputStreamX makeStream(CharSequence chars) {
<span class="fc" id="L97">        return new FromCharArray(chars, 0, chars.length());</span>
    }
    public static UnifiedInputStreamX makeStream(CharSequence chars, int offset, int length) {
<span class="nc" id="L100">        return new FromCharArray(chars, offset, length);</span>
    }
    public static UnifiedInputStreamX makeStream(char[] chars) {
<span class="nc" id="L103">        return new FromCharArray(chars, 0, chars.length);</span>
    }
    public static UnifiedInputStreamX makeStream(char[] chars, int offset, int length) {
<span class="fc" id="L106">        return new FromCharArray(chars, offset, length);</span>
    }
    public static UnifiedInputStreamX makeStream(Reader reader) throws IOException {
<span class="fc" id="L109">        return new FromCharStream(reader);</span>
    }
    public static UnifiedInputStreamX makeStream(byte[] buffer) {
<span class="nc" id="L112">        return new FromByteArray(buffer, 0, buffer.length);</span>
    }
    public static UnifiedInputStreamX makeStream(byte[] buffer, int offset, int length) {
<span class="fc" id="L115">        return new FromByteArray(buffer, offset, length);</span>
    }
    public static UnifiedInputStreamX makeStream(InputStream stream) throws IOException {
<span class="fc" id="L118">        return new FromByteStream(stream);</span>
    }
<span class="nc" id="L120">    public final InputStream getInputStream() { return _stream; }</span>
<span class="nc" id="L121">    public final Reader      getReader()      { return _reader; }</span>
<span class="fc" id="L122">    public final byte[]      getByteArray()   { return _bytes; }</span>
<span class="fc" id="L123">    public final char[]      getCharArray()   { return _chars; }</span>

    private final void init() {
        // _state = UIS_STATE.STATE_READING;
<span class="fc" id="L127">        _eof = false;</span>
<span class="fc" id="L128">        _max_char_value = _buffer.maxValue();</span>
<span class="fc" id="L129">        _save_points = new UnifiedSavePointManagerX(this);</span>
<span class="fc" id="L130">    }</span>

    public void close()
        throws IOException
    {
<span class="fc" id="L135">        _eof = true;</span>
<span class="fc" id="L136">        _buffer.clear();</span>
<span class="fc" id="L137">    }</span>

    public final boolean isEOF() {
<span class="fc" id="L140">        return _eof; // (_state == UIS_STATE.STATE_EOF);</span>
    }

    /**
     * used to find the current position of this stream in the
     * input source.
     * @return current &quot;file&quot; position
     */
    public long getPosition() {
<span class="fc" id="L149">        long file_pos = 0;</span>
<span class="fc" id="L150">        UnifiedDataPageX page = _buffer.getCurrentPage();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (page != null) {</span>
<span class="fc" id="L152">            file_pos = page.getFilePosition(_pos);</span>
        }
<span class="fc" id="L154">        return file_pos;</span>
    }

    /*
     * save point handling - most of the heavy lifting is handled
     * by the PageBuffer.  The local offset in the current page
     * is added by these routines (from the local member _pos)
     * when needed by the save point handling.
     *
     * these covers also handle keeping _save_point_active and
     * _save_point_limit up to date as they handle their normal
     * work.
     *
     * savepoints were not intended to overlap (save in a save
     * point) so while there isn't any obvious or intentional
     * reason this won't work, it's not planned for nor tested
     * and, therefore, likely to have problems.  There is no
     * need for overlapping save point for the parsing case.
     */
    public final SavePoint savePointAllocate() {
<span class="fc" id="L174">        SavePoint sp = _save_points.savePointAllocate();</span>
<span class="fc" id="L175">        return sp;</span>
    }

    protected final void save_point_reset_to_prev(SavePoint sp)
    {
<span class="fc" id="L180">        int             idx = sp.getPrevIdx();</span>
<span class="fc" id="L181">        UnifiedDataPageX curr = _buffer.getPage(idx);</span>
<span class="fc" id="L182">        int             pos = sp.getPrevPos();</span>
<span class="fc" id="L183">        int             limit = sp.getPrevLimit();</span>

<span class="fc" id="L185">        make_page_current(curr, idx, pos, limit);</span>
<span class="fc" id="L186">    }</span>

    protected final void make_page_current(UnifiedDataPageX curr, int idx, int pos, int limit)
    {
<span class="fc" id="L190">        _limit = limit;</span>
<span class="fc" id="L191">        _pos = pos;</span>
<span class="fc" id="L192">        _eof = false;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (is_byte_data()) {</span>
<span class="fc" id="L194">            _bytes = curr.getByteBuffer();</span>
        }
        else {
<span class="fc" id="L197">            _chars = curr.getCharBuffer();</span>
        }
<span class="fc" id="L199">        _buffer.setCurrentPage(idx, curr);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (pos &gt; limit) {</span>
<span class="nc" id="L201">            refill_is_eof();</span>
<span class="nc" id="L202">            return;</span>
        }
<span class="fc" id="L204">    }</span>

    private final boolean is_byte_data() {
<span class="fc" id="L207">        return _is_byte_data;</span>
    }
    public final void unread(int c)
    {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (c == -1) {</span>
<span class="fc" id="L212">            return;</span>
        }
<span class="pc bpc" id="L214" title="2 of 4 branches missed.">        else if (c &lt; 0 || c &gt; _max_char_value) {</span>
<span class="nc" id="L215">            throw new IllegalArgumentException();</span>
        }
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (_eof) {</span>
<span class="fc" id="L218">            _eof = false;</span>
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">            if (_limit == -1) {</span>
<span class="fc" id="L220">                _limit = _pos;</span>
            }
        }
<span class="fc" id="L223">        _pos--;</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (_pos &gt;= 0) {</span>
<span class="fc" id="L225">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (_pos &lt; curr.getStartingOffset()) {</span>
                // here we've backed up past the beginning of the current
                // buffer.  This can only happen when this is a system
                // managed buffer, not a use supplied buffer (which has
                // only one page).  Or when the user has backed up past
                // the actual beginning of the input - which is an error.
<span class="fc" id="L232">                curr.inc_unread_count();</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">                if (is_byte_data()) {</span>
<span class="fc" id="L234">                    _bytes[_pos] = (byte)c;</span>
                }
                else {
<span class="fc" id="L237">                    _chars[_pos] = (char)c;</span>
                }
            }
            else {
                // we only allow unreading the character that was actually
                // read - and when we can, we verify this.  We will miss
                // cases when the character was in the preceding buffer
                // (handled above) when we just have to believe them.
                // TODO: add test only code that checks the previous buffer
                //       case.
<span class="fc" id="L247">                verify_matched_unread(c);</span>
            }
<span class="fc" id="L249">        }</span>
        else {
            // We don't seem to check for that elsewhere.
<span class="nc" id="L252">            _buffer.putCharAt(getPosition(), c);</span>
        }
<span class="fc" id="L254">    }</span>
    private final void verify_matched_unread(int c) {
        if (_debug) {
            if (is_byte_data()) {
                assert(_bytes[_pos] == (byte)c);
            }
            else {
                assert(_chars[_pos] == (char)c);
            }
        }
<span class="fc" id="L264">    }</span>
    public final boolean unread_optional_cr()
    {
<span class="nc" id="L267">        boolean did_unread = false;</span>
<span class="nc" id="L268">        UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
        int c;

        // if we're in the current buffer and we unread a
        // new line and we can see we were preceded by a
        // carriage return in which case we need to back up
        // 1 more position.
        // If we can't back up into a real data we don't
        // care about this since our next unread/read will
        // be work the same anyway since a new line will
        // just be a lone new line.
        // This corrects bug where the scanner reads a char
        // then a \r\n unreads the \n (the \r was eaten by
        // read()) unreads the char and that overwrites
        // the \r and has editted the buffer.  That's a bad
        // thing.
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (_pos &gt; curr.getStartingOffset()) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (is_byte_data()) {</span>
<span class="nc" id="L286">                c = _bytes[_pos-1] &amp; 0xff;</span>
            }
            else {
<span class="nc" id="L289">                c = _chars[_pos-1];</span>
            }
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (c == '\r') {</span>
<span class="nc" id="L292">                _pos--;</span>
            }
        }
<span class="nc" id="L295">        return did_unread;</span>
    }

    public final int read() throws IOException {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (_pos &gt;= _limit) return read_helper();</span>
        // both bytes and chars might be null if this is empty input
        // otherwise we should have 1, and only 1, of these buffers set
<span class="pc bpc" id="L302" title="2 of 8 branches missed.">        assert((_bytes == null) ^ (_chars == null));</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">        return (_is_byte_data) ? (_bytes[_pos++] &amp; 0xff) : _chars[_pos++];</span>
    }

    protected final int read_helper() throws IOException
    {
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (_eof) {</span>
<span class="fc" id="L309">            return EOF;</span>
        }
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (refill_helper()) {</span>
<span class="fc" id="L312">            return EOF;</span>
        }

<span class="fc bfc" id="L315" title="All 2 branches covered.">        int c = (is_byte_data()) ? (_bytes[_pos++] &amp; 0xff) : _chars[_pos++];</span>
<span class="fc" id="L316">        return c;</span>
    }

    private final boolean refill_helper() throws IOException
    {
<span class="fc" id="L321">        _limit = refill();</span>
        // done in refill: _pos = _buffer.getCurrentPage().getOriginalStartingOffset();
<span class="fc bfc" id="L323" title="All 2 branches covered.">        if (_pos &gt;= _limit) {</span>
<span class="fc" id="L324">            _eof = true;</span>
<span class="fc" id="L325">            return true;</span>
        }
<span class="fc" id="L327">        return false;</span>
    }

    public final void skip(int skipDistance) throws IOException
    {
<span class="fc" id="L332">        int remaining = _limit - _pos;</span>

<span class="fc bfc" id="L334" title="All 2 branches covered.">        if (remaining &gt;= skipDistance) {</span>
<span class="fc" id="L335">            _pos += skipDistance;</span>
<span class="fc" id="L336">            remaining = 0;</span>
        }
        else {
<span class="fc" id="L339">            remaining = skipDistance;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">            while (remaining &gt; 0) {</span>
<span class="fc" id="L341">                int ready = _limit - _pos;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">                if (ready &gt; remaining) {</span>
<span class="fc" id="L343">                    ready = remaining;</span>
                }
<span class="fc" id="L345">                _pos += ready;</span>
<span class="fc" id="L346">                remaining -= ready;</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">                if (remaining &gt; 0) {</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                    if (refill_helper()) {</span>
<span class="fc" id="L349">                        break;</span>
                    }
                }
<span class="fc" id="L352">            }</span>
        }
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (remaining &gt; 0) {</span>
<span class="fc" id="L355">            String message = &quot;unexpected EOF encountered during skip of &quot;</span>
                           + skipDistance
                           + &quot; at position &quot;
<span class="fc" id="L358">                           + getPosition();</span>
<span class="fc" id="L359">            throw new IOException(message);</span>
        }
<span class="fc" id="L361">        return;</span>
    }
    // NB this method does not follow the contract of InputStream.read, it will return 0 at EOF
    //    It is unclear what the implication to the rest of the system to make it 'conform'
    public final int read(byte[] dst, int offset, int length) throws IOException
    {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (!is_byte_data()) {</span>
<span class="nc" id="L368">            throw new IOException(&quot;byte read is not support over character sources&quot;);</span>
        }
<span class="fc" id="L370">        int remaining = length;</span>
<span class="pc bpc" id="L371" title="1 of 4 branches missed.">        while (remaining &gt; 0 &amp;&amp; !isEOF()) {</span>
<span class="fc" id="L372">            int ready = _limit - _pos;</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">            if (ready &gt; remaining) {</span>
<span class="fc" id="L374">                ready = remaining;</span>
            }
<span class="fc" id="L376">            System.arraycopy(_bytes, _pos, dst, offset, ready);</span>
<span class="fc" id="L377">            _pos += ready;</span>
<span class="fc" id="L378">            offset += ready;</span>
<span class="fc" id="L379">            remaining -= ready;</span>
<span class="pc bpc" id="L380" title="2 of 6 branches missed.">            if (remaining == 0 || _pos &lt; _limit || refill_helper()) {</span>
<span class="fc" id="L381">                break;</span>
            }
<span class="nc" id="L383">        }</span>
<span class="fc" id="L384">        return length - remaining;</span>
    }
    private int read_utf8(int c) throws IOException
    {
<span class="nc" id="L388">        int len = IonUTF8.getUTF8LengthFromFirstByte(c);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        for (int ii=1; ii&lt;len; ii++) {</span>
<span class="nc" id="L390">            int c2 = read();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (c2 == -1) {</span>
<span class="nc" id="L392">                throw new IonReaderTextTokenException(&quot;invalid UTF8 sequence encountered in stream&quot;);</span>
            }
<span class="nc" id="L394">            c |= (c2 &lt;&lt; (ii*8));</span>
        }
<span class="nc" id="L396">        c = IonUTF8.getScalarFrom4BytesReversed(c);</span>
<span class="nc" id="L397">        return c;</span>
    }

    /**
     * the refill method is the key override that is filled in by
     * the various subclasses.  It fills either the byte or char
     * array with a block of data from the input source.  As this
     * is a virtual function the right version will get called for
     * each source type.  Since it is only called once per block,
     * and from then on the final method which pulls data from
     * the block can return the value this should be a reasonable
     * performance trade off.
     * @return first value from the refilled input source or EOF
     * @throws IOException
     */
    protected int refill() throws IOException
    {
<span class="fc" id="L414">        UnifiedDataPageX  curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L415">        SavePoint sp = _save_points.savePointActiveTop();</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (!can_fill_new_page()) {</span>
            // aka: there can be only one!
            // (and it's used up)
<span class="fc" id="L420">            return refill_is_eof();</span>
        }

<span class="pc bpc" id="L423" title="1 of 4 branches missed.">        if (sp != null &amp;&amp; sp.getEndIdx() == _buffer.getCurrentPageIdx()) {</span>
            // also EOF but the case is odd enough to call it out
<span class="fc" id="L425">            return refill_is_eof();</span>
        }

        long file_position;
<span class="fc" id="L429">        int start_pos = UNREAD_LIMIT;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (curr == null) {</span>
<span class="fc" id="L431">            file_position = 0;</span>
<span class="fc" id="L432">            start_pos = 0;</span>
        }
        else {
<span class="fc" id="L435">            file_position = curr.getFilePosition(_pos);</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">            if (file_position == 0) {</span>
                // unread before the beginning of file is not allowed,
                // so we don't have to leave room for it
<span class="nc" id="L439">                start_pos = 0;</span>
            }
        }

        // see if we are re-reading saved buffers
<span class="fc" id="L444">        int new_idx = _buffer.getNextFilledPageIdx();</span>
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (new_idx &lt; 0) {</span>
            // there is no pre-filled page waiting for us, so we need to
            // read new data on a new page or over our current page
<span class="fc" id="L448">            curr = _buffer.getCurrentPage();</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            boolean needs_new_page = (curr == null);</span>
<span class="fc" id="L450">            new_idx = _buffer.getCurrentPageIdx();</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            if (_save_points.isSavePointOpen()) {</span>
<span class="fc" id="L452">                new_idx++;</span>
<span class="fc" id="L453">                needs_new_page = true;</span>
            }
<span class="fc bfc" id="L455" title="All 2 branches covered.">            if (needs_new_page) {</span>
<span class="fc" id="L456">                curr = _buffer.getEmptyPageIdx();</span>
            }
            //
            //  here we actually read data into our buffers -----
            //
<span class="fc" id="L461">            int read = load(curr, start_pos, file_position);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            if (read &lt; 1) {</span>
<span class="fc" id="L463">                return refill_is_eof();</span>
            }

<span class="pc bpc" id="L466" title="3 of 6 branches missed.">            assert(curr != null &amp;&amp; curr.getOffsetOfFilePosition(file_position) == start_pos);</span>
<span class="fc" id="L467">            set_current_page(new_idx, curr, start_pos);</span>
<span class="fc" id="L468">        }</span>
        else {
<span class="nc bnc" id="L470" title="All 4 branches missed.">            assert(!isEOF());</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (sp != null) {</span>
<span class="nc" id="L472">                int endidx = sp.getEndIdx();</span>
<span class="nc bnc" id="L473" title="All 4 branches missed.">                if (endidx != -1 &amp;&amp; endidx &lt; new_idx/*_buffer.getCurrentPageIdx()*/) {</span>
<span class="nc" id="L474">                    return refill_is_eof();</span>
                }
            }

<span class="nc" id="L478">            curr = _buffer.getPage(new_idx);</span>
<span class="nc bnc" id="L479" title="All 4 branches missed.">            assert(curr.getStartingFileOffset() == file_position);</span>

<span class="nc" id="L481">            set_current_page(new_idx, curr, curr.getStartingOffset());</span>

<span class="nc bnc" id="L483" title="All 4 branches missed.">            if (sp != null &amp;&amp; sp.getEndIdx() == new_idx /*_buffer.getCurrentPageIdx()*/ ) {</span>
                // the last page in the marked range will probably
                // require a different limit
<span class="nc" id="L486">                _limit = sp.getEndPos();</span>
            }
        }

<span class="pc bpc" id="L490" title="3 of 6 branches missed.">        assert(isEOF() ^ (_limit &gt; 0));  // xor: either we're at eof or we have data to read</span>
<span class="fc" id="L491">        return _limit;</span>
    }
    private void set_current_page(int new_page_idx, UnifiedDataPageX new_page, int pos)
    {
<span class="pc bpc" id="L495" title="4 of 8 branches missed.">        assert(new_page != null &amp;&amp; new_page_idx &gt;= 0 &amp;&amp; new_page_idx &lt;= _buffer.getPageCount() + 1);</span>

<span class="fc" id="L497">        UnifiedDataPageX curr = null;</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (new_page_idx &lt; _buffer.getPageCount()) {</span>
<span class="fc" id="L499">            curr = _buffer.getPage(new_page_idx);</span>
        }

<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (new_page != curr) {</span>
<span class="fc" id="L503">            _buffer.setPage(new_page_idx, new_page, true);</span>
        }

<span class="fc" id="L506">        make_page_current(new_page, new_page_idx, pos, new_page.getBufferLimit());</span>

<span class="fc" id="L508">        return;</span>
    }
    private int refill_is_eof() {
<span class="fc" id="L511">        _eof = true;</span>
<span class="fc" id="L512">        _limit = -1;</span>
<span class="fc" id="L513">        return _limit;</span>
    }

    private final boolean can_fill_new_page() {
<span class="fc" id="L517">        return _is_stream;</span>
    }

    protected final int load(UnifiedDataPageX curr, int start_pos, long file_position) throws IOException
    {
<span class="fc" id="L522">        int read = 0;</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (can_fill_new_page()) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">            if (is_byte_data()) {</span>
<span class="fc" id="L525">                read = curr.load(_stream, start_pos, file_position);</span>
            }
            else {
<span class="fc" id="L528">                read = curr.load(_reader, start_pos, file_position);</span>
            }
        }
<span class="fc" id="L531">        return read;</span>
    }

    //
    // specialized subclasses that provide an appropriate constructor
    // and refill method tailored to efficiently use the data source
    //
    private static class FromCharArray extends UnifiedInputStreamX
    {
        FromCharArray(CharSequence chars, int offset, int length)
<span class="fc" id="L541">        {</span>
<span class="fc" id="L542">            _is_byte_data = false;</span>
<span class="fc" id="L543">            _is_stream = false;</span>
<span class="fc" id="L544">            _buffer = UnifiedInputBufferX.makePageBuffer(chars, offset, length);</span>
<span class="fc" id="L545">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L546">            make_page_current(curr, 0, offset, offset+length);</span>
<span class="fc" id="L547">            super.init();</span>
<span class="fc" id="L548">        }</span>
        FromCharArray(char[] charArray, int offset, int length)
<span class="fc" id="L550">        {</span>
<span class="fc" id="L551">            _is_byte_data = false;</span>
<span class="fc" id="L552">            _is_stream = false;</span>
<span class="fc" id="L553">            _buffer = UnifiedInputBufferX.makePageBuffer(charArray, offset, length);</span>
<span class="fc" id="L554">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L555">            make_page_current(curr, 0, offset, offset+length);</span>
<span class="fc" id="L556">            super.init();</span>
<span class="fc" id="L557">        }</span>
    }

    private static class FromCharStream extends UnifiedInputStreamX
    {
        FromCharStream(Reader reader) throws IOException
<span class="fc" id="L563">        {</span>
<span class="fc" id="L564">            _is_byte_data = false;</span>
<span class="fc" id="L565">            _is_stream = true;</span>
<span class="fc" id="L566">            _reader = reader;</span>
<span class="fc" id="L567">            _buffer = UnifiedInputBufferX.makePageBuffer(UnifiedInputBufferX.BufferType.CHARS, DEFAULT_PAGE_SIZE);</span>
<span class="fc" id="L568">            super.init();</span>
<span class="fc" id="L569">            _limit = refill();</span>
<span class="fc" id="L570">        }</span>

        @Override
        public void close()
            throws IOException
        {
<span class="nc" id="L576">            super.close();</span>
<span class="nc" id="L577">            _reader.close();</span>
<span class="nc" id="L578">        }</span>
    }


// FIXME: PERF_TEST was: private

static class FromByteArray extends UnifiedInputStreamX
    {
        FromByteArray(byte[] bytes, int offset, int length)
<span class="fc" id="L587">        {</span>
<span class="fc" id="L588">            _is_byte_data = true;</span>
<span class="fc" id="L589">            _is_stream = false;</span>
<span class="fc" id="L590">            _buffer = UnifiedInputBufferX.makePageBuffer(bytes, offset, length);</span>
<span class="fc" id="L591">            UnifiedDataPageX curr = _buffer.getCurrentPage();</span>
<span class="fc" id="L592">            make_page_current(curr, 0, offset, offset+length);</span>
<span class="fc" id="L593">            super.init();</span>
<span class="fc" id="L594">        }</span>
    }

    private static class FromByteStream extends UnifiedInputStreamX
    {
        FromByteStream(InputStream stream) throws IOException
<span class="fc" id="L600">        {</span>
<span class="fc" id="L601">            _is_byte_data = true;</span>
<span class="fc" id="L602">            _is_stream = true;</span>
<span class="fc" id="L603">            _stream = stream;</span>
<span class="fc" id="L604">            _buffer = UnifiedInputBufferX.makePageBuffer(UnifiedInputBufferX.BufferType.BYTES, DEFAULT_PAGE_SIZE);</span>
<span class="fc" id="L605">            super.init();</span>
<span class="fc" id="L606">            _limit = refill();</span>
<span class="fc" id="L607">        }</span>

        @Override
        public void close()
            throws IOException
        {
<span class="fc" id="L613">            super.close();</span>
<span class="fc" id="L614">            _stream.close();</span>
<span class="fc" id="L615">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>