<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonReaderTextRawX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">IonReaderTextRawX.java</span></div><h1>IonReaderTextRawX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2009-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static software.amazon.ion.impl.IonTokenConstsX.TOKEN_CLOSE_BRACE;
import static software.amazon.ion.impl.IonTokenConstsX.TOKEN_CLOSE_PAREN;
import static software.amazon.ion.impl.IonTokenConstsX.TOKEN_CLOSE_SQUARE;

import java.io.IOException;
import java.math.BigInteger;
import java.util.Iterator;
import software.amazon.ion.IonException;
import software.amazon.ion.IonReader;
import software.amazon.ion.IonType;
import software.amazon.ion.SymbolTable;
import software.amazon.ion.SymbolToken;
import software.amazon.ion.UnknownSymbolException;
import software.amazon.ion.impl.PrivateScalarConversions.AS_TYPE;
import software.amazon.ion.impl.PrivateScalarConversions.ValueVariant;
import software.amazon.ion.impl.UnifiedSavePointManagerX.SavePoint;

/**
 * Reader implementation that reads the token stream and validates
 * the Ion grammar.  This does not care about system values.  It
 * does not materialize values or convert them.  It does mark values
 * in the UnifiedInputStream if they might be field names or annotations
 * since it does populate these properties directly. Otherwise it
 * accepts the TextRawToken's assessment of the type of the next
 * token, which is based on as few characters as possible, typically
 * 1 but generally less than 5.
 *
 * This is called by the {@link IonReaderTextSystemX}, which in turn is most
 * often called by the {@link IonReaderTextUserX}.  One of these two (system
 * reader or user reader) should be invoked by the user for reading text Ion
 * data.  This class is not intended for general use.
 *
 * This reader scan skip values and in doing so it does not
 * materialize the contents and it does not validate the contents.
 * TODO amzn/ion-java#7 We may want to make validation on skip optional.
 *
 * This manages the value buffer (_v ValueVariant) and the lob
 * content (_lob_*) which is cached in some cases.  It's main
 * job however is recognizing the correct order of the input
 * tokens.  This is done in parse_to_next_value (called by hasNext).
 *
 * The current state is represented by an int (whose value should
 * be one of the values of the STATE_* constants).  The legal
 * transitions are stored in TransitionActions and TransitionActions2.
 * The first (TransitionActions) is a two dimensional array whose
 * dimensions are state and input token. The value stored is an
 * int that represents the action to be taken (ACTION_*).  The
 * second copy of this data (TransitionActions2) is a one dimensional
 * array built from the first and manually dereferenced in the
 * parse_to_next_value method.  This turns out to be a significant
 * performance gain (&lt;sigh&gt;).  Logically these are the same.
 *
 */
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">abstract class IonReaderTextRawX</span>
    implements IonReader
{
    public abstract BigInteger bigIntegerValue();

//              static final boolean _object_parser           = false;
              static final boolean _debug                   = false;
    private   static final int     DEFAULT_STACK_DEPTH      = 10;
    protected static final int     UNKNOWN_SIZE             = -1;
    private   static final int     DEFAULT_ANNOTATION_COUNT =  5;

    static final int STATE_BEFORE_ANNOTATION_DATAGRAM     =  0;
    static final int STATE_BEFORE_ANNOTATION_CONTAINED    =  1;
    static final int STATE_BEFORE_ANNOTATION_SEXP         =  2;
    static final int STATE_BEFORE_FIELD_NAME              =  3;
    static final int STATE_BEFORE_VALUE_CONTENT           =  4;
    static final int STATE_BEFORE_VALUE_CONTENT_SEXP      =  5;
    static final int STATE_IN_LONG_STRING                 =  6;
    static final int STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT  =  7;
    static final int STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT  =  8;
    static final int STATE_IN_BLOB_CONTENT                =  9;
    static final int STATE_AFTER_VALUE_CONTENTS           = 10;
    static final int STATE_EOF                            = 11;
    static final int STATE_MAX                            = 11;
    private final String get_state_name(int state) {
<span class="pc bpc" id="L96" title="7 of 13 branches missed.">        switch(state) {</span>
<span class="fc" id="L97">        case STATE_BEFORE_ANNOTATION_DATAGRAM:    return &quot;STATE_BEFORE_ANNOTATION_DATAGRAM&quot;;</span>
<span class="fc" id="L98">        case STATE_BEFORE_ANNOTATION_CONTAINED:   return &quot;STATE_BEFORE_ANNOTATION_CONTAINED&quot;;</span>
<span class="fc" id="L99">        case STATE_BEFORE_ANNOTATION_SEXP:        return &quot;STATE_BEFORE_ANNOTATION_SEXP&quot;;</span>
<span class="fc" id="L100">        case STATE_BEFORE_FIELD_NAME:             return &quot;STATE_BEFORE_FIELD_NAME&quot;;</span>
<span class="fc" id="L101">        case STATE_BEFORE_VALUE_CONTENT:          return &quot;STATE_BEFORE_VALUE_CONTENT&quot;;</span>
<span class="nc" id="L102">        case STATE_BEFORE_VALUE_CONTENT_SEXP:     return &quot;STATE_BEFORE_VALUE_CONTENT_SEXP&quot;;</span>
<span class="nc" id="L103">        case STATE_IN_LONG_STRING:                return &quot;STATE_IN_LONG_STRING&quot;;</span>
<span class="nc" id="L104">        case STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT: return &quot;STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT&quot;;</span>
<span class="nc" id="L105">        case STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT: return &quot;STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT&quot;;</span>
<span class="nc" id="L106">        case STATE_IN_BLOB_CONTENT:               return &quot;STATE_IN_BLOB_CONTENT&quot;;</span>
<span class="fc" id="L107">        case STATE_AFTER_VALUE_CONTENTS:          return &quot;STATE_AFTER_VALUE_CONTENTS&quot;;</span>
<span class="nc" id="L108">        case STATE_EOF:                           return &quot;STATE_EOF&quot;;</span>
<span class="nc" id="L109">        default:                                  return &quot;&lt;invalid state: &quot;+Integer.toString(state)+&quot;&gt;&quot;;</span>
        }
    }

    static final int ACTION_NOT_DEFINED          =  0;
    static final int ACTION_LOAD_FIELD_NAME      =  1;
    static final int ACTION_LOAD_ANNOTATION      =  2;
    static final int ACTION_START_STRUCT         =  3;
    static final int ACTION_START_LIST           =  4;
    static final int ACTION_START_SEXP           =  5;
    static final int ACTION_START_LOB            =  6;
    static final int ACTION_LOAD_SCALAR          =  8;
    static final int ACTION_PLUS_INF             =  9;
    static final int ACTION_MINUS_INF            = 10;
    static final int ACTION_EAT_COMMA            = 11; // if this is unnecessary (because load_scalar handle it) we don't need &quot;after_value&quot;
    static final int ACTION_FINISH_CONTAINER     = 12;
    static final int ACTION_FINISH_LOB           = 13;
    static final int ACTION_FINISH_DATAGRAM      = 14;
    static final int ACTION_EOF                  = 15;
    static final int ACTION_count                = 16;
    @SuppressWarnings(&quot;unused&quot;)
    private final String get_action_name(int action) {
<span class="nc bnc" id="L131" title="All 16 branches missed.">        switch(action) {</span>
<span class="nc" id="L132">        case ACTION_NOT_DEFINED:        return &quot;ACTION_DO_NOTHING&quot;;</span>
<span class="nc" id="L133">        case ACTION_LOAD_FIELD_NAME:    return &quot;ACTION_LOAD_FIELD_NAME&quot;;</span>
<span class="nc" id="L134">        case ACTION_LOAD_ANNOTATION:    return &quot;ACTION_LOAD_ANNOTATION&quot;;</span>
<span class="nc" id="L135">        case ACTION_START_STRUCT:       return &quot;ACTION_START_STRUCT&quot;;</span>
<span class="nc" id="L136">        case ACTION_START_LIST:         return &quot;ACTION_START_LIST&quot;;</span>
<span class="nc" id="L137">        case ACTION_START_SEXP:         return &quot;ACTION_START_SEXP&quot;;</span>
<span class="nc" id="L138">        case ACTION_START_LOB:          return &quot;ACTION_START_LOB&quot;;</span>
<span class="nc" id="L139">        case ACTION_LOAD_SCALAR:        return &quot;ACTION_LOAD_SCALAR&quot;;</span>
<span class="nc" id="L140">        case ACTION_PLUS_INF:           return &quot;ACTION_PLUS_INF&quot;;</span>
<span class="nc" id="L141">        case ACTION_MINUS_INF:          return &quot;ACTION_MINUS_INF&quot;;</span>
<span class="nc" id="L142">        case ACTION_EAT_COMMA:          return &quot;ACTION_EAT_COMMA&quot;;</span>
<span class="nc" id="L143">        case ACTION_FINISH_CONTAINER:   return &quot;ACTION_FINISH_CONTAINER&quot;;</span>
<span class="nc" id="L144">        case ACTION_FINISH_LOB:         return &quot;ACTION_FINISH_LOB&quot;;</span>
<span class="nc" id="L145">        case ACTION_FINISH_DATAGRAM:    return &quot;ACTION_FINISH_DATAGRAM&quot;;</span>
<span class="nc" id="L146">        case ACTION_EOF:                return &quot;ACTION_EOF&quot;;</span>
<span class="nc" id="L147">        default:                        return &quot;&lt;unrecognized action: &quot;+Integer.toString(action)+&quot;&gt;&quot;;</span>
        }
    }

<span class="fc" id="L151">    static final int[][] TransitionActions = makeTransitionActionArray();</span>
    static final int[][] makeTransitionActionArray()
    {
<span class="fc" id="L154">        int[][] actions = new int[STATE_MAX + 1][IonTokenConstsX.TOKEN_MAX + 1];</span>

<span class="fc" id="L156">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_EOF]                = ACTION_FINISH_DATAGRAM;</span>
<span class="fc" id="L157">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC]    = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L158">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_INT]                = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L159">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_BINARY]             = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L160">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_HEX]                = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L161">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_DECIMAL]            = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L162">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_FLOAT]              = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L163">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_FLOAT_INF]          = ACTION_PLUS_INF;</span>
<span class="fc" id="L164">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_FLOAT_MINUS_INF]    = ACTION_MINUS_INF;</span>
<span class="fc" id="L165">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_TIMESTAMP]          = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L166">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE]= ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L167">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE]= ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L168">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]  = ACTION_LOAD_ANNOTATION;</span>
<span class="fc" id="L169">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]      = ACTION_LOAD_ANNOTATION;</span>
<span class="fc" id="L170">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_PAREN]         = ACTION_START_SEXP;</span>
<span class="fc" id="L171">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_BRACE]         = ACTION_START_STRUCT;</span>
<span class="fc" id="L172">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_SQUARE]        = ACTION_START_LIST;</span>
<span class="fc" id="L173">        actions[STATE_BEFORE_ANNOTATION_DATAGRAM][IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE]  = ACTION_START_LOB;</span>

        // both before_annotation and after_annotation are essentially the same as
        // BOF (after_annotation can't accept EOF as valid however)
<span class="fc bfc" id="L177" title="All 2 branches covered.">        for (int ii=0; ii&lt;IonTokenConstsX.TOKEN_MAX+1; ii++) {</span>
<span class="fc" id="L178">            actions[STATE_BEFORE_ANNOTATION_CONTAINED][ii] = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
<span class="fc" id="L179">            actions[STATE_BEFORE_ANNOTATION_SEXP][ii]      = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
<span class="fc" id="L180">            actions[STATE_BEFORE_VALUE_CONTENT][ii]        = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
<span class="fc" id="L181">            actions[STATE_BEFORE_VALUE_CONTENT_SEXP][ii]   = actions[STATE_BEFORE_ANNOTATION_DATAGRAM][ii];</span>
        }
        // now patch up the differences between these 4 states handling of tokens vs before_annotation_datagram
<span class="fc" id="L184">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_EOF]            = 0;</span>
<span class="fc" id="L185">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_CLOSE_PAREN]    = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L186">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_CLOSE_BRACE]    = 0;</span>
<span class="fc" id="L187">        actions[STATE_BEFORE_ANNOTATION_CONTAINED][IonTokenConstsX.TOKEN_CLOSE_SQUARE]   = ACTION_FINISH_CONTAINER;</span>

<span class="fc" id="L189">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_EOF]                 = 0;</span>
<span class="fc" id="L190">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_SYMBOL_OPERATOR]     = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L191">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_DOT]                 = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L192">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_CLOSE_PAREN]         = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L193">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_CLOSE_BRACE]         = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L194">        actions[STATE_BEFORE_ANNOTATION_SEXP][IonTokenConstsX.TOKEN_CLOSE_SQUARE]        = ACTION_FINISH_CONTAINER;</span>

<span class="fc" id="L196">        actions[STATE_BEFORE_VALUE_CONTENT][IonTokenConstsX.TOKEN_EOF]                   = 0;</span>
<span class="fc" id="L197">        actions[STATE_BEFORE_VALUE_CONTENT][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]     = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L198">        actions[STATE_BEFORE_VALUE_CONTENT][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]         = ACTION_LOAD_SCALAR;</span>

<span class="fc" id="L200">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_EOF]              = 0;</span>
<span class="fc" id="L201">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]= ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L202">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]    = ACTION_LOAD_SCALAR;</span>
<span class="fc" id="L203">        actions[STATE_BEFORE_VALUE_CONTENT_SEXP][IonTokenConstsX.TOKEN_SYMBOL_OPERATOR]  = ACTION_LOAD_SCALAR;</span>

<span class="fc" id="L205">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_EOF]                      = 0;</span>
<span class="fc" id="L206">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER]        = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L207">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_SYMBOL_QUOTED]            = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L208">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE]      = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L209">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE]      = ACTION_LOAD_FIELD_NAME;</span>
<span class="fc" id="L210">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_CLOSE_PAREN]              = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L211">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_CLOSE_BRACE]              = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L212">        actions[STATE_BEFORE_FIELD_NAME][IonTokenConstsX.TOKEN_CLOSE_SQUARE]             = ACTION_FINISH_CONTAINER;</span>

         // after a value we'll either see a separator (like ',')
         // or a containers closing token. If we're not in a container
         // (i.e. we're at the top level) then this isn't the state we
         // should be in.  We'll be in STATE_BEFORE_ANNOTATION_DATAGRAM
<span class="fc" id="L218">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_COMMA]                = ACTION_EAT_COMMA;</span>
<span class="fc" id="L219">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_CLOSE_PAREN]          = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L220">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_CLOSE_BRACE]          = ACTION_FINISH_CONTAINER;</span>
<span class="fc" id="L221">         actions[STATE_AFTER_VALUE_CONTENTS][IonTokenConstsX.TOKEN_CLOSE_SQUARE]         = ACTION_FINISH_CONTAINER;</span>

         // the three &quot;in_&lt;lob&gt;&quot; value states have to be handled
         // specially, they can only scan forward to the end of
         // the content on next, or read content for the user otherwise
<span class="fc" id="L226">         actions[STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT][IonTokenConstsX.TOKEN_CLOSE_BRACE] = ACTION_FINISH_LOB;</span>
<span class="fc" id="L227">         actions[STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT][IonTokenConstsX.TOKEN_CLOSE_BRACE] = ACTION_FINISH_LOB;</span>
<span class="fc" id="L228">         actions[STATE_IN_BLOB_CONTENT][IonTokenConstsX.TOKEN_CLOSE_BRACE]               = ACTION_FINISH_LOB;</span>

         // the eof action exists because finishing an unread value can place the scanner just before
         // the input stream eof and set the current state to eof - in which case we just need to return eof
<span class="fc bfc" id="L232" title="All 2 branches covered.">         for (int ii=0; ii&lt;IonTokenConstsX.TOKEN_MAX+1; ii++) {</span>
<span class="fc" id="L233">             actions[STATE_EOF][ii] =  ACTION_EOF;</span>
         }

<span class="fc" id="L236">         return actions;</span>
    }

<span class="fc" id="L239">    static final int[] TransitionActions2 = makeTransition2ActionArray();</span>
    static int[] makeTransition2ActionArray() {
<span class="fc" id="L241">        int   s, s_count = STATE_MAX + 1;</span>
<span class="fc" id="L242">        int   t, t_count = IonTokenConstsX.TOKEN_MAX + 1;</span>
<span class="fc" id="L243">        int[] a = new int[s_count * t_count];</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (s = 0; s &lt; s_count; s++) {</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            for (t=0; t &lt; t_count; t++) {</span>
<span class="fc" id="L246">                int ii = s * IonTokenConstsX.TOKEN_count + t;</span>
<span class="fc" id="L247">                a[ii] = TransitionActions[s][t];</span>
            }
        }
<span class="fc" id="L250">        return a;</span>
    }

    //
    //  actual class members (preceding values are just parsing
    //  control constants).
    //

    IonReaderTextRawTokensX  _scanner;

    boolean             _eof;
    int                 _state;

<span class="fc" id="L263">    IonType[]           _container_state_stack = new IonType[DEFAULT_STACK_DEPTH];</span>
    int                 _container_state_top;
    boolean             _container_is_struct;           // helper bool's set on push and pop and used
    boolean             _container_prohibits_commas;    // frequently during state transitions actions

    boolean             _has_next_called;
    IonType             _value_type;
    int                 _value_keyword;
    IonType             _null_type;
    String              _field_name;
<span class="fc" id="L273">    int                 _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
    int                 _annotation_count;
    SymbolToken[]    _annotations;

    boolean             _current_value_save_point_loaded;
    SavePoint           _current_value_save_point;
    boolean             _current_value_buffer_loaded;
    StringBuilder       _current_value_buffer;

<span class="fc" id="L282">    ValueVariant        _v = new ValueVariant();</span>

    long                _value_start_offset;
    long                _value_start_line;
    long                _value_start_column;
    IonType             _nesting_parent;

<span class="fc" id="L289">    enum LOB_STATE { EMPTY, READ, FINISHED }</span>
    boolean             _lob_value_set;
    int                 _lob_token;
    long                _lob_value_position;
    LOB_STATE           _lob_loaded;
    byte[]              _lob_bytes;
    int                 _lob_actual_len;


    protected IonReaderTextRawX() {
<span class="fc" id="L299">        super();</span>
<span class="fc" id="L300">        _nesting_parent = null;</span>
<span class="fc" id="L301">    }</span>


    /**
     * @return This implementation always returns null.
     */
    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
<span class="fc" id="L309">        return null;</span>
    }

    //========================================================================

    protected final void init_once() {
<span class="fc" id="L315">        _current_value_buffer = new StringBuilder();</span>
<span class="fc" id="L316">        _annotations = new SymbolToken[DEFAULT_ANNOTATION_COUNT];</span>
<span class="fc" id="L317">    }</span>

    protected final void init(UnifiedInputStreamX iis, IonType parent)
    {
<span class="fc" id="L321">        init(iis, parent, 1, 1);</span>
<span class="fc" id="L322">    }</span>

    protected final void init(UnifiedInputStreamX iis
                             ,IonType parent
                             ,long start_line
                             ,long start_column
    ) {

<span class="pc bpc" id="L330" title="2 of 4 branches missed.">        assert(parent != null);</span>
<span class="fc" id="L331">        _scanner = new IonReaderTextRawTokensX(iis, start_line, start_column);</span>
<span class="fc" id="L332">        _value_start_line = start_line;</span>
<span class="fc" id="L333">        _value_start_column = start_column;</span>
<span class="fc" id="L334">        _current_value_save_point = iis.savePointAllocate();</span>
<span class="fc" id="L335">        _lob_loaded = LOB_STATE.EMPTY;</span>
<span class="fc" id="L336">        int starting_state = get_state_at_container_start(parent);</span>
<span class="fc" id="L337">        set_state(starting_state);</span>
<span class="fc" id="L338">        _eof = false;</span>
<span class="fc" id="L339">        push_container_state(parent);</span>
<span class="fc" id="L340">    }</span>

    protected final void re_init(UnifiedInputStreamX iis
                                ,IonType parent
                                ,long start_line
                                ,long start_column
    ) {
<span class="fc" id="L347">        _state = 0;</span>
<span class="fc" id="L348">        _container_state_top = 0;</span>
<span class="fc" id="L349">        _container_is_struct = false;</span>
<span class="fc" id="L350">        _container_prohibits_commas = false;</span>
<span class="fc" id="L351">        _has_next_called = false;</span>
<span class="fc" id="L352">        _value_type = null;</span>
<span class="fc" id="L353">        _value_keyword = 0;</span>
<span class="fc" id="L354">        _null_type = null;</span>
<span class="fc" id="L355">        _field_name = null;</span>
<span class="fc" id="L356">        _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L357">        _annotation_count = 0;</span>
<span class="fc" id="L358">        _current_value_save_point_loaded = false;</span>
<span class="fc" id="L359">        _current_value_buffer_loaded = false;</span>
<span class="fc" id="L360">        _value_start_offset = 0;</span>
<span class="fc" id="L361">        _lob_value_set = false;</span>
<span class="fc" id="L362">        _lob_token = 0;</span>
<span class="fc" id="L363">        _lob_value_position = 0;</span>
<span class="fc" id="L364">        _lob_bytes = null;</span>
<span class="fc" id="L365">        _lob_actual_len = 0;</span>

<span class="fc" id="L367">        init(iis, parent, start_line, start_column);</span>

<span class="fc" id="L369">        _nesting_parent = parent;</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (IonType.STRUCT.equals(_nesting_parent)) {</span>
<span class="fc" id="L371">            _container_is_struct = true;</span>
        }
<span class="fc" id="L373">    }</span>

    public void close()
        throws IOException
    {
<span class="fc" id="L378">        _scanner.close();</span>
<span class="fc" id="L379">    }</span>

    private final void set_state(int new_state) {
<span class="fc" id="L382">        _state = new_state;</span>
<span class="fc" id="L383">    }</span>
    private final int get_state_int() {
<span class="fc" id="L385">        return _state;</span>
    }
    private final String get_state_name() {
<span class="fc" id="L388">        String name = get_state_name(get_state_int());</span>
<span class="fc" id="L389">        return name;</span>
    }

    protected final void clear_current_value_buffer() {
<span class="fc bfc" id="L393" title="All 2 branches covered.">        if (_current_value_buffer_loaded) {</span>
<span class="fc" id="L394">            _current_value_buffer.setLength(0);</span>
<span class="fc" id="L395">            _current_value_buffer_loaded = false;</span>
        }
<span class="fc bfc" id="L397" title="All 2 branches covered.">        if (_current_value_save_point_loaded) {</span>
<span class="fc" id="L398">            _current_value_save_point.clear();</span>
<span class="fc" id="L399">            _current_value_save_point_loaded = false;</span>
        }
<span class="fc" id="L401">    }</span>

    private final void current_value_is_null(IonType null_type)
    {
<span class="fc" id="L405">        clear_current_value_buffer();</span>
<span class="fc" id="L406">        _value_type = _null_type;</span>
<span class="fc" id="L407">        _v.setValueToNull(null_type);</span>
<span class="fc" id="L408">        _v.setAuthoritativeType(PrivateScalarConversions.AS_TYPE.null_value);</span>
<span class="fc" id="L409">    }</span>

    private final void current_value_is_bool(boolean value)
    {
<span class="fc" id="L413">        clear_current_value_buffer();</span>
<span class="fc" id="L414">        _value_type = IonType.BOOL;</span>
<span class="fc" id="L415">        _v.setValue(value);</span>
<span class="fc" id="L416">        _v.setAuthoritativeType(PrivateScalarConversions.AS_TYPE.boolean_value);</span>
<span class="fc" id="L417">    }</span>

    private final void set_fieldname(SymbolToken sym) {
<span class="fc" id="L420">        _field_name = sym.getText();</span>
<span class="fc" id="L421">        _field_name_sid = sym.getSid();</span>
<span class="fc" id="L422">    }</span>

    private final void clear_fieldname() {
<span class="fc" id="L425">        _field_name = null;</span>
<span class="fc" id="L426">        _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L427">    }</span>

    private final void append_annotation(SymbolToken sym) {
        // empty text is checked by caller
<span class="fc" id="L431">        int oldlen = _annotations.length;</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">        if (_annotation_count &gt;= oldlen) {</span>
<span class="fc" id="L433">            int newlen = oldlen * 2;</span>
<span class="fc" id="L434">            SymbolToken[] temp = new SymbolToken[newlen];</span>
<span class="fc" id="L435">            System.arraycopy(_annotations, 0, temp, 0, oldlen);</span>
<span class="fc" id="L436">            _annotations = temp;</span>
        }
<span class="fc" id="L438">        _annotations[_annotation_count++] = sym;</span>
<span class="fc" id="L439">    }</span>

    private final void clear_annotation_list() {
<span class="fc" id="L442">        _annotation_count = 0;</span>
<span class="fc" id="L443">    }</span>

    /**
     * this looks forward to see if there is an upcoming value
     * if there is it returns true.  It may have to clean up
     * any value that's partially complete (for example a
     * collection whose annotation has been read and loaded
     * but the user has chosen not to step into the collection).
     * @return true if more data remains, false on eof
     */
    boolean hasNext()
    {
<span class="fc" id="L455">        boolean has_next = has_next_raw_value();</span>
<span class="fc" id="L456">        return has_next;</span>
    }
    protected final boolean has_next_raw_value() {
<span class="pc bpc" id="L459" title="1 of 4 branches missed.">        if (!_has_next_called &amp;&amp; !_eof) {</span>
            try {
<span class="fc" id="L461">                finish_value(null);</span>
<span class="fc" id="L462">                clear_value();</span>
<span class="fc" id="L463">                parse_to_next_value();</span>
            }
<span class="fc" id="L465">            catch (IOException e) {</span>
<span class="fc" id="L466">                throw new IonException(e);</span>
<span class="fc" id="L467">            }</span>
<span class="fc" id="L468">            _has_next_called = true;</span>
        }
<span class="fc bfc" id="L470" title="All 2 branches covered.">        return (_eof != true);</span>
    }

    /**
     * returns the type of the next value in the stream.
     * it calls hasNext to assure that the value has been properly
     * started, since hasNext prepares a value as a side effect of
     * determining whether or not a value is pending.
     * A NoSuchElementException is thrown if there are not values remaining.
     * Once called if there is a value available it's contents can
     * be accessed through the other public API's (such as getLong()).
     * @return type of the next value, or null if there is none.
     */
    public IonType next()
    {
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (!hasNext()) {</span>
<span class="fc" id="L486">            return null;</span>
        }
<span class="pc bpc" id="L488" title="1 of 4 branches missed.">        if (_value_type == null &amp;&amp; _scanner.isUnfinishedToken()) {</span>
            try {
<span class="fc" id="L490">                token_contents_load(_scanner.getToken());</span>
            }
<span class="nc" id="L492">            catch (IOException e) {</span>
<span class="nc" id="L493">                throw new IonException(e);</span>
<span class="fc" id="L494">            }</span>
        }
<span class="fc" id="L496">        _has_next_called = false;</span>
<span class="fc" id="L497">        return _value_type;</span>
    }
    private final void finish_and_save_value() throws IOException
    {
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">        if (!_current_value_save_point_loaded) {</span>
<span class="fc" id="L502">            _scanner.save_point_start(_current_value_save_point);</span>
<span class="fc" id="L503">            finish_value(_current_value_save_point);</span>
<span class="fc" id="L504">            _current_value_save_point_loaded = true;</span>
        }
<span class="fc" id="L506">    }</span>
    private final void finish_value(SavePoint sp) throws IOException
    {
<span class="fc bfc" id="L509" title="All 2 branches covered.">        if (_scanner.isUnfinishedToken()) {</span>
<span class="pc bpc" id="L510" title="1 of 4 branches missed.">            if (sp != null &amp;&amp; _value_type != null) {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                switch (_value_type) {</span>
                case STRUCT:
                case SEXP:
                case LIST:
<span class="nc" id="L515">                    sp = null;</span>
<span class="nc" id="L516">                    break;</span>
                default:
                    break;
                }
            }
<span class="fc" id="L521">            _scanner.finish_token(sp);</span>

<span class="fc" id="L523">            int new_state = get_state_after_value();</span>
<span class="fc" id="L524">            set_state(new_state);</span>
        }
<span class="fc" id="L526">        _has_next_called = false;</span>
<span class="fc" id="L527">    }</span>
    private final void clear_value()
    {
<span class="fc" id="L530">        _value_type = null;</span>
<span class="fc" id="L531">        _null_type = null;</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (_lob_value_set) {</span>
<span class="nc" id="L533">            _lob_value_set = false;</span>
<span class="nc" id="L534">            _lob_value_position = 0;</span>
        }
<span class="fc bfc" id="L536" title="All 2 branches covered.">        if (!LOB_STATE.EMPTY.equals(_lob_loaded)) {</span>
<span class="fc" id="L537">            _lob_actual_len = -1;</span>
<span class="fc" id="L538">            _lob_bytes = null;</span>
<span class="fc" id="L539">            _lob_loaded = LOB_STATE.EMPTY;</span>
        }
<span class="fc" id="L541">        clear_current_value_buffer();</span>
<span class="fc" id="L542">        clear_annotation_list();</span>
<span class="fc" id="L543">        clear_fieldname();</span>
<span class="fc" id="L544">        _v.clear();</span>
<span class="fc" id="L545">        _value_start_offset = -1;</span>
<span class="fc" id="L546">    }</span>

    private final void set_container_flags(IonType t) {
<span class="pc bpc" id="L549" title="1 of 5 branches missed.">        switch (t) {</span>
        case LIST:
<span class="fc" id="L551">            _container_is_struct = false;</span>
<span class="fc" id="L552">            _container_prohibits_commas = false;</span>
<span class="fc" id="L553">            break;</span>
        case SEXP:
<span class="fc" id="L555">            _container_is_struct = false;</span>
<span class="fc" id="L556">            _container_prohibits_commas = true;</span>
<span class="fc" id="L557">            break;</span>
        case STRUCT:
<span class="fc" id="L559">            _container_is_struct = true;</span>
<span class="fc" id="L560">            _container_prohibits_commas = false;</span>
<span class="fc" id="L561">            break;</span>
        case DATAGRAM:
<span class="fc" id="L563">            _container_is_struct = false;</span>
<span class="fc" id="L564">            _container_prohibits_commas = true;</span>
<span class="fc" id="L565">            break;</span>
        default:
<span class="nc" id="L567">            throw new IllegalArgumentException(&quot;type must be a container, not a &quot;+t.toString());</span>
        }
<span class="fc" id="L569">    }</span>

    private int get_state_after_value()
    {
        int state_after_scalar;
<span class="pc bpc" id="L574" title="1 of 4 branches missed.">        switch(getContainerType()) {</span>
        case LIST:
        case STRUCT:
<span class="fc" id="L577">            state_after_scalar = STATE_AFTER_VALUE_CONTENTS;</span>
<span class="fc" id="L578">            break;</span>
        case SEXP:
<span class="fc" id="L580">            state_after_scalar = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L581">            break;</span>
        case DATAGRAM:
<span class="fc" id="L583">            state_after_scalar = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
<span class="fc" id="L584">            break;</span>
        default:
<span class="nc" id="L586">            String message = &quot;invalid container type encountered during parsing &quot;</span>
<span class="nc" id="L587">                           + getContainerType()</span>
<span class="nc" id="L588">                           + _scanner.input_position();</span>
<span class="nc" id="L589">            throw new IonException(message);</span>
        }
<span class="fc bfc" id="L591" title="All 4 branches covered.">        if (_nesting_parent != null &amp;&amp; getDepth() == 0) {</span>
<span class="fc" id="L592">            state_after_scalar = STATE_EOF;</span>
        }
<span class="fc" id="L594">        return state_after_scalar;</span>
    }
    private final int get_state_after_annotation() {
        int state_after_annotation;
<span class="pc bpc" id="L598" title="2 of 4 branches missed.">        switch(get_state_int()) {</span>
        case STATE_AFTER_VALUE_CONTENTS:
<span class="nc" id="L600">            IonType container = top_state();</span>
<span class="nc bnc" id="L601" title="All 3 branches missed.">            switch(container) {</span>
            case STRUCT:
            case LIST:
            case DATAGRAM:
<span class="nc" id="L605">                state_after_annotation = STATE_BEFORE_VALUE_CONTENT;</span>
<span class="nc" id="L606">                break;</span>
            case SEXP:
<span class="nc" id="L608">                state_after_annotation = STATE_BEFORE_VALUE_CONTENT_SEXP;</span>
<span class="nc" id="L609">                break;</span>
            default:
<span class="nc" id="L611">                String message = &quot;invalid container type encountered during parsing &quot;</span>
                    + container
<span class="nc" id="L613">                    + _scanner.input_position();</span>
<span class="nc" id="L614">                throw new IonException(message);</span>
            }
<span class="nc" id="L616">            break;</span>
        case STATE_BEFORE_ANNOTATION_DATAGRAM:
        case STATE_BEFORE_ANNOTATION_CONTAINED:
<span class="fc" id="L619">            state_after_annotation = STATE_BEFORE_VALUE_CONTENT;</span>
<span class="fc" id="L620">            break;</span>
        case STATE_BEFORE_ANNOTATION_SEXP:
<span class="fc" id="L622">            state_after_annotation = STATE_BEFORE_VALUE_CONTENT_SEXP;</span>
<span class="fc" id="L623">            break;</span>
        default:
<span class="nc" id="L625">            String message = &quot;invalid state encountered during parsing before the value &quot;</span>
<span class="nc" id="L626">                + get_state_name()</span>
<span class="nc" id="L627">                + _scanner.input_position();</span>
<span class="nc" id="L628">            throw new IonException(message);</span>
        }
<span class="fc" id="L630">        return state_after_annotation;</span>
    }

    private final int get_state_after_container() {
<span class="fc" id="L634">        IonType container = top_state();</span>
<span class="fc" id="L635">        int new_state = get_state_after_container(container);</span>
<span class="fc" id="L636">        return new_state;</span>
    }

    private final int get_state_after_container(int token) {
<span class="fc" id="L640">        IonType container = top_state();</span>

<span class="pc bpc" id="L642" title="1 of 4 branches missed.">        switch(container) {</span>
            case STRUCT:
<span class="fc" id="L644">                check_container_close(container, TOKEN_CLOSE_BRACE, token);</span>
<span class="fc" id="L645">                break;</span>
            case LIST:
<span class="fc" id="L647">                check_container_close(container, TOKEN_CLOSE_SQUARE, token);</span>
<span class="fc" id="L648">                break;</span>
            case SEXP:
<span class="fc" id="L650">                check_container_close(container, TOKEN_CLOSE_PAREN, token);</span>
<span class="fc" id="L651">                break;</span>
            case DATAGRAM:
                // We shouldn't get here.  Fall through.
            default:
<span class="nc" id="L655">                String message = &quot;invalid container type encountered during parsing &quot;</span>
                    + container
<span class="nc" id="L657">                    + _scanner.input_position();</span>
<span class="nc" id="L658">                throw new IonException(message);</span>
        }

<span class="fc" id="L661">        int new_state = get_state_after_container(container);</span>
<span class="fc" id="L662">        return new_state;</span>
    }

    private final int get_state_after_container(IonType container) {
        int new_state;
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (container == null) {</span>
<span class="nc" id="L668">            new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
        }
        else {
<span class="pc bpc" id="L671" title="1 of 4 branches missed.">            switch(container) {</span>
                case STRUCT:
                case LIST:
<span class="fc" id="L674">                    new_state = STATE_AFTER_VALUE_CONTENTS;</span>
<span class="fc" id="L675">                    break;</span>
                case SEXP:
<span class="fc" id="L677">                    new_state = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L678">                    break;</span>
                case DATAGRAM:
<span class="fc" id="L680">                    new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
<span class="fc" id="L681">                    break;</span>
                default:
<span class="nc" id="L683">                    String message = &quot;invalid container type encountered during parsing &quot;</span>
                        + container
<span class="nc" id="L685">                        + _scanner.input_position();</span>
<span class="nc" id="L686">                    throw new IonException(message);</span>
            }
<span class="fc bfc" id="L688" title="All 4 branches covered.">            if (_nesting_parent != null &amp;&amp; getDepth() == 0) {</span>
<span class="fc" id="L689">                new_state = STATE_EOF;</span>
            }
        }
<span class="fc" id="L692">        return new_state;</span>
    }

    private final void check_container_close(IonType container, int expectedToken, int actualToken)
    {
<span class="fc bfc" id="L697" title="All 2 branches covered.">        if (actualToken != expectedToken) {</span>
<span class="fc" id="L698">            String message = container.toString().toLowerCase() + &quot; closed by &quot;</span>
<span class="fc" id="L699">                + IonTokenConstsX.describeToken(actualToken)</span>
<span class="fc" id="L700">                + _scanner.input_position();</span>
<span class="fc" id="L701">            throw new IonException(message);</span>
        }
<span class="fc" id="L703">    }</span>

    private final int get_state_at_container_start(IonType container) {
        int new_state;
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        if (container == null) {</span>
<span class="nc" id="L708">            new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
        }
        else {
<span class="pc bpc" id="L711" title="1 of 5 branches missed.">            switch (container) {</span>
            case STRUCT:
<span class="fc" id="L713">                new_state = STATE_BEFORE_FIELD_NAME;</span>
<span class="fc" id="L714">                break;</span>
            case LIST:
<span class="fc" id="L716">                new_state = STATE_BEFORE_ANNOTATION_CONTAINED;</span>
<span class="fc" id="L717">                break;</span>
            case SEXP:
<span class="fc" id="L719">                new_state = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L720">                break;</span>
            case DATAGRAM:
<span class="fc" id="L722">                new_state = STATE_BEFORE_ANNOTATION_DATAGRAM;</span>
<span class="fc" id="L723">                break;</span>
            default:
<span class="nc" id="L725">                String message = &quot;invalid container type encountered during parsing &quot;</span>
                    + container
<span class="nc" id="L727">                    + _scanner.input_position();</span>
<span class="nc" id="L728">                throw new IonException(message);</span>
            }
        }
<span class="fc" id="L731">        return new_state;</span>
    }


    private final SymbolToken parseSymbolToken(String context,
                                                  StringBuilder sb,
                                                  int t)
        throws IOException
    {
        String text;
        int sid;

<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (t == IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER) {</span>
<span class="fc" id="L744">            int kw = IonTokenConstsX.keyword(sb, 0, sb.length());</span>
<span class="fc bfc" id="L745" title="All 3 branches covered.">            switch (kw) {</span>
                case IonTokenConstsX.KEYWORD_FALSE:
                case IonTokenConstsX.KEYWORD_TRUE:
                case IonTokenConstsX.KEYWORD_NULL:
                case IonTokenConstsX.KEYWORD_NAN:
                    // keywords are not ok unless they're quoted
<span class="fc" id="L751">                    String reason =</span>
                    &quot;Cannot use unquoted keyword &quot; +
<span class="fc" id="L753">                        sb.toString() + &quot; as &quot; + context;</span>
<span class="nc" id="L754">                    parse_error(reason);</span>
                case IonTokenConstsX.KEYWORD_sid:
<span class="fc" id="L756">                    text = null;</span>
<span class="fc" id="L757">                    sid = IonTokenConstsX.decodeSid(sb);</span>
<span class="fc" id="L758">                    break;</span>
                default:
<span class="fc" id="L760">                    text = sb.toString();</span>
<span class="fc" id="L761">                    sid = UNKNOWN_SYMBOL_ID;</span>
                    break;
            }
<span class="fc" id="L764">        }</span>
        else {
<span class="fc" id="L766">            text = sb.toString();</span>
<span class="fc" id="L767">            sid = UNKNOWN_SYMBOL_ID;</span>
        }

<span class="fc" id="L770">        return new SymbolTokenImpl(text, sid);</span>
    }


    protected final void parse_to_next_value() throws IOException
    {
        int t;
        int action, temp_state;
<span class="fc" id="L778">        boolean trailing_whitespace = false;  // TODO: there's a better way to do this</span>
        StringBuilder sb;

        // FIXME: check depth and type before doing anything further
        //        if we're on a collection and at the correct depth
        //        we need to skip over the contents of the collection
        //        before doing any more parsing

        // we'll need a token to get started here
        // we'll also remember where we were when we started if the
        // user later wants to get a span over this value.  In the
        // case where we just before a comma, after the comma we'll
        // reset this offset since for the span the comma isn't part
        // of the span when it's hoisted
<span class="fc" id="L792">        _value_start_offset = _scanner.getStartingOffset();</span>
<span class="fc" id="L793">        _value_start_line   = _scanner.getLineNumber();</span>
<span class="fc" id="L794">        _value_start_column = _scanner.getLineOffset();</span>

<span class="fc" id="L796">        t = _scanner.nextToken();</span>

        for (;;) {
<span class="fc" id="L799">            int idx = get_state_int() * IonTokenConstsX.TOKEN_count + t;</span>
<span class="fc" id="L800">            action = TransitionActions2[idx];</span>
            // this used to be (but the 2d array is 9072ms vs 8786ms
            // timing, 3% of total file parse time!):
            // action = TransitionActions[get_state_int()][t];
<span class="pc bpc" id="L804" title="2 of 16 branches missed.">            switch (action) {</span>
            case ACTION_NOT_DEFINED:
                {
                    // TODO why would we get here?
<span class="fc" id="L808">                    boolean span_eof = false;</span>

<span class="pc bpc" id="L810" title="1 of 2 branches missed.">                    if (_nesting_parent != null) {</span>
<span class="nc bnc" id="L811" title="All 4 branches missed.">                        switch (_nesting_parent) {</span>
                            case LIST:
<span class="nc bnc" id="L813" title="All 2 branches missed.">                                if (t == IonTokenConstsX.TOKEN_CLOSE_SQUARE) {</span>
<span class="nc" id="L814">                                    span_eof = true;</span>
                                }
                                break;
                            case SEXP:
<span class="nc bnc" id="L818" title="All 2 branches missed.">                                if (t == IonTokenConstsX.TOKEN_CLOSE_PAREN){</span>
<span class="nc" id="L819">                                    span_eof = true;</span>
                                }
                                break;
                            case STRUCT:
<span class="nc bnc" id="L823" title="All 2 branches missed.">                                if (t == IonTokenConstsX.TOKEN_CLOSE_BRACE) {</span>
<span class="nc" id="L824">                                    span_eof = true;</span>
                                }
                                break;
                            default:
                                break;
                        }
                    }
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">                    if (span_eof != true) {</span>
<span class="fc" id="L832">                        String message = &quot;invalid syntax [state:&quot;</span>
<span class="fc" id="L833">                                       + get_state_name()</span>
                                       + &quot; on token:&quot;
<span class="fc" id="L835">                                       +IonTokenConstsX.getTokenName(t)</span>
                                       +&quot;]&quot;;
<span class="nc" id="L837">                        parse_error(message);</span>
                    }
<span class="nc" id="L839">                    set_state(STATE_EOF);</span>
<span class="nc" id="L840">                    _eof = true;</span>
<span class="nc" id="L841">                    return;</span>
                }
            case ACTION_EOF:
<span class="fc" id="L844">                set_state(STATE_EOF);</span>
<span class="fc" id="L845">                _eof = true;</span>
<span class="fc" id="L846">                return;</span>
            case ACTION_LOAD_FIELD_NAME:
            {
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">                if (!is_in_struct_internal()) {</span>
<span class="nc" id="L850">                    throw new IllegalStateException(&quot;field names have to be in structs&quot;);</span>
                }
                //finish_value(_current_value_save_point);
<span class="fc" id="L853">                finish_and_save_value();</span>

<span class="fc" id="L855">                sb = token_contents_load(t);</span>

<span class="fc" id="L857">                SymbolToken sym = parseSymbolToken(&quot;a field name&quot;, sb, t);</span>
<span class="fc" id="L858">                set_fieldname(sym);</span>
<span class="fc" id="L859">                clear_current_value_buffer();</span>

<span class="fc" id="L861">                t = _scanner.nextToken();</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                if (t != IonTokenConstsX.TOKEN_COLON) {</span>
<span class="fc" id="L863">                    String message = &quot;field name must be followed by a colon, not a &quot;</span>
<span class="fc" id="L864">                                   + IonTokenConstsX.getTokenName(t);</span>
<span class="nc" id="L865">                    parse_error(message);</span>
                }
<span class="fc" id="L867">                _scanner.tokenIsFinished();</span>
<span class="fc" id="L868">                set_state(STATE_BEFORE_ANNOTATION_CONTAINED);</span>
<span class="fc" id="L869">                t = _scanner.nextToken();</span>
<span class="fc" id="L870">                break;</span>
            }
            case ACTION_LOAD_ANNOTATION:
            {
<span class="fc" id="L874">                sb = token_contents_load(t);</span>

<span class="fc" id="L876">                trailing_whitespace = _scanner.skip_whitespace();</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">                if (!_scanner.skipDoubleColon()) {</span>
                    // unnecessary: set_current_value(sp);
                    // this will &quot;loop around&quot; to ACTION_LOAD_SCALAR
                    // since this is necessarily a symbol of one
                    // sort of another
<span class="fc" id="L882">                    temp_state = get_state_after_annotation();</span>
<span class="fc" id="L883">                    set_state(temp_state);</span>
<span class="fc" id="L884">                    break;</span>
                }

                // We have an annotation!
<span class="fc" id="L888">                SymbolToken sym = parseSymbolToken(&quot;an annotation&quot;, sb, t);</span>
<span class="fc" id="L889">                append_annotation(sym);</span>
<span class="fc" id="L890">                clear_current_value_buffer();</span>

                // Consumed the annotation, move on.
                // note: that peekDoubleColon() consumed the two colons
                // so nextToken won't see them
<span class="fc" id="L895">                t = _scanner.nextToken();</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">                switch(t) {</span>
                case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
                case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
                    // This may be another annotation, so stay in this state
                    // and come around the horn again to check it out.
<span class="fc" id="L901">                    break;</span>
                default:
                    // we leave the error handling to the transition
<span class="fc" id="L904">                    temp_state = get_state_after_annotation();</span>
<span class="fc" id="L905">                    set_state(temp_state);</span>
<span class="fc" id="L906">                    break;</span>
                }
                break;
            }
            case ACTION_START_STRUCT:
<span class="fc" id="L911">                _value_type = IonType.STRUCT;</span>
<span class="fc" id="L912">                temp_state = STATE_BEFORE_FIELD_NAME;</span>
<span class="fc" id="L913">                set_state(temp_state);</span>
<span class="fc" id="L914">                return;</span>
            case ACTION_START_LIST:
<span class="fc" id="L916">                _value_type = IonType.LIST;</span>
<span class="fc" id="L917">                temp_state = STATE_BEFORE_ANNOTATION_CONTAINED;</span>
<span class="fc" id="L918">                set_state(temp_state);</span>
<span class="fc" id="L919">                return;</span>
            case ACTION_START_SEXP:
<span class="fc" id="L921">                _value_type = IonType.SEXP;</span>
<span class="fc" id="L922">                temp_state = STATE_BEFORE_ANNOTATION_SEXP;</span>
<span class="fc" id="L923">                set_state(temp_state);</span>
<span class="fc" id="L924">                return;</span>
            case ACTION_START_LOB:
<span class="fc bfc" id="L926" title="All 3 branches covered.">                switch (_scanner.peekLobStartPunctuation()) {</span>
                case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="fc" id="L928">                    set_state(STATE_IN_CLOB_DOUBLE_QUOTED_CONTENT);</span>
<span class="fc" id="L929">                    _lob_token = IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE;</span>
<span class="fc" id="L930">                    _value_type = IonType.CLOB;</span>
<span class="fc" id="L931">                    break;</span>
                case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="fc" id="L933">                    set_state(STATE_IN_CLOB_TRIPLE_QUOTED_CONTENT);</span>
<span class="fc" id="L934">                    _lob_token = IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE;</span>
<span class="fc" id="L935">                    _value_type = IonType.CLOB;</span>
<span class="fc" id="L936">                    break;</span>
                default:
<span class="fc" id="L938">                    set_state(STATE_IN_BLOB_CONTENT);</span>
<span class="fc" id="L939">                    _lob_token = IonTokenConstsX.TOKEN_OPEN_DOUBLE_BRACE;</span>
<span class="fc" id="L940">                    _value_type = IonType.BLOB;</span>
                    break;
                }
<span class="fc" id="L943">                return;</span>
            case ACTION_LOAD_SCALAR:
<span class="fc bfc" id="L945" title="All 2 branches covered.">                if (t == IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER) {</span>
<span class="fc" id="L946">                    sb = token_contents_load(t);</span>
<span class="fc" id="L947">                    _value_keyword = IonTokenConstsX.keyword(sb, 0, sb.length());</span>
<span class="fc bfc" id="L948" title="All 6 branches covered.">                    switch (_value_keyword) {</span>
                    case IonTokenConstsX.KEYWORD_NULL:
                    {
<span class="fc bfc" id="L951" title="All 2 branches covered.">                        int kwt = trailing_whitespace ? IonTokenConstsX.KEYWORD_none : _scanner.peekNullTypeSymbol();</span>
<span class="pc bpc" id="L952" title="1 of 15 branches missed.">                        switch (kwt) {</span>
<span class="fc" id="L953">                        case IonTokenConstsX.KEYWORD_NULL:      _null_type = IonType.NULL;       break;</span>
<span class="fc" id="L954">                        case IonTokenConstsX.KEYWORD_BOOL:      _null_type = IonType.BOOL;       break;</span>
<span class="fc" id="L955">                        case IonTokenConstsX.KEYWORD_INT:       _null_type = IonType.INT;        break;</span>
<span class="fc" id="L956">                        case IonTokenConstsX.KEYWORD_FLOAT:     _null_type = IonType.FLOAT;      break;</span>
<span class="fc" id="L957">                        case IonTokenConstsX.KEYWORD_DECIMAL:   _null_type = IonType.DECIMAL;    break;</span>
<span class="fc" id="L958">                        case IonTokenConstsX.KEYWORD_TIMESTAMP: _null_type = IonType.TIMESTAMP;  break;</span>
<span class="fc" id="L959">                        case IonTokenConstsX.KEYWORD_SYMBOL:    _null_type = IonType.SYMBOL;     break;</span>
<span class="fc" id="L960">                        case IonTokenConstsX.KEYWORD_STRING:    _null_type = IonType.STRING;     break;</span>
<span class="fc" id="L961">                        case IonTokenConstsX.KEYWORD_BLOB:      _null_type = IonType.BLOB;       break;</span>
<span class="fc" id="L962">                        case IonTokenConstsX.KEYWORD_CLOB:      _null_type = IonType.CLOB;       break;</span>
<span class="fc" id="L963">                        case IonTokenConstsX.KEYWORD_LIST:      _null_type = IonType.LIST;       break;</span>
<span class="fc" id="L964">                        case IonTokenConstsX.KEYWORD_SEXP:      _null_type = IonType.SEXP;       break;</span>
<span class="fc" id="L965">                        case IonTokenConstsX.KEYWORD_STRUCT:    _null_type = IonType.STRUCT;     break;</span>
<span class="fc" id="L966">                        case IonTokenConstsX.KEYWORD_none:      _null_type = IonType.NULL;       break; // this happens when there isn't a '.' otherwise peek throws the error or returns none</span>
<span class="nc" id="L967">                        default: parse_error(&quot;invalid keyword id (&quot;+kwt+&quot;) encountered while parsing a null&quot;);</span>
                        }
                        // at this point we've consumed a dot '.' and it's preceding whitespace
                        // clear_value();
<span class="fc" id="L971">                        current_value_is_null(_null_type);</span>
                        // set to null_type in above call: _value_type = IonType.NULL;
<span class="fc" id="L973">                        break;</span>
                    }
                    case IonTokenConstsX.KEYWORD_TRUE:
<span class="fc" id="L976">                        _value_type = IonType.BOOL;</span>
<span class="fc" id="L977">                        current_value_is_bool(true);</span>
<span class="fc" id="L978">                        break;</span>
                    case IonTokenConstsX.KEYWORD_FALSE:
<span class="fc" id="L980">                        _value_type = IonType.BOOL;</span>
<span class="fc" id="L981">                        current_value_is_bool(false);</span>
<span class="fc" id="L982">                        break;</span>
                    case IonTokenConstsX.KEYWORD_NAN:
<span class="fc" id="L984">                        _value_type = IonType.FLOAT;</span>
<span class="fc" id="L985">                        clear_current_value_buffer();</span>
<span class="fc" id="L986">                        _v.setValue(Double.NaN);</span>
<span class="fc" id="L987">                        _v.setAuthoritativeType(AS_TYPE.double_value);</span>
<span class="fc" id="L988">                        break;</span>
                    case IonTokenConstsX.KEYWORD_sid:
                    {
<span class="fc" id="L991">                        int sid = IonTokenConstsX.decodeSid(sb);</span>
<span class="fc" id="L992">                        _v.setValue(sid);</span>
<span class="fc" id="L993">                        _v.setAuthoritativeType(AS_TYPE.int_value);</span>
                    }
                    default:
                        // We don't care about any other 'keywords'
<span class="fc" id="L997">                        _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L998">                        break;</span>
                    }
                }
<span class="fc bfc" id="L1001" title="All 2 branches covered.">                else if (t == IonTokenConstsX.TOKEN_DOT) {</span>
<span class="fc" id="L1002">                    _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1003">                    clear_current_value_buffer();</span>
<span class="fc" id="L1004">                    _v.setValue(&quot;.&quot;);</span>
<span class="fc" id="L1005">                    _v.setAuthoritativeType(AS_TYPE.string_value);</span>
                }
                else {
                    // if it's not a symbol we just look at the token type
<span class="fc" id="L1009">                    _value_type = IonTokenConstsX.ion_type_of_scalar(t);</span>
                }
<span class="fc" id="L1011">                int state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1012">                set_state(state_after_scalar);</span>
<span class="fc" id="L1013">                return;</span>
            case ACTION_PLUS_INF:
<span class="fc" id="L1015">                _value_type = IonType.FLOAT;</span>
<span class="fc" id="L1016">                clear_current_value_buffer();</span>
<span class="fc" id="L1017">                _v.setValue(Double.POSITIVE_INFINITY);</span>
<span class="fc" id="L1018">                _v.setAuthoritativeType(AS_TYPE.double_value);</span>
<span class="fc" id="L1019">                state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1020">                set_state(state_after_scalar);</span>
<span class="fc" id="L1021">                return;</span>
            case ACTION_MINUS_INF:
<span class="fc" id="L1023">                _value_type = IonType.FLOAT;</span>
<span class="fc" id="L1024">                clear_current_value_buffer();</span>
<span class="fc" id="L1025">                _v.setValue(Double.NEGATIVE_INFINITY);</span>
<span class="fc" id="L1026">                _v.setAuthoritativeType(AS_TYPE.double_value);</span>
<span class="fc" id="L1027">                state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1028">                set_state(state_after_scalar);</span>
<span class="fc" id="L1029">                return;</span>
            case ACTION_EAT_COMMA:
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">                if (_container_prohibits_commas) {</span>
<span class="nc" id="L1032">                    parse_error(&quot;commas aren't used to separate values in &quot;+getContainerType().toString());</span>
                }
<span class="fc" id="L1034">                int new_state = STATE_BEFORE_ANNOTATION_CONTAINED;</span>
<span class="fc bfc" id="L1035" title="All 2 branches covered.">                if (_container_is_struct) {</span>
<span class="fc" id="L1036">                    new_state = STATE_BEFORE_FIELD_NAME;</span>
                }
<span class="fc" id="L1038">                set_state(new_state);</span>
<span class="fc" id="L1039">                _scanner.tokenIsFinished();</span>
                // when we eat a comma we need to reset the current
                // value start used to define a span, since the comma
                // isn't part of the span when it's hoisted
<span class="fc" id="L1043">                _value_start_offset = _scanner.getStartingOffset();</span>
<span class="fc" id="L1044">                t = _scanner.nextToken();</span>
<span class="fc" id="L1045">                break;</span>
            case ACTION_FINISH_CONTAINER:
<span class="fc" id="L1047">                new_state = get_state_after_container(t);</span>
<span class="fc" id="L1048">                set_state(new_state);</span>
<span class="fc" id="L1049">                _eof = true;</span>
<span class="fc" id="L1050">                return;</span>
            case ACTION_FINISH_LOB:
<span class="nc" id="L1052">                state_after_scalar = get_state_after_value();</span>
<span class="nc" id="L1053">                set_state(state_after_scalar);</span>
<span class="nc" id="L1054">                return;</span>
            case ACTION_FINISH_DATAGRAM:
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">                if (getDepth() != 0) {</span>
<span class="nc" id="L1057">                    parse_error(&quot;state failure end of datagram encounterd with a non-container stack&quot;);</span>
                }
<span class="fc" id="L1059">                set_state(STATE_EOF);</span>
<span class="fc" id="L1060">                _eof = true;</span>
<span class="fc" id="L1061">                return;</span>
<span class="nc" id="L1062">            default: parse_error(&quot;unexpected token encountered: &quot;+IonTokenConstsX.getTokenName(t));</span>
            }
<span class="fc" id="L1064">        }</span>
    }

    protected final StringBuilder token_contents_load(int token_type) throws IOException
    {
<span class="fc" id="L1069">        StringBuilder sb = _current_value_buffer;</span>
        boolean       clob_chars_only;
        int           c;

<span class="fc bfc" id="L1073" title="All 2 branches covered.">        if (_current_value_buffer_loaded) {</span>
<span class="fc" id="L1074">            return sb;</span>
        }
<span class="fc bfc" id="L1076" title="All 2 branches covered.">        else if (_current_value_save_point_loaded) {</span>
<span class="pc bpc" id="L1077" title="3 of 6 branches missed.">            assert(!_scanner.isUnfinishedToken() &amp;&amp; !_current_value_save_point.isClear());</span>
            // _scanner.load_save_point_contents( _current_value_save_point, sb);

<span class="fc" id="L1080">            _scanner.save_point_activate(_current_value_save_point);</span>
<span class="pc bpc" id="L1081" title="2 of 6 branches missed.">            switch (token_type) {</span>
            default:
<span class="nc" id="L1083">                _scanner.load_raw_characters(sb);</span>
<span class="nc" id="L1084">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
<span class="fc" id="L1086">                _scanner.load_symbol_identifier(sb);</span>
<span class="fc" id="L1087">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1088">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_OPERATOR:
<span class="nc" id="L1090">                _scanner.load_symbol_operator(sb);</span>
<span class="nc" id="L1091">                _value_type = IonType.SYMBOL;</span>
<span class="nc" id="L1092">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1095">                _scanner.load_single_quoted_string(sb, clob_chars_only);</span>
<span class="fc" id="L1096">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1097">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="pc bpc" id="L1099" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1100">                _scanner.load_double_quoted_string(sb, clob_chars_only);</span>
<span class="fc" id="L1101">                _value_type = IonType.STRING;</span>
<span class="fc" id="L1102">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1105">                _scanner.load_triple_quoted_string(sb, clob_chars_only);</span>
<span class="fc" id="L1106">                _value_type = IonType.STRING;</span>
                break;
            }
<span class="fc" id="L1109">            _scanner.save_point_deactivate(_current_value_save_point);</span>
<span class="fc" id="L1110">            _current_value_buffer_loaded = true;</span>
        }
        else {
<span class="fc" id="L1113">            _scanner.save_point_start(_current_value_save_point);</span>
<span class="pc bpc" id="L1114" title="1 of 7 branches missed.">            switch (token_type) {</span>
            case IonTokenConstsX.TOKEN_UNKNOWN_NUMERIC:
            case IonTokenConstsX.TOKEN_INT:
            case IonTokenConstsX.TOKEN_BINARY:
            case IonTokenConstsX.TOKEN_HEX:
            case IonTokenConstsX.TOKEN_FLOAT:
            case IonTokenConstsX.TOKEN_DECIMAL:
            case IonTokenConstsX.TOKEN_TIMESTAMP:
<span class="fc" id="L1122">                _value_type = _scanner.load_number(sb);</span>
<span class="fc" id="L1123">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_IDENTIFIER:
<span class="fc" id="L1125">                _scanner.load_symbol_identifier(sb);</span>
<span class="fc" id="L1126">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1127">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_OPERATOR:
<span class="fc" id="L1129">                _scanner.load_symbol_operator(sb);</span>
<span class="fc" id="L1130">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1131">                break;</span>
            case IonTokenConstsX.TOKEN_SYMBOL_QUOTED:
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1134">                c = _scanner.load_single_quoted_string(sb, clob_chars_only);</span>
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">                if (c == UnifiedInputStreamX.EOF) {</span>
                    //String message = &quot;EOF encountered before closing single quote&quot;;
                    //parse_error(message);
<span class="nc" id="L1138">                    _scanner.unexpected_eof();</span>
                }
<span class="fc" id="L1140">                _value_type = IonType.SYMBOL;</span>
<span class="fc" id="L1141">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_DOUBLE_QUOTE:
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1144">                c = _scanner.load_double_quoted_string(sb, clob_chars_only);</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">                if (c == UnifiedInputStreamX.EOF) {</span>
                    // String message = &quot;EOF encountered before closing single quote&quot;;
                    // parse_error(message);
<span class="nc" id="L1148">                    _scanner.unexpected_eof();</span>
                }
<span class="fc" id="L1150">                _value_type = IonType.STRING;</span>
<span class="fc" id="L1151">                break;</span>
            case IonTokenConstsX.TOKEN_STRING_TRIPLE_QUOTE:
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">                clob_chars_only = (IonType.CLOB == _value_type);</span>
<span class="fc" id="L1154">                c = _scanner.load_triple_quoted_string(sb, clob_chars_only);</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">                if (c == UnifiedInputStreamX.EOF) {</span>
                    //String message = &quot;EOF encountered before closing single quote&quot;;
                    //parse_error(message);
<span class="nc" id="L1158">                    _scanner.unexpected_eof();</span>
                }
<span class="fc" id="L1160">                _value_type = IonType.STRING;</span>
<span class="fc" id="L1161">                break;</span>
            default:
<span class="nc" id="L1163">                String message = &quot;unexpected token &quot;</span>
<span class="nc" id="L1164">                               + IonTokenConstsX.getTokenName(token_type)</span>
                               + &quot; encountered&quot;;
<span class="nc" id="L1166">                throw new IonException(message);</span>
            }
<span class="fc" id="L1168">            _current_value_save_point.markEnd();</span>
<span class="fc" id="L1169">            _current_value_save_point_loaded = true;</span>
<span class="fc" id="L1170">            _current_value_buffer_loaded = true;</span>
<span class="fc" id="L1171">            tokenValueIsFinished();</span>
        }
<span class="fc" id="L1173">        return sb;</span>
    }

    /**
     * called by super classes to tell us that the
     * current token has been consumed.
     */
    protected void tokenValueIsFinished()
    {
<span class="fc" id="L1182">        _scanner.tokenIsFinished();</span>
<span class="fc bfc" id="L1183" title="All 4 branches covered.">        if (IonType.BLOB.equals(_value_type) || IonType.CLOB.equals(_value_type))</span>
        {
<span class="fc" id="L1185">            int state_after_scalar = get_state_after_value();</span>
<span class="fc" id="L1186">            set_state(state_after_scalar);</span>
        }
<span class="fc" id="L1188">    }</span>

    private final void push_container_state(IonType newContainer)
    {
<span class="fc" id="L1192">        int oldlen = _container_state_stack.length;</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">        if (_container_state_top &gt;= oldlen) {</span>
<span class="fc" id="L1194">            int newlen = oldlen * 2;</span>
<span class="fc" id="L1195">            IonType[] temp = new IonType[newlen];</span>
<span class="fc" id="L1196">            System.arraycopy(_container_state_stack, 0, temp, 0, oldlen);</span>
<span class="fc" id="L1197">            _container_state_stack = temp;</span>
        }
<span class="fc" id="L1199">        set_container_flags(newContainer);</span>
<span class="fc" id="L1200">        _container_state_stack[_container_state_top++] = newContainer;</span>
<span class="fc" id="L1201">    }</span>

    private final void pop_container_state() {
<span class="fc" id="L1204">        _container_state_top--;</span>
<span class="fc" id="L1205">        set_container_flags(top_state());</span>
<span class="fc" id="L1206">        _eof = false;</span>
<span class="fc" id="L1207">        _has_next_called = false;</span>

<span class="fc" id="L1209">        int new_state = get_state_after_container();</span>
<span class="fc" id="L1210">        set_state(new_state);</span>
<span class="fc" id="L1211">    }</span>

    private final IonType top_state() {
<span class="fc" id="L1214">        int top = _container_state_top - 1;</span>
<span class="fc" id="L1215">        IonType top_container = _container_state_stack[top];</span>
<span class="fc" id="L1216">        return top_container;</span>
    }

    public IonType getType()
    {
<span class="fc" id="L1221">        return _value_type;</span>
    }
    // externally we're if we're in a hoisted struct
    // we're not really in a struct, we at the top level
    public boolean isInStruct()
    {
<span class="fc" id="L1227">        boolean in_struct = false;</span>
<span class="fc" id="L1228">        IonType container = getContainerType();</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">        if (IonType.STRUCT.equals(container)) {</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">            if (getDepth() &gt; 0) {</span>
<span class="fc" id="L1231">                in_struct = true;</span>
            }
            else {
<span class="pc bpc" id="L1234" title="2 of 4 branches missed.">                assert(IonType.STRUCT.equals(_nesting_parent) == true);</span>
            }
        }
<span class="fc" id="L1237">        return in_struct;</span>
    }
    // internally (really only in parse_to_next()) we care
    // about being in a struct even if it's a hoisted container
    // since the hoisted values will still have a field name we
    // have to ignore
    private boolean is_in_struct_internal()
    {
<span class="fc" id="L1245">        boolean in_struct = false;</span>
<span class="fc" id="L1246">        IonType container = getContainerType();</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">        if (IonType.STRUCT.equals(container)) {</span>
<span class="fc" id="L1248">            in_struct = true;</span>
        }
<span class="fc" id="L1250">        return in_struct;</span>
    }
    public IonType getContainerType()
    {
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">        if (_container_state_top == 0) return IonType.DATAGRAM;</span>
<span class="fc" id="L1255">        return _container_state_stack[_container_state_top - 1];</span>
    }
    public int getDepth()
    {
<span class="fc" id="L1259">        int depth = _container_state_top;</span>
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">        if (depth &gt; 0) {</span>
<span class="fc" id="L1261">int debugging_depth = depth;</span>
<span class="fc" id="L1262">            IonType top_type = _container_state_stack[0];</span>
<span class="fc bfc" id="L1263" title="All 2 branches covered.">            if (_nesting_parent == null) {</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">                if (IonType.DATAGRAM.equals(top_type)) {</span>
<span class="fc" id="L1265">                    depth--;</span>
                }
            }
            else {
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">                if (_nesting_parent.equals(top_type)) {</span>
<span class="fc" id="L1270">                    depth--;</span>
                }
            }
<span class="pc bpc" id="L1273" title="1 of 2 branches missed.">if (depth == debugging_depth) {</span>
<span class="nc" id="L1274">    System.err.println(&quot;so here's a case where we didn't subtract 1&quot;);</span>
}
        }
<span class="fc" id="L1277">        return depth;</span>
    }

    public String getFieldName()
    {
        // For hoisting
<span class="nc bnc" id="L1283" title="All 4 branches missed.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return null;</span>

<span class="nc" id="L1285">        String name = _field_name;</span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">        if (name == null &amp;&amp; _field_name_sid &gt; 0)</span>
        {
<span class="nc" id="L1288">            throw new UnknownSymbolException(_field_name_sid);</span>
        }
<span class="nc" id="L1290">        return name;</span>
    }

    final String getRawFieldName()
    {
        // For hoisting
<span class="fc bfc" id="L1296" title="All 4 branches covered.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return null;</span>
<span class="fc" id="L1297">        return _field_name;</span>
    }

    int getFieldId()
    {
        // For hoisting
<span class="fc bfc" id="L1303" title="All 4 branches covered.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L1304">        return _field_name_sid;</span>
    }

    public SymbolToken getFieldNameSymbol()
    {
        // For hoisting
<span class="fc bfc" id="L1310" title="All 4 branches covered.">        if (getDepth() == 0 &amp;&amp; is_in_struct_internal()) return null;</span>

<span class="fc" id="L1312">        String name = _field_name;</span>
<span class="fc" id="L1313">        int sid = getFieldId();</span>
<span class="fc bfc" id="L1314" title="All 4 branches covered.">        if (name == null &amp;&amp; sid == UNKNOWN_SYMBOL_ID) return null;</span>
<span class="fc" id="L1315">        return new SymbolTokenImpl(name, sid);</span>
    }

    public Iterator&lt;String&gt; iterateTypeAnnotations()
    {
<span class="fc" id="L1320">        return PrivateUtils.stringIterator(getTypeAnnotations());</span>
    }

    public String[] getTypeAnnotations()
    {
<span class="fc" id="L1325">        return PrivateUtils.toStrings(_annotations, _annotation_count);</span>
    }


    public void stepIn()
    {
<span class="pc bpc" id="L1331" title="2 of 4 branches missed.">        if (_value_type == null || _eof) {</span>
<span class="nc" id="L1332">            throw new IllegalStateException();</span>
        }
<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">        switch (_value_type) {</span>
        case STRUCT:
        case LIST:
        case SEXP:
<span class="fc" id="L1338">            break;</span>
        default:
<span class="nc" id="L1340">            throw new IllegalStateException();</span>
        }

<span class="fc" id="L1343">        int new_state = get_state_at_container_start(_value_type);</span>
<span class="fc" id="L1344">        set_state(new_state);</span>

<span class="fc" id="L1346">        push_container_state(_value_type);</span>

<span class="fc" id="L1348">        _scanner.tokenIsFinished();</span>
        try {
<span class="fc" id="L1350">            finish_value(null);</span>
        }
<span class="nc" id="L1352">        catch (IOException e) {</span>
<span class="nc" id="L1353">            throw new IonException(e);</span>
<span class="fc" id="L1354">        }</span>
<span class="fc bfc" id="L1355" title="All 2 branches covered.">        if (_v.isNull()) {</span>
<span class="fc" id="L1356">            _eof = true;</span>
<span class="fc" id="L1357">            _has_next_called = true;  // there are no contents in a null container</span>
        }

<span class="fc" id="L1360">        _value_type = null;</span>

        if (_debug) System.out.println(&quot;stepInto() new depth: &quot;+getDepth());
<span class="fc" id="L1363">    }</span>
    public void stepOut()
    {
<span class="fc bfc" id="L1366" title="All 2 branches covered.">        if (getDepth() &lt; 1) {</span>
<span class="fc" id="L1367">            throw new IllegalStateException(IonMessages.CANNOT_STEP_OUT);</span>
        }
        try {
<span class="fc" id="L1370">            finish_value(null);</span>
<span class="pc bpc" id="L1371" title="2 of 5 branches missed.">            switch (getContainerType()) {</span>
            case STRUCT:
<span class="fc bfc" id="L1373" title="All 2 branches covered.">                if (!_eof) _scanner.skip_over_struct();</span>
                break;
            case LIST:
<span class="fc bfc" id="L1376" title="All 2 branches covered.">                if (!_eof) _scanner.skip_over_list();</span>
                break;
            case SEXP:
<span class="fc bfc" id="L1379" title="All 2 branches covered.">                if (!_eof) _scanner.skip_over_sexp();</span>
                break;
            case DATAGRAM:
<span class="nc" id="L1382">                break;</span>
            default:
<span class="nc" id="L1384">                throw new IllegalStateException();</span>
            }
        }
<span class="nc" id="L1387">        catch (IOException e) {</span>
<span class="nc" id="L1388">            throw new IonException(e);</span>
<span class="fc" id="L1389">        }</span>
<span class="fc" id="L1390">        pop_container_state();</span>
<span class="fc" id="L1391">        _scanner.tokenIsFinished();</span>
        try {
<span class="fc" id="L1393">            finish_value(null);</span>
        }
<span class="nc" id="L1395">        catch (IOException e) {</span>
<span class="nc" id="L1396">            throw new IonException(e);</span>
<span class="fc" id="L1397">        }</span>

<span class="fc" id="L1399">        clear_value();</span>

        if (_debug) System.out.println(&quot;stepOUT() new depth: &quot;+getDepth());
<span class="fc" id="L1402">    }</span>

    //
    // symbol related code that is inactive in this parser
    //
    public SymbolTable getSymbolTable()
    {
<span class="fc" id="L1409">        return null;</span>
    }

    //
    // helper classes
    //

    public static class IonReaderTextParsingException extends IonException {
        private static final long serialVersionUID = 1L;

        IonReaderTextParsingException(String msg) {
<span class="fc" id="L1420">            super(msg);</span>
<span class="fc" id="L1421">        }</span>
        IonReaderTextParsingException(Exception e) {
<span class="nc" id="L1423">            super(e);</span>
<span class="nc" id="L1424">        }</span>
        IonReaderTextParsingException(String msg, Exception e) {
<span class="fc" id="L1426">            super(msg, e);</span>
<span class="fc" id="L1427">        }</span>
    }

    protected final void parse_error(String reason) {
<span class="fc" id="L1431">        String message =</span>
                &quot;Syntax error&quot;
<span class="fc" id="L1433">              + _scanner.input_position()</span>
              + &quot;: &quot;
              + reason;
<span class="fc" id="L1436">        throw new IonReaderTextParsingException(message);</span>
    }
    protected final void parse_error(Exception e) {
<span class="fc" id="L1439">        String message =</span>
                &quot;Syntax error at &quot;
<span class="fc" id="L1441">              + _scanner.input_position()</span>
              + &quot;: &quot;
<span class="fc" id="L1443">              + e.getLocalizedMessage();</span>
<span class="fc" id="L1444">        throw new IonReaderTextParsingException(message, e);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>