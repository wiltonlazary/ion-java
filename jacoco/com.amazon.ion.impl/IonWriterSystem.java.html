<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonWriterSystem.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">IonWriterSystem.java</span></div><h1>IonWriterSystem.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import static com.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static com.amazon.ion.impl._Private_Utils.newSymbolToken;
import static com.amazon.ion.impl._Private_Utils.newSymbolTokens;

import com.amazon.ion.IonException;
import com.amazon.ion.IonType;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.SystemSymbols;
import com.amazon.ion.UnknownSymbolException;
import com.amazon.ion.system.IonWriterBuilder.InitialIvmHandling;
import com.amazon.ion.system.IonWriterBuilder.IvmMinimizing;
import java.io.IOException;



<span class="pc bpc" id="L34" title="1 of 2 branches missed.">abstract class IonWriterSystem</span>
    extends _Private_IonWriterBase
{
    /**
     * The system symtab used when resetting the stream.
     * Must not be null.
     */
    final SymbolTable _default_system_symbol_table;

    /**
     * What to do about IVMs at the start of the stream.
     * Becomes null as soon as we write anything.
     * After a {@link #finish()} this becomes {@link InitialIVMHandling#ENSURE}
     * because we must force another IVM to be emitted.
     */
    private InitialIvmHandling _initial_ivm_handling;

    /**
     * What to do about non-initial IVMs.
     */
    private final IvmMinimizing _ivm_minimizing;

    /**
     * Indicates whether the (immediately previous emitted value was an IVM.
     * This is cleared by {@link #endValue()}.
     */
    private boolean _previous_value_was_ivm;

    /**
     * Indicates whether we've written anything at all.
     */
    private boolean _anything_written;

    /**
     * Must be either local or system table, and never null.
     * May only be changed between top-level values.
     */
    private SymbolTable _symbol_table;

    /** really ion type is only used for int, string or null (unknown) */
    private IonType     _field_name_type;
    private String      _field_name;
<span class="fc" id="L76">    private int         _field_name_sid = UNKNOWN_SYMBOL_ID;</span>

    private static final int DEFAULT_ANNOTATION_COUNT = 4;

    private int         _annotation_count;
<span class="fc" id="L81">    private SymbolToken[] _annotations =</span>
        new SymbolToken[DEFAULT_ANNOTATION_COUNT];


    //========================================================================

    /**
     * @param defaultSystemSymbolTable must not be null.
     */
    IonWriterSystem(SymbolTable defaultSystemSymbolTable,
                    InitialIvmHandling initialIvmHandling,
                    IvmMinimizing ivmMinimizing)
<span class="fc" id="L93">    {</span>
<span class="fc" id="L94">        defaultSystemSymbolTable.getClass(); // Efficient null check</span>
<span class="fc" id="L95">        _default_system_symbol_table = defaultSystemSymbolTable;</span>
<span class="fc" id="L96">        _symbol_table = defaultSystemSymbolTable;</span>
<span class="fc" id="L97">        _initial_ivm_handling = initialIvmHandling;</span>
<span class="fc" id="L98">        _ivm_minimizing = ivmMinimizing;</span>
<span class="fc" id="L99">    }</span>


    //========================================================================
    // Context management

    final SymbolTable getDefaultSystemSymtab()
    {
<span class="fc" id="L107">        return _default_system_symbol_table;</span>
    }

    public final SymbolTable getSymbolTable()
    {
<span class="fc" id="L112">        return _symbol_table;</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * This implementation simply validates that the argument is not a
     * shared symbol table, and assigns it to {@link #_symbol_table}.
     */
    @Override
    public final void setSymbolTable(SymbolTable symbols)
        throws IOException
    {
<span class="nc bnc" id="L125" title="All 4 branches missed.">        if (symbols == null || _Private_Utils.symtabIsSharedNotSystem(symbols)) {</span>
<span class="nc" id="L126">            throw new IllegalArgumentException(&quot;symbol table must be local or system to be set, or reset&quot;);</span>
        }
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (getDepth() &gt; 0) {</span>
<span class="nc" id="L129">            throw new IllegalStateException(&quot;the symbol table cannot be set, or reset, while a container is open&quot;);</span>
        }
<span class="nc" id="L131">        _symbol_table = symbols;</span>
<span class="nc" id="L132">    }</span>

    boolean shouldWriteIvm()
    {
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (_initial_ivm_handling == InitialIvmHandling.ENSURE)</span>
        {
<span class="fc" id="L138">            return true;</span>
        }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (_initial_ivm_handling == InitialIvmHandling.SUPPRESS)</span>
        {
            // TODO amzn/ion-java/issues/24 Must write IVM if given system != 1.0
<span class="fc" id="L143">            return false;</span>
        }
        // TODO amzn/ion-java/issues/24 Add SUPPRESS_ALL to suppress non 1.0 IVMs

<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (_ivm_minimizing == IvmMinimizing.ADJACENT)</span>
        {
            // TODO amzn/ion-java/issues/24 Write IVM if current system version != given system
            // For now we assume that it's the same since we only support 1.0
<span class="fc bfc" id="L151" title="All 2 branches covered.">            return ! _previous_value_was_ivm;</span>
        }
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (_ivm_minimizing == IvmMinimizing.DISTANT)</span>
        {
            // TODO amzn/ion-java/issues/24 Write IVM if current system version != given system
            // For now we assume that it's the same since we only support 1.0
<span class="fc bfc" id="L157" title="All 2 branches covered.">            return ! _anything_written;</span>
        }

<span class="fc" id="L160">        return true;</span>
    }

    /**
     * Sets {@link #_symbol_table} and clears {@link #_initial_ivm_handling}.
     * Subclasses should override to generate output.
     */
    final void writeIonVersionMarker(SymbolTable systemSymtab)
        throws IOException
    {
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (getDepth() != 0)</span>
        {
<span class="nc" id="L172">            String message =</span>
                &quot;Ion Version Markers are only valid at the top level of a &quot; +
                &quot;data stream&quot;;
<span class="nc" id="L175">            throw new IllegalStateException(message);</span>
        }
<span class="pc bpc" id="L177" title="2 of 4 branches missed.">        assert systemSymtab.isSystemTable();</span>

<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (! SystemSymbols.ION_1_0.equals(systemSymtab.getIonVersionId()))</span>
        {
<span class="nc" id="L181">            String message = &quot;This library only supports Ion 1.0&quot;;</span>
<span class="nc" id="L182">            throw new UnsupportedOperationException(message);</span>
        }

<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (shouldWriteIvm())</span>
        {
<span class="fc" id="L187">            _initial_ivm_handling = null;</span>

<span class="fc" id="L189">            writeIonVersionMarkerAsIs(systemSymtab);</span>

<span class="fc" id="L191">            _previous_value_was_ivm = true;</span>
        }

<span class="fc" id="L194">        _symbol_table = systemSymtab;</span>
<span class="fc" id="L195">    }</span>

    /**
     * Writes an IVM without checking preconditions or
     * {@link InitialIVMHandling}.
     */
    abstract void writeIonVersionMarkerAsIs(SymbolTable systemSymtab)
        throws IOException;


    @Override
    public final void writeIonVersionMarker()
        throws IOException
    {
<span class="fc" id="L209">        writeIonVersionMarker(_default_system_symbol_table);</span>
<span class="fc" id="L210">    }</span>


    void writeLocalSymtab(SymbolTable symtab)
        throws IOException
    {
<span class="pc bpc" id="L216" title="2 of 4 branches missed.">        assert symtab.isLocalTable();</span>
<span class="fc" id="L217">        _symbol_table = symtab;</span>
<span class="fc" id="L218">    }</span>


    /**
     * Builds a new local symbol table from the current contextual symtab
     * (a system symtab).
     * @return not null.
     */
    SymbolTable inject_local_symbol_table() throws IOException
    {
<span class="pc bpc" id="L228" title="2 of 4 branches missed.">        assert _symbol_table.isSystemTable();</span>
        // no catalog since it doesn't matter as this is a
        // pure local table, with no imports
<span class="fc" id="L231">        return LocalSymbolTable.DEFAULT_LST_FACTORY.newLocalSymtab(_symbol_table);</span>
    }

    @Override
    final String assumeKnownSymbol(int sid)
    {
<span class="nc" id="L237">        String text = _symbol_table.findKnownSymbol(sid);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (text == null)</span>
        {
<span class="nc" id="L240">            throw new UnknownSymbolException(sid);</span>
        }
<span class="nc" id="L242">        return text;</span>
    }

    final int add_symbol(String name) throws IOException
    {
        int sid;
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (_symbol_table.isSystemTable()) {</span>
<span class="fc" id="L249">            sid = _symbol_table.findSymbol(name);</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">            if (sid != UNKNOWN_SYMBOL_ID) {</span>
<span class="fc" id="L251">                return sid;</span>
            }
            // @name is not a system symbol, so we inject a local symtab
<span class="fc" id="L254">            _symbol_table = inject_local_symbol_table();</span>
        }
<span class="pc bpc" id="L256" title="2 of 4 branches missed.">        assert _symbol_table.isLocalTable();</span>
<span class="fc" id="L257">        sid = _symbol_table.intern(name).getSid();</span>
<span class="fc" id="L258">        return sid;</span>
    }

    void startValue() throws IOException
    {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (_initial_ivm_handling == InitialIvmHandling.ENSURE)</span>
        {
<span class="fc" id="L265">            writeIonVersionMarker(_default_system_symbol_table);</span>
        }
<span class="fc" id="L267">    }</span>

    void endValue()
    {
<span class="fc" id="L271">        _initial_ivm_handling = null;</span>
<span class="fc" id="L272">        _previous_value_was_ivm = false;</span>
<span class="fc" id="L273">        _anything_written = true;</span>
<span class="fc" id="L274">    }</span>


    /** Writes a symbol without checking for system ID. */
    abstract void writeSymbolAsIs(int symbolId) throws IOException;

    /** Writes a symbol without checking for system ID. */
    abstract void writeSymbolAsIs(String value) throws IOException;

    @Override
    final void writeSymbol(int symbolId) throws IOException
    {
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (symbolId &lt; 0) {</span>
<span class="fc" id="L287">            throw new IllegalArgumentException(&quot;symbol IDs are &gt;= 0.&quot;);</span>
        }

<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (symbolId == SystemSymbols.ION_1_0_SID</span>
<span class="pc bpc" id="L291" title="2 of 4 branches missed.">            &amp;&amp; getDepth() == 0</span>
            &amp;&amp; _annotation_count == 0) {
            // $ion_1_0 is written as an IVM only if it is not annotated
            // TODO amzn/ion-java/issues/24 Make sure to get the right symtab, default may differ.
<span class="fc" id="L295">            writeIonVersionMarker();</span>
        }
        else
        {
<span class="fc" id="L299">            writeSymbolAsIs(symbolId);</span>
        }
<span class="fc" id="L301">    }</span>

    public final void writeSymbol(String value) throws IOException
    {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (SystemSymbols.ION_1_0.equals(value)</span>
<span class="fc bfc" id="L306" title="All 4 branches covered.">            &amp;&amp; getDepth() == 0</span>
            &amp;&amp; _annotation_count == 0) {
            // $ion_1_0 is written as an IVM only if it is not annotated
            // TODO amzn/ion-java/issues/24 Make sure to get the right symtab, default may differ.
<span class="fc" id="L310">            writeIonVersionMarker();</span>
        }
        else {
<span class="fc" id="L313">            writeSymbolAsIs(value);</span>
        }
<span class="fc" id="L315">    }</span>


    public void finish() throws IOException
    {
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (getDepth() != 0) {</span>
<span class="fc" id="L321">            throw new IllegalStateException(ERROR_FINISH_NOT_AT_TOP_LEVEL);</span>
        }

<span class="fc" id="L324">        flush();</span>

<span class="fc" id="L326">        _previous_value_was_ivm = false;</span>
<span class="fc" id="L327">        _initial_ivm_handling = InitialIvmHandling.ENSURE;</span>
<span class="fc" id="L328">        _symbol_table = _default_system_symbol_table;</span>
<span class="fc" id="L329">    }</span>


    //========================================================================
    // Field names

    // This handles converting string to int (or the reverse) using the current
    // symbol table, if that is needed.  These routines are not generally
    // overridden except to throw UnsupportedOperationException when they are
    // not supported.


    @Override
    public final boolean isFieldNameSet()
    {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (_field_name_type != null) {</span>
<span class="pc bpc" id="L345" title="1 of 3 branches missed.">            switch (_field_name_type) {</span>
            case STRING:
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                return _field_name != null;</span>
            case INT:
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                return _field_name_sid &gt;= 0;</span>
            default:
                break;
            }
        }
<span class="fc" id="L354">        return false;</span>
    }

    final void clearFieldName()
    {
<span class="fc" id="L359">        _field_name_type = null;</span>
<span class="fc" id="L360">        _field_name = null;</span>
<span class="fc" id="L361">        _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L362">    }</span>


    public final void setFieldName(String name)
    {
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">        if (!this.isInStruct()) {</span>
<span class="nc" id="L368">            throw new IllegalStateException();</span>
        }

<span class="fc" id="L371">        name.getClass(); // fast null check</span>

<span class="fc" id="L373">        _field_name_type = IonType.STRING;</span>
<span class="fc" id="L374">        _field_name = name;</span>
<span class="fc" id="L375">        _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
<span class="fc" id="L376">    }</span>

    public final void setFieldNameSymbol(SymbolToken name)
    {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (!this.isInStruct()) {</span>
<span class="nc" id="L381">            throw new IllegalStateException();</span>
        }

<span class="fc" id="L384">        String text = name.getText();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (text != null)</span>
        {
<span class="fc" id="L387">            _field_name_type = IonType.STRING;</span>
<span class="fc" id="L388">            _field_name = text;</span>
<span class="fc" id="L389">            _field_name_sid = UNKNOWN_SYMBOL_ID;</span>
        }
        else
        {
<span class="fc" id="L393">            int sid = name.getSid();</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">            if (sid &lt; 0) {</span>
<span class="nc" id="L395">                throw new IllegalArgumentException();</span>
            }
<span class="fc" id="L397">            validateSymbolId(sid);</span>

<span class="fc" id="L399">            _field_name_type = IonType.INT;</span>
<span class="fc" id="L400">            _field_name_sid = sid;</span>
<span class="fc" id="L401">            _field_name = null;</span>
        }
<span class="fc" id="L403">    }</span>

    /**
     * Returns the symbol id of the current field name, if the field name
     * has been set.  If the name has not been set, either as either a String
     * or a symbol id value, this returns -1 (undefined symbol).
     * @return symbol id of the name of the field about to be written or -1 if
     * it is not set
     */
    final int getFieldId()
    {
        int id;

<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (_field_name_type == null) {</span>
<span class="nc" id="L417">            throw new IllegalStateException(&quot;the field has not be set&quot;);</span>
        }
<span class="pc bpc" id="L419" title="1 of 3 branches missed.">        switch (_field_name_type) {</span>
        case STRING:
                try {
<span class="fc" id="L422">                    id = add_symbol(_field_name);</span>
                }
<span class="nc" id="L424">                catch (IOException e) {</span>
<span class="nc" id="L425">                    throw new IonException(e);</span>
<span class="fc" id="L426">                }</span>
                // TODO cache the sid?
            break;
        case INT:
<span class="fc" id="L430">            id = _field_name_sid;</span>
<span class="fc" id="L431">            break;</span>
        default:
<span class="nc" id="L433">            throw new IllegalStateException(&quot;the field has not be set&quot;);</span>
        }

<span class="fc" id="L436">        return id;</span>
    }

    final SymbolToken assumeFieldNameSymbol()
    {
<span class="fc bfc" id="L441" title="All 2 branches covered.">        if (_field_name_type == null)  {</span>
<span class="fc" id="L442">            throw new IllegalStateException(ERROR_MISSING_FIELD_NAME);</span>
        }
        // Exactly one of our fields is set.
<span class="pc bpc" id="L445" title="2 of 8 branches missed.">        assert _field_name != null ^ _field_name_sid &gt;= 0;</span>
<span class="fc" id="L446">        return new SymbolTokenImpl(_field_name, _field_name_sid);</span>
    }

    //========================================================================
    // Annotations

    /**
     * Ensures that our {@link #_annotations} and {@link #_annotation_sids}
     * arrays have enough capacity to hold the given number of annotations.
     * Does not increase {@link #_annotation_count}.
     */
    final void ensureAnnotationCapacity(int length) {
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">        int oldlen = (_annotations == null) ? 0 : _annotations.length;</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (length &lt; oldlen) return;</span>

<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        int newlen = (_annotations == null) ? 10 : (_annotations.length * 2);</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (length &gt; newlen) {</span>
<span class="fc" id="L463">            newlen = length;</span>
        }

<span class="fc" id="L466">        SymbolToken[] temp1 = new SymbolToken[newlen];</span>

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">        if (oldlen &gt; 0) {</span>
<span class="fc" id="L469">            System.arraycopy(_annotations, 0, temp1, 0, oldlen);</span>
        }
<span class="fc" id="L471">        _annotations = temp1;</span>
<span class="fc" id="L472">    }</span>


    final int[] internAnnotationsAndGetSids() throws IOException
    {
<span class="fc" id="L477">        int count = _annotation_count;</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">        if (count == 0) return _Private_Utils.EMPTY_INT_ARRAY;</span>

<span class="fc" id="L480">        int[] sids = new int[count];</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc" id="L483">            SymbolToken sym = _annotations[i];</span>
<span class="fc" id="L484">            int sid = sym.getSid();</span>
<span class="fc bfc" id="L485" title="All 2 branches covered.">            if (sid == UNKNOWN_SYMBOL_ID)</span>
            {
<span class="fc" id="L487">                String text = sym.getText();</span>
<span class="fc" id="L488">                sid = add_symbol(text);</span>
<span class="fc" id="L489">                _annotations[i] = new SymbolTokenImpl(text, sid);</span>
            }
<span class="fc" id="L491">            sids[i] = sid;</span>
        }
<span class="fc" id="L493">        return sids;</span>
    }


    final boolean hasAnnotations()
    {
<span class="fc bfc" id="L499" title="All 2 branches covered.">        return _annotation_count != 0;</span>
    }

    final int annotationCount()
    {
<span class="fc" id="L504">        return _annotation_count;</span>
    }

    final void clearAnnotations()
    {
<span class="fc" id="L509">        _annotation_count = 0;</span>
<span class="fc" id="L510">    }</span>

    @Override
    final int findAnnotation(String name) {
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (_annotation_count &gt; 0) {</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">            for (int ii=0; ii&lt;_annotation_count; ii++) {</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                if (name.equals(_annotations[ii].getText())) {</span>
<span class="fc" id="L517">                    return ii;</span>
                }
            }
        }
<span class="fc" id="L521">        return -1;</span>
    }

    final SymbolToken[] getTypeAnnotationSymbols()
    {
<span class="fc" id="L526">        int count = _annotation_count;</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">        if (count == 0) return SymbolToken.EMPTY_ARRAY;</span>

<span class="fc" id="L529">        SymbolToken[] syms = new SymbolToken[count];</span>
<span class="fc" id="L530">        System.arraycopy(_annotations, 0, syms, 0, count);</span>
<span class="fc" id="L531">        return syms;</span>
    }

    public final void setTypeAnnotationSymbols(SymbolToken... annotations)
    {
<span class="fc bfc" id="L536" title="All 4 branches covered.">        if (annotations == null || annotations.length == 0)</span>
        {
<span class="fc" id="L538">            _annotation_count = 0;</span>
        }
        else
        {
<span class="fc" id="L542">            int count = annotations.length;</span>
            // TODO the following makes two copy passes
            // TODO validate the input
<span class="fc" id="L545">            ensureAnnotationCapacity(count);</span>

<span class="fc" id="L547">            SymbolTable symtab = getSymbolTable();</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++)</span>
            {
<span class="fc" id="L550">                SymbolToken sym = annotations[i];</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">                if (sym.getText() == null) {</span>
<span class="fc" id="L552">                    validateSymbolId(sym.getSid());</span>
                }
<span class="fc" id="L554">                sym = _Private_Utils.localize(symtab, sym);</span>
<span class="fc" id="L555">                _annotations[i] = sym;</span>
            }
<span class="fc" id="L557">            _annotation_count = count;</span>
        }
<span class="fc" id="L559">    }</span>

    @Override
    final String[] getTypeAnnotations()
    {
<span class="nc" id="L564">        return _Private_Utils.toStrings(_annotations, _annotation_count);</span>
    }

    public final void setTypeAnnotations(String... annotations)
    {
<span class="fc bfc" id="L569" title="All 4 branches covered.">        if (annotations == null || annotations.length == 0)</span>
        {
<span class="fc" id="L571">            _annotation_count = 0;</span>
        }
        else
        {
<span class="fc" id="L575">            SymbolToken[] syms =</span>
<span class="fc" id="L576">                newSymbolTokens(getSymbolTable(), annotations);</span>
<span class="fc" id="L577">            int count = syms.length;</span>
            // TODO the following makes two copy passes
<span class="fc" id="L579">            ensureAnnotationCapacity(count);</span>
<span class="fc" id="L580">            System.arraycopy(syms, 0, _annotations, 0, count);</span>
<span class="fc" id="L581">            _annotation_count = count;</span>
        }
<span class="fc" id="L583">    }</span>

    public final void addTypeAnnotation(String annotation)
    {
<span class="fc" id="L587">        SymbolToken is = newSymbolToken(getSymbolTable(), annotation);</span>
<span class="fc" id="L588">        ensureAnnotationCapacity(_annotation_count + 1);</span>
<span class="fc" id="L589">        _annotations[_annotation_count++] = is;</span>
<span class="fc" id="L590">    }</span>


    @Override
    final int[] getTypeAnnotationIds()
    {
<span class="nc" id="L596">        return _Private_Utils.toSids(_annotations, _annotation_count);</span>
    }

    public &lt;T&gt; T asFacet(Class&lt;T&gt; facetType)
    {
        // This implementation has no facets.
<span class="nc" id="L602">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>