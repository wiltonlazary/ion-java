<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonUTF8.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">IonUTF8.java</span></div><h1>IonUTF8.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import com.amazon.ion.IonException;
import java.io.Closeable;
import java.io.IOException;
import java.io.OutputStream;

/**
 * this class holds the various constants and helper functions Ion uses
 * to &quot;understand&quot; UTF-8 encoded input.  This may duplicate values that
 * are available in Java's Character class, but the goal is to fully
 * control and isolate the UTF-8 conversion here.
 *
 * The helper functions are intended to avoid the various bit twiddling
 * errors that can easily occur when working with bits.  As these functions
 * are all static final methods, and very short, the Java compilers should
 * find them very easy to in-line.  (in previous testing I have observed
 * that the Sun JVM heavily in-lines such methods).
 */
<span class="pc bpc" id="L35" title="1 of 2 branches missed.">class IonUTF8 {</span>
    private final static int UNICODE_MAX_ONE_BYTE_SCALAR       = 0x0000007F; // 7 bits     =  7 / 1 = 7    bits per byte
    private final static int UNICODE_MAX_TWO_BYTE_SCALAR       = 0x000007FF; // 5 + 6 bits = 11 / 2 = 5.50 bits per byte
    private final static int UNICODE_MAX_THREE_BYTE_SCALAR     = 0x0000FFFF; // 4 + 6+6    = 16 / 3 = 5.33 bits per byte
    private final static int UNICODE_MAX_FOUR_BYTE_SCALAR      = 0x0010FFFF; // 3 + 6+6+6  = 21 / 4 = 5.25 bits per byte
    private final static int UNICODE_THREE_BYTES_OR_FEWER_MASK = 0xFFFF0000; // if any bits under the f's are set the scalar is either 4 bytes long, or invalid (negative or too large)
    private final static int UNICODE_TWO_BYTE_HEADER           = 0xC0;       // 8 + 4 = 12 = 0xC0
    private final static int UNICODE_THREE_BYTE_HEADER         = 0xE0;       // 8+4+2 = 14 = 0xE0
    private final static int UNICODE_FOUR_BYTE_HEADER          = 0xF0;       // 8+4+2+1 = 15 = 0xF0
    private final static int UNICODE_CONTINUATION_BYTE_HEADER  = 0x80;
    private final static int UNICODE_TWO_BYTE_MASK             = 0x1F;       // 8-3 = 5 bits
    private final static int UNICODE_THREE_BYTE_MASK           = 0x0F;       // 4 bits
    private final static int UNICODE_FOUR_BYTE_MASK            = 0x07;       // 3 bits
    private final static int UNICODE_CONTINUATION_BYTE_MASK    = 0x3F;       // 6 bits in each continuation char

    private final static int MAXIMUM_UTF16_1_CHAR_CODE_POINT   = 0x0000FFFF;
    private final static int SURROGATE_OFFSET                  = 0x00010000;
    private final static int SURROGATE_MASK                    = 0xFFFFFC00;  // 0b 1111 1100 0000 0000
    private final static int HIGH_SURROGATE                    = 0x0000D800;  // 0b 1101 1000 0000 0000
    private final static int LOW_SURROGATE                     = 0x0000DC00;  // 0b 1101 1100 0000 0000

    public final static boolean isHighSurrogate(int b) {
<span class="fc bfc" id="L57" title="All 2 branches covered.">        return ((b &amp; SURROGATE_MASK) == HIGH_SURROGATE);</span>
    }
    public final static boolean isLowSurrogate(int b) {
<span class="fc bfc" id="L60" title="All 2 branches covered.">        return ((b &amp; SURROGATE_MASK) == LOW_SURROGATE);</span>
    }
    public final static boolean isSurrogate(int b) {
<span class="fc bfc" id="L63" title="All 4 branches covered.">        return (b &gt;= 0xD800 &amp;&amp; b &lt;= 0xDFFF);  // 55296 to 57343 or 2048 chars in all</span>
    }

    public final static boolean isOneByteUTF8(int b) {
<span class="fc bfc" id="L67" title="All 2 branches covered.">        return ((b &amp; 0x80) == 0);</span>
    }
    public final static boolean isTwoByteUTF8(int b) {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        return ((b &amp; ~UNICODE_TWO_BYTE_MASK) == UNICODE_TWO_BYTE_HEADER);</span>
    }
    public final static boolean isThreeByteUTF8(int b) {
<span class="fc bfc" id="L73" title="All 2 branches covered.">        return ((b &amp; ~UNICODE_THREE_BYTE_MASK) == UNICODE_THREE_BYTE_HEADER);</span>
    }
    public final static boolean isFourByteUTF8(int b) {
<span class="fc bfc" id="L76" title="All 2 branches covered.">        return ((b &amp; ~UNICODE_FOUR_BYTE_MASK) == UNICODE_FOUR_BYTE_HEADER);</span>
    }
    public final static boolean isContinueByteUTF8(int b) {
<span class="fc bfc" id="L79" title="All 2 branches covered.">        return ((b &amp; ~UNICODE_CONTINUATION_BYTE_MASK) == UNICODE_CONTINUATION_BYTE_HEADER);</span>
    }
    public final static boolean isStartByte(int b) {
<span class="fc bfc" id="L82" title="All 4 branches covered.">        return isOneByteUTF8(b) || !isContinueByteUTF8(b);</span>
    }

    public final static char twoByteScalar(int b1, int b2) {
<span class="fc" id="L86">        int c = ((b1 &amp; UNICODE_TWO_BYTE_MASK) &lt;&lt; 6) | (b2 &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L87">        return (char)c;</span>
    }
    public final static int threeByteScalar(int b1, int b2, int b3) {
<span class="fc" id="L90">        int c = ((b1 &amp; UNICODE_THREE_BYTE_MASK) &lt;&lt; 12) | ((b2 &amp; UNICODE_CONTINUATION_BYTE_MASK) &lt;&lt; 6) | (b3 &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L91">        return c;</span>
    }
    public final static int fourByteScalar(int b1, int b2, int b3, int b4) {
<span class="fc" id="L94">        int c = ((b1 &amp; UNICODE_FOUR_BYTE_MASK) &lt;&lt; 18) | ((b2 &amp; UNICODE_CONTINUATION_BYTE_MASK) &lt;&lt; 12) | ((b3 &amp; UNICODE_CONTINUATION_BYTE_MASK) &lt;&lt; 6) | (b4 &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L95">        return c;</span>
    }

    public final static boolean isOneByteScalar(int unicodeScalar) {
<span class="fc bfc" id="L99" title="All 2 branches covered.">        return (unicodeScalar &lt;= UNICODE_MAX_ONE_BYTE_SCALAR);</span>
    }
    public final static boolean isTwoByteScalar(int unicodeScalar) {
<span class="fc bfc" id="L102" title="All 2 branches covered.">        return (unicodeScalar &lt;= UNICODE_MAX_TWO_BYTE_SCALAR);</span>
    }
    public final static boolean isThreeByteScalar(int unicodeScalar) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        return (unicodeScalar &lt;= UNICODE_MAX_THREE_BYTE_SCALAR);</span>
    }
    public final static boolean isFourByteScalar(int unicodeScalar) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">        return (unicodeScalar &lt;= UNICODE_MAX_FOUR_BYTE_SCALAR);</span>
    }
    public final static int getUTF8ByteCount(int unicodeScalar) {
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if ((unicodeScalar &amp; UNICODE_THREE_BYTES_OR_FEWER_MASK) != 0) {</span>
<span class="pc bpc" id="L112" title="2 of 4 branches missed.">            if (unicodeScalar &gt;= 0 &amp;&amp; unicodeScalar &lt;= UNICODE_MAX_FOUR_BYTE_SCALAR)  return 4;</span>
<span class="nc" id="L113">            throw new InvalidUnicodeCodePoint();</span>
        }
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (unicodeScalar &lt;= UNICODE_MAX_ONE_BYTE_SCALAR)   return 1;</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">        if (unicodeScalar &lt;= UNICODE_MAX_TWO_BYTE_SCALAR)   return 2;</span>
<span class="fc" id="L117">        return 3;</span>
    }
    public final static int getUTF8LengthFromFirstByte(int firstByte) {
<span class="fc" id="L120">        firstByte &amp;= 0xff;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        if (isOneByteUTF8(firstByte))   return 1;</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (isTwoByteUTF8(firstByte))   return 2;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (isThreeByteUTF8(firstByte)) return 3;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (isFourByteUTF8(firstByte))  return 4;</span>
<span class="fc" id="L125">        return -1;</span>
    }

    public final static byte getByte1Of2(int unicodeScalar) {
<span class="fc" id="L129">        int b1 = (UNICODE_TWO_BYTE_HEADER         | ((unicodeScalar &gt;&gt; 6)  &amp; UNICODE_TWO_BYTE_MASK));</span>
<span class="fc" id="L130">        return (byte)b1;</span>
    }
    public final static byte getByte2Of2(int unicodeScalar) {
<span class="fc" id="L133">        int b2 = (UNICODE_CONTINUATION_BYTE_HEADER | ( unicodeScalar        &amp; UNICODE_CONTINUATION_BYTE_MASK));</span>
<span class="fc" id="L134">        return (byte)b2;</span>
    }
    public final static byte getByte1Of3(int unicodeScalar) {
<span class="fc" id="L137">        int b1 = (UNICODE_THREE_BYTE_HEADER        | ((unicodeScalar &gt;&gt; 12) &amp; UNICODE_THREE_BYTE_MASK));</span>
<span class="fc" id="L138">        return (byte)b1;</span>
    }
    public final static byte getByte2Of3(int unicodeScalar) {
<span class="fc" id="L141">        int b2 = (UNICODE_CONTINUATION_BYTE_HEADER | ((unicodeScalar &gt;&gt; 6)  &amp; UNICODE_CONTINUATION_BYTE_MASK));</span>
<span class="fc" id="L142">        return (byte)b2;</span>
    }
    public final static byte getByte3Of3(int unicodeScalar) {
<span class="fc" id="L145">        int b3 = (UNICODE_CONTINUATION_BYTE_HEADER | ( unicodeScalar        &amp; UNICODE_CONTINUATION_BYTE_MASK));</span>
<span class="fc" id="L146">        return (byte)b3;</span>
    }
    public final static byte getByte1Of4(int unicodeScalar) {
<span class="fc" id="L149">        int b1 = (UNICODE_FOUR_BYTE_HEADER         | ((unicodeScalar &gt;&gt; 18) &amp; UNICODE_FOUR_BYTE_MASK));</span>
<span class="fc" id="L150">        return (byte)b1;</span>
    }
    public final static byte getByte2Of4(int unicodeScalar) {
<span class="fc" id="L153">        int b2 = (UNICODE_CONTINUATION_BYTE_HEADER | ((unicodeScalar &gt;&gt; 12) &amp; UNICODE_CONTINUATION_BYTE_MASK));</span>
<span class="fc" id="L154">        return (byte)b2;</span>
    }
    public final static byte getByte3Of4(int unicodeScalar) {
<span class="fc" id="L157">        int b3 = (UNICODE_CONTINUATION_BYTE_HEADER | ((unicodeScalar &gt;&gt; 6)  &amp; UNICODE_CONTINUATION_BYTE_MASK));</span>
<span class="fc" id="L158">        return (byte)b3;</span>
    }
    public final static byte getByte4Of4(int unicodeScalar) {
<span class="fc" id="L161">        int b4 = (UNICODE_CONTINUATION_BYTE_HEADER | ( unicodeScalar        &amp; UNICODE_CONTINUATION_BYTE_MASK));</span>
<span class="fc" id="L162">        return (byte)b4;</span>
    }
    public final static int getAs4BytesReversed(int unicodeScalar) {
        int four_bytes;

        //loop to write these bytes out:
        //bytes = getAs4Bytes(us)
        //do {
        //    write(bytes &amp; 0xff);
        //    bytes = (bytes &gt;&gt;&gt; 8);  // don't sign extend
        //} until (bytes == 0);

<span class="pc bpc" id="L174" title="1 of 5 branches missed.">        switch (getUTF8ByteCount(unicodeScalar)) {</span>
        case 1:
<span class="fc" id="L176">            return unicodeScalar;</span>
        case 2:
<span class="fc" id="L178">            four_bytes  = getByte1Of2(unicodeScalar);</span>
<span class="fc" id="L179">            four_bytes |= getByte2Of2(unicodeScalar) &lt;&lt; 8;</span>
<span class="fc" id="L180">            return four_bytes;</span>
        case 3:
<span class="fc" id="L182">            four_bytes  = getByte1Of3(unicodeScalar);</span>
<span class="fc" id="L183">            four_bytes |= getByte2Of3(unicodeScalar) &lt;&lt; 8;</span>
<span class="fc" id="L184">            four_bytes |= getByte3Of3(unicodeScalar) &lt;&lt; 16;</span>
<span class="fc" id="L185">            return four_bytes;</span>
        case 4:
<span class="fc" id="L187">            four_bytes  = getByte1Of4(unicodeScalar);</span>
<span class="fc" id="L188">            four_bytes |= getByte2Of4(unicodeScalar) &lt;&lt; 8;</span>
<span class="fc" id="L189">            four_bytes |= getByte3Of4(unicodeScalar) &lt;&lt; 16;</span>
<span class="fc" id="L190">            four_bytes |= getByte4Of4(unicodeScalar) &lt;&lt; 24;</span>
<span class="fc" id="L191">            return four_bytes;</span>
        }
<span class="nc" id="L193">        throw new InvalidUnicodeCodePoint();</span>
    }
    /**
     * this helper converts the unicodeScalar to a sequence of utf8 bytes
     * and copies those bytes into the supplied outputBytes array.  If there
     * is insufficient room in the array to hold the generated bytes it will
     * throw an ArrayIndexOutOfBoundsException.  It does not check for the
     * validity of the passed in unicodeScalar thoroughly, however it will
     * throw an InvalidUnicodeCodePoint if the value is less than negative
     * or the UTF8 encoding would exceed 4 bytes.
     * @param unicodeScalar scalar to convert
     * @param outputBytes user output array to fill with UTF8 bytes
     * @param offset first array element to fill
     * @param maxLength maximum number of array elements to fill
     * @return number of bytes written to the output array
     */
    public final static int convertToUTF8Bytes(int unicodeScalar, byte[] outputBytes, int offset, int maxLength)
    {
<span class="fc" id="L211">        int dst = offset;</span>
<span class="fc" id="L212">        int end = offset + maxLength;</span>

<span class="pc bpc" id="L214" title="1 of 5 branches missed.">        switch (getUTF8ByteCount(unicodeScalar)) {</span>
        case 1:
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (dst &gt;= end) throw new ArrayIndexOutOfBoundsException();</span>
<span class="fc" id="L217">            outputBytes[dst++] = (byte)(unicodeScalar &amp; 0xff);</span>
<span class="fc" id="L218">            break;</span>
        case 2:
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">            if (dst+1 &gt;= end) throw new ArrayIndexOutOfBoundsException();</span>
<span class="fc" id="L221">            outputBytes[dst++] = getByte1Of2(unicodeScalar);</span>
<span class="fc" id="L222">            outputBytes[dst++] = getByte2Of2(unicodeScalar);</span>
<span class="fc" id="L223">            break;</span>
        case 3:
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">            if (dst+2 &gt;= end) throw new ArrayIndexOutOfBoundsException();</span>
<span class="fc" id="L226">            outputBytes[dst++] = getByte1Of3(unicodeScalar);</span>
<span class="fc" id="L227">            outputBytes[dst++] = getByte2Of3(unicodeScalar);</span>
<span class="fc" id="L228">            outputBytes[dst++] = getByte3Of3(unicodeScalar);</span>
<span class="fc" id="L229">            break;</span>
        case 4:
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if (dst+3 &gt;= end) throw new ArrayIndexOutOfBoundsException();</span>
<span class="fc" id="L232">            outputBytes[dst++] = getByte1Of4(unicodeScalar);</span>
<span class="fc" id="L233">            outputBytes[dst++] = getByte2Of4(unicodeScalar);</span>
<span class="fc" id="L234">            outputBytes[dst++] = getByte3Of4(unicodeScalar);</span>
<span class="fc" id="L235">            outputBytes[dst++] = getByte4Of4(unicodeScalar);</span>
            break;
        }
<span class="fc" id="L238">        return dst - offset;</span>
    }
    /**
     * converts a unicode code point to a 0-3 bytes of UTF8
     * encoded data and a length - note this doesn't pack
     * a 1 byte character and it returns the start character.
     * this is the unpacking routine
     *  while (_utf8_pretch_byte_count &gt; 0 &amp;&amp; offset &lt; limit) {
     *    _utf8_pretch_byte_count--;
     *    buffer[offset++] = (byte)((_utf8_pretch_bytes &gt;&gt; (_utf8_pretch_byte_count*8)) &amp; 0xff);
     *  }
     */
    public final static int packBytesAfter1(int unicodeScalar, int utf8Len)
    {
        int packed_chars;

<span class="pc bpc" id="L254" title="1 of 4 branches missed.">        switch (utf8Len) {</span>
        default:
<span class="nc" id="L256">            throw new IllegalArgumentException(&quot;pack requires len &gt; 1&quot;);</span>
        case 2:
<span class="fc" id="L258">            packed_chars = getByte2Of2(unicodeScalar);</span>
<span class="fc" id="L259">            break;</span>
        case 3:
<span class="fc" id="L261">            packed_chars  = getByte2Of3(unicodeScalar);</span>
<span class="fc" id="L262">            packed_chars |= getByte3Of3(unicodeScalar) &lt;&lt; 8;</span>
<span class="fc" id="L263">            break;</span>
        case 4:
<span class="fc" id="L265">            packed_chars = getByte2Of4(unicodeScalar);</span>
<span class="fc" id="L266">            packed_chars |= getByte3Of4(unicodeScalar) &lt;&lt; 8;</span>
<span class="fc" id="L267">            packed_chars |= getByte4Of4(unicodeScalar) &lt;&lt; 16;</span>
            break;
        }
<span class="fc" id="L270">        return packed_chars;</span>

    }

    public final static int getScalarFrom4BytesReversed(int utf8BytesReversed)
    {
        //loop to read these bytes out:
        // int b4r = read();
        // switch (getUTF8LengthFromFirstByte(b)) {
        // case 4: b4r |= (read() &lt;&lt; 24);  // fall through
        // case 3: b4r |= (read() &lt;&lt; 16);
        // case 2: b4r |= (read() &lt;&lt;  8);
        // case 1: // nothing to do
        // }
<span class="fc" id="L284">        int c = utf8BytesReversed &amp; 0xff;</span>
<span class="pc bpc" id="L285" title="1 of 5 branches missed.">        switch (getUTF8LengthFromFirstByte(c)) {</span>
        case 1:
<span class="fc" id="L287">            return c;</span>
        case 2:
<span class="fc" id="L289">            c  = ((c &amp; UNICODE_TWO_BYTE_MASK) &lt;&lt; 6);</span>
<span class="fc" id="L290">            c |= ((utf8BytesReversed &gt;&gt; 8) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L291">            return c;</span>
        case 3:
<span class="fc" id="L293">            c  = ((c &amp; UNICODE_THREE_BYTE_MASK) &lt;&lt; 12);</span>
<span class="fc" id="L294">            c |= ((utf8BytesReversed &gt;&gt; 2) &amp; (UNICODE_CONTINUATION_BYTE_MASK) &lt;&lt; 6);</span>
<span class="fc" id="L295">            c |= ((utf8BytesReversed &gt;&gt; 16) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L296">            return c;</span>
        case 4:
<span class="fc" id="L298">            c  = ((c &amp; UNICODE_FOUR_BYTE_MASK) &lt;&lt; 18);</span>
<span class="fc" id="L299">            c |= (((utf8BytesReversed &lt;&lt; 4) &amp; (UNICODE_CONTINUATION_BYTE_MASK) &lt;&lt; 12));</span>
<span class="fc" id="L300">            c |= (((utf8BytesReversed &gt;&gt; 2) &amp; (UNICODE_CONTINUATION_BYTE_MASK) &lt;&lt; 6));</span>
<span class="fc" id="L301">            c |= ((utf8BytesReversed &gt;&gt; 24) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L302">            return c;</span>
        }
<span class="nc" id="L304">        throw new InvalidUnicodeCodePoint();</span>
    }
    /**
     * this helper calculates the number of bytes it will consume from the
     * supplied byte array (bytes) if getScalarFromBytes is called with
     * the same parameters.  This is in place of having getScalarFromBytes
     * return an object with the bytes consumed and the resultant scalar.
     * This will throw ArrayIndexOutOfBoundsException if there are fewer
     * bytes remaining (maxLength) than needed for a valid UTF8 sequence
     * starting at offset.
     * @param bytes UTF8 bytes in user supplied array
     * @param offset first array element to read from
     * @param maxLength maximum number of bytes to read from the array
     * @return number of bytes needed to decode the next scalar
     */
    public final static int getScalarReadLengthFromBytes(byte[] bytes, int offset, int maxLength)
    {
<span class="fc" id="L321">        int src = offset;</span>
<span class="fc" id="L322">        int end = offset + maxLength;</span>

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (src &gt;= end) throw new ArrayIndexOutOfBoundsException();</span>
<span class="fc" id="L325">        int c = bytes[src++] &amp; 0xff;</span>
<span class="fc" id="L326">        int utf8length = getUTF8LengthFromFirstByte(c);</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (src + utf8length &gt; end) throw new ArrayIndexOutOfBoundsException();</span>

<span class="fc" id="L329">        return utf8length;</span>
    }
    /**
     * this helper converts the bytes starting at offset from UTF8 to a
     * Unicode scalar.  This does not check for valid Unicode scalar ranges
     * but simply handle the UTF8 decoding.  getScalarReadLengthFromBytes
     * can be used to determine how many bytes would be converted (consumed) in
     * this process if the same parameters are passed in.  This will throw
     * ArrayIndexOutOfBoundsException if the array has too few bytes to
     * fully decode the scalar. It will throw InvalidUnicodeCodePoint if
     * the first byte isn't a valid UTF8 initial byte with a length of
     * 4 or less.
     * @param bytes UTF8 bytes in an array
     * @param offset initial array element to decode from
     * @param maxLength maximum number of bytes to consume from the array
     * @return Unicode scalar
     */
    public final static int getScalarFromBytes(byte[] bytes, int offset, int maxLength)
    {
<span class="fc" id="L348">        int src = offset;</span>
<span class="fc" id="L349">        int end = offset + maxLength;</span>

<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (src &gt;= end) throw new ArrayIndexOutOfBoundsException();</span>
<span class="fc" id="L352">        int c = bytes[src++] &amp; 0xff;</span>
<span class="fc" id="L353">        int utf8length = getUTF8LengthFromFirstByte(c);</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (src + utf8length &gt; end) throw new ArrayIndexOutOfBoundsException();</span>

<span class="pc bpc" id="L356" title="1 of 5 branches missed.">        switch (utf8length) {</span>
        case 1:
<span class="fc" id="L358">            break;</span>
        case 2:
<span class="fc" id="L360">            c  = (c &amp; UNICODE_TWO_BYTE_MASK);</span>
<span class="fc" id="L361">            c |= ((bytes[src++] &amp; 0xff) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L362">            break;</span>
        case 3:
<span class="fc" id="L364">            c  = (c &amp; UNICODE_THREE_BYTE_MASK);</span>
<span class="fc" id="L365">            c |= ((bytes[src++] &amp; 0xff) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L366">            c |= ((bytes[src++] &amp; 0xff) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L367">            break;</span>
        case 4:
<span class="fc" id="L369">            c  = (c &amp; UNICODE_FOUR_BYTE_MASK);</span>
<span class="fc" id="L370">            c |= ((bytes[src++] &amp; 0xff) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L371">            c |= ((bytes[src++] &amp; 0xff) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L372">            c |= ((bytes[src++] &amp; 0xff) &amp; UNICODE_CONTINUATION_BYTE_MASK);</span>
<span class="fc" id="L373">            break;</span>
        default:
<span class="nc" id="L375">            throw new InvalidUnicodeCodePoint(&quot;code point is invalid: &quot;+utf8length);</span>
        }
<span class="fc" id="L377">        return c;</span>
    }

    public final static boolean needsSurrogateEncoding(int unicodeScalar) {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        return (unicodeScalar &gt; MAXIMUM_UTF16_1_CHAR_CODE_POINT);</span>
    }
    public final static char highSurrogate(int unicodeScalar) {
<span class="pc bpc" id="L384" title="2 of 4 branches missed.">        assert(unicodeScalar &gt; MAXIMUM_UTF16_1_CHAR_CODE_POINT);</span>
<span class="pc bpc" id="L385" title="2 of 4 branches missed.">        assert(unicodeScalar &lt;= Character.MAX_CODE_POINT);</span>
<span class="fc" id="L386">        int c = ((unicodeScalar - SURROGATE_OFFSET) &gt;&gt; 10);</span>
<span class="fc" id="L387">        return (char)((c | HIGH_SURROGATE) &amp; 0xffff);</span>
    }
    public final static char lowSurrogate(int unicodeScalar) {
<span class="pc bpc" id="L390" title="2 of 4 branches missed.">        assert(unicodeScalar &gt; MAXIMUM_UTF16_1_CHAR_CODE_POINT);</span>
<span class="pc bpc" id="L391" title="2 of 4 branches missed.">        assert(unicodeScalar &lt;= Character.MAX_CODE_POINT);</span>
<span class="fc" id="L392">        int c = ((unicodeScalar - SURROGATE_OFFSET) &amp; 0x3ff);</span>
<span class="fc" id="L393">        return (char)((c | LOW_SURROGATE) &amp; 0xffff);</span>
    }
    public final static int getUnicodeScalarFromSurrogates(int highSurrogate, int lowSurrogate)
    {
<span class="pc bpc" id="L397" title="2 of 4 branches missed.">        assert(IonUTF8.isHighSurrogate(highSurrogate));</span>
<span class="pc bpc" id="L398" title="2 of 4 branches missed.">        assert(IonUTF8.isLowSurrogate(lowSurrogate));</span>
        int scalar;
<span class="fc" id="L400">        scalar = lowSurrogate &amp; 0x3ff;</span>
<span class="fc" id="L401">        scalar += (highSurrogate &amp; 0x3ff) &lt;&lt; 10;</span>
<span class="fc" id="L402">        scalar += SURROGATE_OFFSET;</span>
<span class="fc" id="L403">        return scalar;</span>
    }

    public static class InvalidUnicodeCodePoint extends IonException
    {
        private static final long serialVersionUID = -3200811216940328945L;

        public InvalidUnicodeCodePoint() {
<span class="nc" id="L411">            super(&quot;invalid UTF8&quot;);</span>
<span class="nc" id="L412">        }</span>
        public InvalidUnicodeCodePoint(String msg) {
<span class="nc" id="L414">            super(msg);</span>
<span class="nc" id="L415">        }</span>
        public InvalidUnicodeCodePoint(Exception e) {
<span class="nc" id="L417">            super(e);</span>
<span class="nc" id="L418">        }</span>
        public InvalidUnicodeCodePoint(String msg, Exception e) {
<span class="nc" id="L420">            super(msg, e);</span>
<span class="nc" id="L421">        }</span>
    }


    public static final class UTF8ToChar extends OutputStream implements Closeable
    {
        final private Appendable   _char_stream;
        // the pending bytes are being handled like this
        // instead of in a byte array as previous timing
        // of array dereferencing (circa 2009) shows it
        // to be remarkably slow.
<span class="nc" id="L432">              private int          _expected_count = 0;</span>
<span class="nc" id="L433">              private int          _pending_count = 0;</span>
              private int          _pending_c1;
              private int          _pending_c2;
              private int          _pending_c3;

<span class="nc" id="L438">        public UTF8ToChar(Appendable charStream) {</span>
<span class="nc" id="L439">            _char_stream = charStream;</span>
<span class="nc" id="L440">        }</span>
        public final Appendable getAppendable() {
<span class="nc" id="L442">            return _char_stream;</span>
        }

        @Override
        public final void close() throws IOException
        {
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (_pending_count &gt; 0) {</span>
<span class="nc" id="L449">                throw new IOException(&quot;unfinished utf8 sequence still open&quot;);</span>
            }
<span class="nc" id="L451">        }</span>

        @Override
        public final void write(int b) throws IOException
        {
<span class="nc" id="L456">            b = b &amp; 0xff;</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (_expected_count &gt; 0) {</span>
<span class="nc" id="L458">                write_helper_continue(b);</span>
            }
<span class="nc bnc" id="L460" title="All 2 branches missed.">            else if (b &gt; 127) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                if (!IonUTF8.isStartByte(b)) {</span>
<span class="nc" id="L462">                    throw new IOException(&quot;invalid UTF8 sequence: byte &gt; 127 is not a UTF8 leading byte&quot;);</span>
                }
<span class="nc" id="L464">                write_helper_start_sequence(b);</span>
            }
            else {
<span class="nc" id="L467">                _char_stream.append((char)b);</span>
            }
<span class="nc" id="L469">        }</span>

        @Override
        public final void write(byte[] bytes) throws IOException
        {
<span class="nc" id="L474">            write(bytes, 0, bytes.length);</span>
<span class="nc" id="L475">        }</span>

        @Override
        public final void write(byte[] bytes, int off, int len) throws IOException
        {
<span class="nc bnc" id="L480" title="All 2 branches missed.">            for (int ii=off; ii&lt;off+len; ii++) {</span>
<span class="nc" id="L481">                int b = bytes[ii] &amp; 0xff;</span>
<span class="nc bnc" id="L482" title="All 4 branches missed.">                if (_pending_count == 0 &amp;&amp; b &lt; 128) {</span>
<span class="nc" id="L483">                    _char_stream.append((char)b);</span>
                }
                else {
<span class="nc" id="L486">                    write(b);</span>
                }
            }
<span class="nc" id="L489">        }</span>

        private final void write_helper_start_sequence(int b) throws IOException
        {
<span class="nc" id="L493">            _expected_count = IonUTF8.getUTF8LengthFromFirstByte(b);</span>
<span class="nc" id="L494">            _pending_count = 1;</span>
<span class="nc" id="L495">            _pending_c1 = b;</span>
<span class="nc" id="L496">        }</span>
        private final void write_helper_continue(int b) throws IOException
        {
<span class="nc" id="L499">            _pending_count++;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (_expected_count == _pending_count) {</span>
<span class="nc" id="L501">                write_helper_write_char(b);</span>
            }
            else {
<span class="nc bnc" id="L504" title="All 3 branches missed.">                switch(_pending_count) {</span>
                case 2:
<span class="nc" id="L506">                    _pending_c2 = b;</span>
<span class="nc" id="L507">                    break;</span>
                case 3:
<span class="nc" id="L509">                    _pending_c3 = b;</span>
<span class="nc" id="L510">                    break;</span>
                default:
<span class="nc" id="L512">                    throw new IOException(&quot;invalid state for pending vs expected UTF8 bytes&quot;);</span>
                }
            }
<span class="nc" id="L515">        }</span>
        private final void write_helper_write_char(int b) throws IOException
        {
            char c;
            int  s;
<span class="nc bnc" id="L520" title="All 4 branches missed.">            switch(_pending_count) {</span>
            case 2:
<span class="nc bnc" id="L522" title="All 2 branches missed.">                if (!IonUTF8.isContinueByteUTF8(b)) {</span>
<span class="nc" id="L523">                    throwBadContinuationByte();</span>
                }
<span class="nc" id="L525">                c = IonUTF8.twoByteScalar(_pending_c1, b);</span>
<span class="nc" id="L526">                _char_stream.append(c);</span>
<span class="nc" id="L527">                break;</span>
            case 3:
<span class="nc bnc" id="L529" title="All 2 branches missed.">                if (!IonUTF8.isContinueByteUTF8(b)) {</span>
<span class="nc" id="L530">                    throwBadContinuationByte();</span>
                }
<span class="nc bnc" id="L532" title="All 2 branches missed.">                if (!IonUTF8.isContinueByteUTF8(_pending_c2)) {</span>
<span class="nc" id="L533">                    throwBadContinuationByte();</span>
                }
<span class="nc" id="L535">                s = IonUTF8.threeByteScalar(_pending_c1, _pending_c2, b);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                if (IonUTF8.needsSurrogateEncoding(s)) {</span>
<span class="nc" id="L537">                    _char_stream.append(IonUTF8.lowSurrogate(s));</span>
<span class="nc" id="L538">                    _char_stream.append(IonUTF8.highSurrogate(s));</span>
                }
                else {
<span class="nc" id="L541">                    _char_stream.append((char)s);</span>
                }
<span class="nc" id="L543">                break;</span>
            case 4:
<span class="nc bnc" id="L545" title="All 2 branches missed.">                if (!IonUTF8.isContinueByteUTF8(b)) {</span>
<span class="nc" id="L546">                    throwBadContinuationByte();</span>
                }
<span class="nc bnc" id="L548" title="All 2 branches missed.">                if (!IonUTF8.isContinueByteUTF8(_pending_c2)) {</span>
<span class="nc" id="L549">                    throwBadContinuationByte();</span>
                }
<span class="nc bnc" id="L551" title="All 2 branches missed.">                if (!IonUTF8.isContinueByteUTF8(_pending_c3)) {</span>
<span class="nc" id="L552">                    throwBadContinuationByte();</span>
                }
<span class="nc" id="L554">                s = IonUTF8.fourByteScalar(_pending_c1, _pending_c2, _pending_c3, b);</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">                if (IonUTF8.needsSurrogateEncoding(s)) {</span>
<span class="nc" id="L556">                    _char_stream.append(IonUTF8.lowSurrogate(s));</span>
<span class="nc" id="L557">                    _char_stream.append(IonUTF8.highSurrogate(s));</span>
                }
                else {
<span class="nc" id="L560">                    _char_stream.append((char)s);</span>
                }
<span class="nc" id="L562">                break;</span>
            default:
<span class="nc" id="L564">                throw new IOException(&quot;invalid state for UTF8 sequence length &quot;+_pending_count);</span>
            }
<span class="nc" id="L566">        }</span>
        private void throwBadContinuationByte() throws IOException
        {
<span class="nc" id="L569">            throw new IOException(&quot;continuation byte expected&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>