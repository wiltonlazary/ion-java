<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OutputStreamFastAppendable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">OutputStreamFastAppendable.java</span></div><h1>OutputStreamFastAppendable.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import static com.amazon.ion.impl._Private_IonConstants.makeUnicodeScalar;

import com.amazon.ion.util._Private_FastAppendable;
import java.io.Closeable;
import java.io.Flushable;
import java.io.IOException;
import java.io.OutputStream;

/**
 * Adapts an {@link OutputStream} to implement {@link _Private_FastAppendable}.
 * &lt;b&gt;This always outputs UTF-8!&lt;/b&gt;
 */
<span class="pc bpc" id="L30" title="1 of 2 branches missed.">final class OutputStreamFastAppendable</span>
    implements _Private_FastAppendable, Closeable, Flushable
{
    private static final int MAX_BYTES_LEN = 4096;

    private final OutputStream _out;

    /** Aggregates bytes so we can write to {@link #_out} in large batches. */
    private final byte[] _byteBuffer;

    /** Position in {@link #_byteBuffer} where we'll write the next byte. */
    private int _pos;

    OutputStreamFastAppendable(OutputStream out)
<span class="fc" id="L44">    {</span>
<span class="fc" id="L45">        out.getClass(); // Efficient null check</span>

<span class="fc" id="L47">        _out = out;</span>
<span class="fc" id="L48">        _pos = 0;</span>
<span class="fc" id="L49">        _byteBuffer = new byte[MAX_BYTES_LEN];</span>
<span class="fc" id="L50">    }</span>

    // ------------------- FastAppendable Appendable Methods -------------------
    public Appendable append(char c)
        throws IOException
    {
        // Choose what method to use depending on type of character.
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (c &lt; 0x80) {</span>
<span class="fc" id="L58">            appendAscii(c);</span>
        } else {
<span class="nc" id="L60">            appendUtf16(c);</span>
        }
<span class="fc" id="L62">        return this;</span>
    }

    public Appendable append(CharSequence csq)
        throws IOException
    {
<span class="fc" id="L68">        append(csq, 0, csq.length());</span>
<span class="fc" id="L69">        return this;</span>
    }

    public Appendable append(CharSequence csq, int start, int end)
        throws IOException
    {
<span class="fc bfc" id="L75" title="All 2 branches covered.">        for (int ii = start; ii &lt; end; ++ii) {</span>
<span class="fc" id="L76">            append(csq.charAt(ii));</span>
        }
<span class="fc" id="L78">        return this;</span>
    }

    public final void appendAscii(char c)
        throws IOException
    {
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (_pos == _byteBuffer.length) {</span>
<span class="fc" id="L85">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="fc" id="L86">            _pos = 0;</span>
        }
<span class="pc bpc" id="L88" title="2 of 4 branches missed.">        assert c &lt; 0x80;</span>
<span class="fc" id="L89">        _byteBuffer[_pos++] = (byte)c;</span>
<span class="fc" id="L90">    }</span>

    public final void appendAscii(CharSequence csq)
        throws IOException
    {
<span class="fc" id="L95">        appendAscii(csq, 0, csq.length());</span>
<span class="fc" id="L96">    }</span>

    @SuppressWarnings(&quot;deprecation&quot;)
    public final void appendAscii(CharSequence csq, int start, int end)
        throws IOException
    {
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (csq instanceof String) {</span>
            // Using deprecated String.getBytes intentionally, since it is
            // correct behavior in this case, and much faster.
<span class="fc" id="L105">            String str = (String)csq;</span>
<span class="fc" id="L106">            int len = end - start;</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">            if (_pos + len &lt; _byteBuffer.length) {</span>
                // put String bytes directly into buffer
<span class="fc" id="L109">                str.getBytes(start, end, _byteBuffer, _pos);</span>
<span class="fc" id="L110">                _pos += len;</span>
            } else {
                do {
                    // flush the buffer on every loop
<span class="fc" id="L114">                    _out.write(_byteBuffer, 0, _pos);</span>
                    // check if we still need to split into chunks
<span class="fc bfc" id="L116" title="All 2 branches covered.">                    _pos = (end - start &gt; _byteBuffer.length</span>
<span class="fc" id="L117">                                ? _byteBuffer.length</span>
<span class="fc" id="L118">                                : end - start);</span>
<span class="fc" id="L119">                    str.getBytes(start, start + _pos, _byteBuffer, 0);</span>
<span class="fc" id="L120">                    start += _pos;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">                } while (start &lt; end);</span>
            }
<span class="fc" id="L123">        } else {</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            for (int ii=start; ii &lt; end; ii++) {</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                if (_pos == _byteBuffer.length) {</span>
<span class="nc" id="L126">                    _out.write(_byteBuffer, 0, _pos);</span>
<span class="nc" id="L127">                    _pos = 0;</span>
                }
<span class="fc" id="L129">                char c = csq.charAt(ii);</span>
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">                assert c &lt; 0x80;</span>
<span class="fc" id="L131">                _byteBuffer[_pos++] = (byte)c;</span>
            }
        }
<span class="fc" id="L134">    }</span>

    public final void appendUtf16(char c)
        throws IOException
    {
<span class="pc bpc" id="L139" title="2 of 4 branches missed.">        assert c &gt;= 0x80;</span>

<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (_pos &gt; _byteBuffer.length - 3) {</span>
<span class="nc" id="L142">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="nc" id="L143">            _pos = 0;</span>
        }

<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (c &lt; 0x800) {</span>
<span class="fc" id="L147">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0xC0 | ( c &gt;&gt; 6        )) );</span>
<span class="fc" id="L148">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ( c       &amp; 0x3F)) );</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        } else if (c &lt; 0x10000) {</span>
<span class="fc" id="L150">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0xE0 | ( c &gt;&gt; 12       )) );</span>
<span class="fc" id="L151">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ((c &gt;&gt; 6) &amp; 0x3F)) );</span>
<span class="fc" id="L152">            _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ( c       &amp; 0x3F)) );</span>
        }
<span class="fc" id="L154">    }</span>

    public final void appendUtf16Surrogate(char leadSurrogate,
                                           char trailSurrogate)
        throws IOException
    {
        // Here we must convert a UTF-16 surrogate pair to UTF-8 bytes.

<span class="fc" id="L162">        int c = makeUnicodeScalar(leadSurrogate, trailSurrogate);</span>
<span class="pc bpc" id="L163" title="2 of 4 branches missed.">        assert c &gt;= 0x10000;</span>

<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (_pos &gt; _byteBuffer.length - 4) {</span>
<span class="nc" id="L166">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="nc" id="L167">            _pos = 0;</span>
        }

<span class="fc" id="L170">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0xF0 | ( c &gt;&gt; 18        )) );</span>
<span class="fc" id="L171">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ((c &gt;&gt; 12) &amp; 0x3F)) );</span>
<span class="fc" id="L172">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ((c &gt;&gt; 6)  &amp; 0x3F)) );</span>
<span class="fc" id="L173">        _byteBuffer[_pos++] = (byte)( 0xff &amp; (0x80 | ( c        &amp; 0x3F)) );</span>
<span class="fc" id="L174">    }</span>


    public final void flush()
        throws IOException
    {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if (_pos &gt; 0) {</span>
<span class="fc" id="L181">            _out.write(_byteBuffer, 0, _pos);</span>
<span class="fc" id="L182">            _pos = 0;</span>
        }
<span class="fc" id="L184">        _out.flush();</span>
<span class="fc" id="L185">    }</span>

    public final void close()
        throws IOException
    {
        try
        {
<span class="fc" id="L192">            flush();</span>
        }
        finally
        {
<span class="fc" id="L196">            _out.close();</span>
        }
<span class="fc" id="L198">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>