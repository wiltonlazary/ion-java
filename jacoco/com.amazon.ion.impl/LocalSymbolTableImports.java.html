<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LocalSymbolTableImports.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">LocalSymbolTableImports.java</span></div><h1>LocalSymbolTableImports.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import static com.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;

import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import java.util.Arrays;
import java.util.List;

/**
 * This class manages the system symbol table and any shared symbol table(s)
 * imported by a local symbol table. It provides &quot;find&quot; methods to find
 * either symbol Ids or names in the imported tables.
 * &lt;p&gt;
 * This class is &lt;b&gt;immutable&lt;/b&gt;, and hence safe for use by multiple threads.
 */
// TODO amzn/ion-java/issues/37 Create specialized class to handle the common case where
//      there are zero or one imported non-system shared symtab(s).
<span class="pc bpc" id="L34" title="1 of 2 branches missed.">final class LocalSymbolTableImports</span>
{
    /**
     * The symtabs imported by a local symtab, never null or empty. The first
     * symtab must be a system symtab, the rest must be non-system shared
     * symtabs.
     */
    private final SymbolTable[] myImports;

    /**
     * The maxId of all imported tables, i.e., the sum of all maxIds declared
     * by symtabs in {@link #myImports}.
     */
    private final int           myMaxId;

    /**
     * The base Sid of each symtab in {@link #myImports} in parallel, i.e.,
     * {@link #myBaseSids}[0] references {@link #myImports}[0]. Must be
     * the same length as {@link #myImports}.
     */
    private final int[]         myBaseSids;

    //==========================================================================
    // Constructor(s) and static factory methods
    //==========================================================================

    /**
     * Constructor, takes the passed-in {@code importTables} containing the
     * imported symtabs.
     *
     * @param importTables
     *          the imported symtabs, must contain at least one element; the
     *          first element must be a system symtab, the rest must be
     *          non-system shared symtabs
     *
     * @throws IllegalArgumentException
     *          if any import is a local table, or if any but the first is a
     *          system table
     * @throws NullPointerException
     *          if any import is null
     */
    LocalSymbolTableImports(List&lt;SymbolTable&gt; importTables)
<span class="fc" id="L76">    {</span>
<span class="fc" id="L77">        int importTablesSize = importTables.size();</span>

<span class="fc" id="L79">        myImports = importTables.toArray(new SymbolTable[importTablesSize]);</span>

<span class="fc" id="L81">        myBaseSids = new int[importTablesSize];</span>
<span class="fc" id="L82">        myMaxId = prepBaseSids(myBaseSids, myImports);</span>
<span class="fc" id="L83">    }</span>

    /**
     * @param defaultSystemSymtab
     *          the default system symtab, which will be used if the first
     *          import in {@code imports} isn't a system symtab, never null
     * @param imports
     *          the set of shared symbol tables to import; the first (and only
     *          the first) may be a system table, in which case the
     *          {@code defaultSystemSymtab is ignored}
     *
     * @throws IllegalArgumentException
     *          if any import is a local table, or if any but the first is a
     *          system table
     * @throws NullPointerException
     *          if any import is null
     */
    LocalSymbolTableImports(SymbolTable defaultSystemSymtab,
                            SymbolTable... imports)
<span class="fc" id="L102">    {</span>
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">        assert defaultSystemSymtab.isSystemTable()</span>
            : &quot;defaultSystemSymtab isn't a system symtab&quot;;

<span class="fc bfc" id="L106" title="All 4 branches covered.">        if (imports != null &amp;&amp; imports.length &gt; 0)</span>
        {
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (imports[0].isSystemTable())</span>
            {
                // copy imports as-is
<span class="fc" id="L111">                myImports = imports.clone();</span>
            }
            else
            {
                // use defaultSystemSymtab and append imports
<span class="fc" id="L116">                myImports = new SymbolTable[imports.length + 1];</span>
<span class="fc" id="L117">                myImports[0] = defaultSystemSymtab;</span>
<span class="fc" id="L118">                System.arraycopy(imports, 0, myImports, 1, imports.length);</span>
            }
        }
        else
        {
            // use defaultSystemSymtab only
<span class="fc" id="L124">            myImports = new SymbolTable[] { defaultSystemSymtab };</span>
        }

<span class="fc" id="L127">        myBaseSids = new int[myImports.length];</span>
<span class="fc" id="L128">        myMaxId = prepBaseSids(myBaseSids, myImports);</span>
<span class="fc" id="L129">    }</span>

    /**
     * Collects the necessary maxId info. from the passed-in {@code imports}
     * and populates the {@code baseSids} array.
     *
     * @return the sum of all imports' maxIds
     *
     * @throws IllegalArgumentException
     *          if any symtab beyond the first is a local or system symtab
     */
    private static int prepBaseSids(int[] baseSids, SymbolTable[] imports)
    {
<span class="fc" id="L142">        SymbolTable firstImport = imports[0];</span>

<span class="pc bpc" id="L144" title="2 of 4 branches missed.">        assert firstImport.isSystemTable()</span>
            : &quot;first symtab must be a system symtab&quot;;

<span class="fc" id="L147">        baseSids[0] = 0;</span>
<span class="fc" id="L148">        int total = firstImport.getMaxId();</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (int i = 1; i &lt; imports.length; i++)</span>
        {
<span class="fc" id="L152">            SymbolTable importedTable = imports[i];</span>

<span class="fc bfc" id="L154" title="All 4 branches covered.">            if (importedTable.isLocalTable() || importedTable.isSystemTable())</span>
            {
<span class="fc" id="L156">                String message = &quot;only non-system shared tables can be imported&quot;;</span>
<span class="fc" id="L157">                throw new IllegalArgumentException(message);</span>
            }

<span class="fc" id="L160">            baseSids[i] = total;</span>
<span class="fc" id="L161">            total += imports[i].getMaxId();</span>
        }

<span class="fc" id="L164">        return total;</span>
    }

    //==========================================================================

    String findKnownSymbol(int sid)
    {
<span class="fc" id="L171">        String name = null;</span>

<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        if (sid &lt;= myMaxId)</span>
        {
<span class="fc" id="L175">            int i, previousBaseSid = 0;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">            for (i = 1; i &lt; myImports.length; i++)</span>
            {
<span class="fc" id="L178">                int baseSid = myBaseSids[i];</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                if (sid &lt;= baseSid)</span>
                {
<span class="fc" id="L181">                    break;</span>
                }
<span class="fc" id="L183">                previousBaseSid = baseSid;</span>
            }

            // if we run over myImports.length, the sid is in the last symtab
<span class="fc" id="L187">            int importScopedSid = sid - previousBaseSid;</span>
<span class="fc" id="L188">            name = myImports[i-1].findKnownSymbol(importScopedSid);</span>
        }

<span class="fc" id="L191">        return name;</span>
    }

    int findSymbol(String name)
    {
<span class="fc" id="L196">        SymbolToken tok = find(name);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        return (tok == null ? UNKNOWN_SYMBOL_ID : tok.getSid());</span>
    }

    /**
     * Finds a symbol already interned by an import, returning the lowest
     * known SID.
     * &lt;p&gt;
     * This method will not necessarily return the same instance given the
     * same input.
     *
     * @param text the symbol text to find
     *
     * @return
     *          the interned symbol (with both text and SID), or {@code null}
     *          if it's not defined by an imported table
     */
    SymbolToken find(String text)
    {
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (int i = 0; i &lt; myImports.length; i++)</span>
        {
<span class="fc" id="L217">            SymbolTable importedTable = myImports[i];</span>
<span class="fc" id="L218">            SymbolToken tok = importedTable.find(text);</span>

<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (tok != null)</span>
            {
<span class="fc" id="L222">                int sid = tok.getSid() + myBaseSids[i];</span>
<span class="fc" id="L223">                text = tok.getText(); // Use interned instance</span>

<span class="pc bpc" id="L225" title="2 of 4 branches missed.">                assert text != null;</span>

<span class="fc" id="L227">                return new SymbolTokenImpl(text, sid);</span>
            }
        }
<span class="fc" id="L230">        return null;</span>
    }

    int getMaxId()
    {
<span class="fc" id="L235">        return myMaxId;</span>
    }

    /**
     * Gets the sole system symtab.
     */
    SymbolTable getSystemSymbolTable()
    {
<span class="pc bpc" id="L243" title="2 of 4 branches missed.">        assert myImports[0].isSystemTable();</span>
<span class="fc" id="L244">        return myImports[0];</span>
    }

    /**
     * Gets all non-system shared symtabs (if any).
     *
     * @return a newly allocated copy of the imported symtabs
     */
    SymbolTable[] getImportedTables()
    {
<span class="fc" id="L254">        int count = myImports.length - 1; // we don't include system symtab</span>
<span class="fc" id="L255">        SymbolTable[] imports = new SymbolTable[count];</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (count &gt; 0)</span>
        {
            // defensive copy
<span class="fc" id="L259">            System.arraycopy(myImports, 1, imports, 0, count);</span>
        }
<span class="fc" id="L261">        return imports;</span>
    }

    /**
     * Returns the {@link #myImports} member field without making a copy.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; Callers must not modify the resulting SymbolTable array!
     * This will violate the immutability property of this class.
     *
     * @return
     *          the backing array of imported symtabs, as-is; the first element
     *          is a system symtab, the rest are non-system shared symtabs
     *
     * @see #getImportedTables()
     */
    SymbolTable[] getImportedTablesNoCopy()
    {
<span class="fc" id="L278">        return myImports;</span>
    }

    @Override
    public String toString()
    {
<span class="nc" id="L284">        return Arrays.toString(myImports);</span>
    }

    /**
     * Determines whether the passed-in instance has the same sequence of
     * symbol table imports as this instance. Note that equality of these
     * imports are checked using their reference, instead of their semantic
     * state.
     */
    boolean equalImports(LocalSymbolTableImports other)
    {
<span class="fc" id="L295">        return Arrays.equals(myImports, other.myImports);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>