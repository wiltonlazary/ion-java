<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrivateIonTextAppender.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">PrivateIonTextAppender.java</span></div><h1>PrivateIonTextAppender.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import static software.amazon.ion.impl.PrivateIonConstants.MAX_LONG_TEXT_SIZE;
import static software.amazon.ion.impl.PrivateIonConstants.isHighSurrogate;
import static software.amazon.ion.impl.PrivateIonConstants.isLowSurrogate;
import static software.amazon.ion.impl.PrivateIonConstants.makeUnicodeScalar;

import java.io.ByteArrayInputStream;
import java.io.Closeable;
import java.io.Flushable;
import java.io.IOException;
import java.io.OutputStream;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import software.amazon.ion.Decimal;
import software.amazon.ion.impl.Base64Encoder.TextStream;
import software.amazon.ion.system.IonTextWriterBuilder;
import software.amazon.ion.util.PrivateFastAppendable;


/**
 * Generic text sink that enables optimized output of both ASCII and UTF-16.
 *
 * @deprecated This is an internal API that is subject to change without notice.
 */
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">@Deprecated</span>
public final class PrivateIonTextAppender
    implements Closeable, Flushable
{
    private static boolean is8bitValue(int v)
    {
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">        return (v &amp; ~0xff) == 0;</span>
    }

    private static boolean isDecimalDigit(int codePoint)
    {
<span class="fc bfc" id="L53" title="All 4 branches covered.">        return (codePoint &gt;= '0' &amp;&amp; codePoint &lt;= '9');</span>
    }

    private static final boolean[] IDENTIFIER_START_CHAR_FLAGS;
    private static final boolean[] IDENTIFIER_FOLLOW_CHAR_FLAGS;
    static
    {
<span class="fc" id="L60">        IDENTIFIER_START_CHAR_FLAGS = new boolean[256];</span>
<span class="fc" id="L61">        IDENTIFIER_FOLLOW_CHAR_FLAGS = new boolean[256];</span>

<span class="fc bfc" id="L63" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L64">            IDENTIFIER_START_CHAR_FLAGS[ii]  = true;</span>
<span class="fc" id="L65">            IDENTIFIER_FOLLOW_CHAR_FLAGS[ii] = true;</span>
        }
<span class="fc bfc" id="L67" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L68">            IDENTIFIER_START_CHAR_FLAGS[ii]  = true;</span>
<span class="fc" id="L69">            IDENTIFIER_FOLLOW_CHAR_FLAGS[ii] = true;</span>
        }
<span class="fc" id="L71">        IDENTIFIER_START_CHAR_FLAGS ['_'] = true;</span>
<span class="fc" id="L72">        IDENTIFIER_FOLLOW_CHAR_FLAGS['_'] = true;</span>

<span class="fc" id="L74">        IDENTIFIER_START_CHAR_FLAGS ['$'] = true;</span>
<span class="fc" id="L75">        IDENTIFIER_FOLLOW_CHAR_FLAGS['$'] = true;</span>

<span class="fc bfc" id="L77" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L78">            IDENTIFIER_FOLLOW_CHAR_FLAGS[ii] = true;</span>
        }
    }

    public static boolean isIdentifierStart(int codePoint) {
<span class="pc bpc" id="L83" title="1 of 4 branches missed.">        return IDENTIFIER_START_CHAR_FLAGS[codePoint &amp; 0xff] &amp;&amp; is8bitValue(codePoint);</span>
    }

    public static boolean isIdentifierPart(int codePoint) {
<span class="pc bpc" id="L87" title="1 of 4 branches missed.">        return IDENTIFIER_FOLLOW_CHAR_FLAGS[codePoint &amp; 0xff] &amp;&amp; is8bitValue(codePoint);</span>
    }

    public static final boolean[] OPERATOR_CHAR_FLAGS;
    static
    {
<span class="fc" id="L93">        final char[] operatorChars = {</span>
            '&lt;', '&gt;', '=', '+', '-', '*', '&amp;', '^', '%',
            '~', '/', '?', '.', ';', '!', '|', '@', '`', '#'
           };

<span class="fc" id="L98">        OPERATOR_CHAR_FLAGS = new boolean[256];</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">        for (int ii=0; ii&lt;operatorChars.length; ii++) {</span>
<span class="fc" id="L101">            char operator = operatorChars[ii];</span>
<span class="fc" id="L102">            OPERATOR_CHAR_FLAGS[operator] = true;</span>
        }
    }

    public static boolean isOperatorPart(int codePoint) {
<span class="pc bpc" id="L107" title="1 of 4 branches missed.">        return OPERATOR_CHAR_FLAGS[codePoint &amp; 0xff] &amp;&amp; is8bitValue(codePoint);</span>
    }


<span class="fc" id="L111">    public static final String[] ZERO_PADDING =</span>
    {
        &quot;&quot;,
        &quot;0&quot;,
        &quot;00&quot;,
        &quot;000&quot;,
        &quot;0000&quot;,
        &quot;00000&quot;,
        &quot;000000&quot;,
        &quot;0000000&quot;,
    };


    /**
     * Escapes for U+00 through U+FF, for use in double-quoted Ion strings.
     * This includes escapes for all LATIN-1 code points U+80 through U+FF.
     */
    private static final String[] STRING_ESCAPE_CODES;
    static
    {
<span class="fc" id="L131">        STRING_ESCAPE_CODES = new String[256];</span>
<span class="fc" id="L132">        STRING_ESCAPE_CODES[0x00] = &quot;\\0&quot;;</span>
<span class="fc" id="L133">        STRING_ESCAPE_CODES[0x07] = &quot;\\a&quot;;</span>
<span class="fc" id="L134">        STRING_ESCAPE_CODES[0x08] = &quot;\\b&quot;;</span>
<span class="fc" id="L135">        STRING_ESCAPE_CODES['\t'] = &quot;\\t&quot;;</span>
<span class="fc" id="L136">        STRING_ESCAPE_CODES['\n'] = &quot;\\n&quot;;</span>
<span class="fc" id="L137">        STRING_ESCAPE_CODES[0x0B] = &quot;\\v&quot;;</span>
<span class="fc" id="L138">        STRING_ESCAPE_CODES['\f'] = &quot;\\f&quot;;</span>
<span class="fc" id="L139">        STRING_ESCAPE_CODES['\r'] = &quot;\\r&quot;;</span>
<span class="fc" id="L140">        STRING_ESCAPE_CODES['\\'] = &quot;\\\\&quot;;</span>
<span class="fc" id="L141">        STRING_ESCAPE_CODES['\&quot;'] = &quot;\\\&quot;&quot;;</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (int i = 1; i &lt; 0x20; ++i) {</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            if (STRING_ESCAPE_CODES[i] == null) {</span>
<span class="fc" id="L144">                String s = Integer.toHexString(i);</span>
<span class="fc" id="L145">                STRING_ESCAPE_CODES[i] = &quot;\\x&quot; + ZERO_PADDING[2 - s.length()] + s;</span>
            }
        }
<span class="fc bfc" id="L148" title="All 2 branches covered.">        for (int i = 0x7F; i &lt; 0x100; ++i) {</span>
<span class="fc" id="L149">            String s = Integer.toHexString(i);</span>
<span class="fc" id="L150">            STRING_ESCAPE_CODES[i] = &quot;\\x&quot; + s;</span>
        }
    }

    /**
     * Escapes for U+00 through U+FF, for use in triple-quoted Ion strings.
     * This includes escapes for all LATIN-1 code points U+80 through U+FF.
     */
    static final String[] LONG_STRING_ESCAPE_CODES;
    static
    {
<span class="fc" id="L161">        LONG_STRING_ESCAPE_CODES = new String[256];</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (int i = 0; i &lt; 256; ++i) {</span>
<span class="fc" id="L163">            LONG_STRING_ESCAPE_CODES[i] = STRING_ESCAPE_CODES[i];</span>
        }
<span class="fc" id="L165">        LONG_STRING_ESCAPE_CODES['\n'] = null;</span>
<span class="fc" id="L166">        LONG_STRING_ESCAPE_CODES['\''] = &quot;\\\'&quot;;</span>
<span class="fc" id="L167">        LONG_STRING_ESCAPE_CODES['\&quot;'] = null; // Treat as normal code point for long string</span>
    }

    /**
     * Escapes for U+00 through U+FF, for use in single-quoted Ion symbols.
     * This includes escapes for all LATIN-1 code points U+80 through U+FF.
     */
    static final String[] SYMBOL_ESCAPE_CODES;
    static
    {
<span class="fc" id="L177">        SYMBOL_ESCAPE_CODES = new String[256];</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (int i = 0; i &lt; 256; ++i) {</span>
<span class="fc" id="L179">            SYMBOL_ESCAPE_CODES[i] = STRING_ESCAPE_CODES[i];</span>
        }
<span class="fc" id="L181">        SYMBOL_ESCAPE_CODES['\''] = &quot;\\\'&quot;;</span>
<span class="fc" id="L182">        SYMBOL_ESCAPE_CODES['\&quot;'] = null; // Treat as normal code point for symbol.</span>
    }

    /**
     * Escapes for U+00 through U+FF, for use in double-quoted JSON strings.
     * This includes escapes for all LATIN-1 code points U+80 through U+FF.
     */
    static final String[] JSON_ESCAPE_CODES;
    static
    {
<span class="fc" id="L192">        JSON_ESCAPE_CODES = new String[256];</span>
<span class="fc" id="L193">        JSON_ESCAPE_CODES[0x08] = &quot;\\b&quot;;</span>
<span class="fc" id="L194">        JSON_ESCAPE_CODES['\t'] = &quot;\\t&quot;;</span>
<span class="fc" id="L195">        JSON_ESCAPE_CODES['\n'] = &quot;\\n&quot;;</span>
<span class="fc" id="L196">        JSON_ESCAPE_CODES['\f'] = &quot;\\f&quot;;</span>
<span class="fc" id="L197">        JSON_ESCAPE_CODES['\r'] = &quot;\\r&quot;;</span>
<span class="fc" id="L198">        JSON_ESCAPE_CODES['\\'] = &quot;\\\\&quot;;</span>
<span class="fc" id="L199">        JSON_ESCAPE_CODES['\&quot;'] = &quot;\\\&quot;&quot;;</span>

        // JSON requires all of these characters to be escaped.
<span class="fc bfc" id="L202" title="All 2 branches covered.">        for (int i = 0; i &lt; 0x20; ++i) {</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">            if (JSON_ESCAPE_CODES[i] == null) {</span>
<span class="fc" id="L204">                String s = Integer.toHexString(i);</span>
<span class="fc" id="L205">                JSON_ESCAPE_CODES[i] = &quot;\\u&quot; + ZERO_PADDING[4 - s.length()] + s;</span>
            }
        }

<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (int i = 0x7F; i &lt; 0x100; ++i) {</span>
<span class="fc" id="L210">            String s = Integer.toHexString(i);</span>
<span class="fc" id="L211">            JSON_ESCAPE_CODES[i] = &quot;\\u00&quot; + s;</span>
        }
<span class="fc" id="L213">    }</span>

    private static final String HEX_4_PREFIX = &quot;\\u&quot;;
    private static final String HEX_8_PREFIX = &quot;\\U&quot;;
    private static final String TRIPLE_QUOTES = &quot;'''&quot;;


    //=========================================================================


    private final PrivateFastAppendable myAppendable;
    private final boolean escapeNonAscii;


    PrivateIonTextAppender(PrivateFastAppendable out, boolean escapeNonAscii)
<span class="fc" id="L228">    {</span>
<span class="fc" id="L229">        this.myAppendable   = out;</span>
<span class="fc" id="L230">        this.escapeNonAscii = escapeNonAscii;</span>
<span class="fc" id="L231">    }</span>


    public static PrivateIonTextAppender
    forFastAppendable(PrivateFastAppendable out, Charset charset)
    {
<span class="fc" id="L237">        boolean escapeNonAscii = charset.equals(PrivateUtils.ASCII_CHARSET);</span>
<span class="fc" id="L238">        return new PrivateIonTextAppender(out, escapeNonAscii);</span>
    }


    /**
     * @param charset must be either {@link IonTextWriterBuilder#ASCII} or
     * {@link IonTextWriterBuilder#UTF8}. When ASCII is used, all non-ASCII
     * characters will be escaped. Otherwise, only select code points will be
     * escaped.
     */
    public static PrivateIonTextAppender forAppendable(Appendable out,
                                                         Charset charset)
    {
<span class="nc" id="L251">        PrivateFastAppendable fast = new AppendableFastAppendable(out);</span>
<span class="nc" id="L252">        return forFastAppendable(fast, charset);</span>
    }


    /**
     * Doesn't escape non-ASCII characters.
     */
    public static PrivateIonTextAppender forAppendable(Appendable out)
    {
<span class="fc" id="L261">        PrivateFastAppendable fast = new AppendableFastAppendable(out);</span>
<span class="fc" id="L262">        boolean escapeNonAscii = false;</span>
<span class="fc" id="L263">        return new PrivateIonTextAppender(fast, escapeNonAscii);</span>
    }


    /**
     * @param charset must be either {@link IonTextWriterBuilder#ASCII} or
     * {@link IonTextWriterBuilder#UTF8}. When ASCII is used, all non-ASCII
     * characters will be escaped. Otherwise, only select code points will be
     * escaped.
     */
    public static PrivateIonTextAppender forOutputStream(OutputStream out,
                                                           Charset charset)
    {
<span class="nc" id="L276">        PrivateFastAppendable fast = new OutputStreamFastAppendable(out);</span>
<span class="nc" id="L277">        return forFastAppendable(fast, charset);</span>
    }


    //=========================================================================


    public void flush()
        throws IOException
    {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (myAppendable instanceof Flushable)</span>
        {
<span class="fc" id="L289">            ((Flushable) myAppendable).flush();</span>
        }
<span class="fc" id="L291">    }</span>

    public void close()
        throws IOException
    {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (myAppendable instanceof Closeable)</span>
        {
<span class="fc" id="L298">            ((Closeable) myAppendable).close();</span>
        }
<span class="fc" id="L300">    }</span>


    public void appendAscii(char c)
        throws IOException
    {
<span class="fc" id="L306">        myAppendable.appendAscii(c);</span>
<span class="fc" id="L307">    }</span>

    public void appendAscii(CharSequence csq)
        throws IOException
    {
<span class="fc" id="L312">        myAppendable.appendAscii(csq);</span>
<span class="fc" id="L313">    }</span>

    public void appendAscii(CharSequence csq, int start, int end)
        throws IOException
    {
<span class="fc" id="L318">        myAppendable.appendAscii(csq, start, end);</span>
<span class="fc" id="L319">    }</span>

    public void appendUtf16(char c)
        throws IOException
    {
<span class="fc" id="L324">        myAppendable.appendUtf16(c);</span>
<span class="fc" id="L325">    }</span>

    public void appendUtf16Surrogate(char leadSurrogate, char trailSurrogate)
        throws IOException
    {
<span class="fc" id="L330">        myAppendable.appendUtf16Surrogate(leadSurrogate, trailSurrogate);</span>
<span class="fc" id="L331">    }</span>


    //=========================================================================


    /**
     * Print an Ion String type
     * @param text
     * @throws IOException
     */
    public final void printString(CharSequence text)
        throws IOException
    {
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (text == null)</span>
        {
<span class="fc" id="L347">            appendAscii(&quot;null.string&quot;);</span>
        }
        else
        {
<span class="fc" id="L351">            appendAscii('&quot;');</span>
<span class="fc" id="L352">            printCodePoints(text, STRING_ESCAPE_CODES);</span>
<span class="fc" id="L353">            appendAscii('&quot;');</span>
        }
<span class="fc" id="L355">    }</span>

    /**
     * Print an Ion triple-quoted string
     * @param text
     * @throws IOException
     */
    public final void printLongString(CharSequence text)
        throws IOException
    {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">        if (text == null)</span>
        {
<span class="nc" id="L367">            appendAscii(&quot;null.string&quot;);</span>
        }
        else
        {
<span class="fc" id="L371">            appendAscii(TRIPLE_QUOTES);</span>
<span class="fc" id="L372">            printCodePoints(text, LONG_STRING_ESCAPE_CODES);</span>
<span class="fc" id="L373">            appendAscii(TRIPLE_QUOTES);</span>
        }
<span class="fc" id="L375">    }</span>

    /**
     * Print a JSON string
     * @param text
     * @throws IOException
     */
    public final void printJsonString(CharSequence text)
        throws IOException
    {
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">        if (text == null)</span>
        {
<span class="nc" id="L387">            appendAscii(&quot;null&quot;);</span>
        }
        else
        {
<span class="fc" id="L391">            appendAscii('&quot;');</span>
<span class="fc" id="L392">            printCodePoints(text, JSON_ESCAPE_CODES);</span>
<span class="fc" id="L393">            appendAscii('&quot;');</span>
        }
<span class="fc" id="L395">    }</span>


    /**
     * Determines whether the given text matches one of the Ion identifier
     * keywords &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;false&lt;/code&gt;.
     * &lt;p&gt;
     * This does &lt;em&gt;not&lt;/em&gt; check for non-identifier keywords such as
     * &lt;code&gt;null.int&lt;/code&gt;.
     *
     * @param text the symbol to check.
     * @return &lt;code&gt;true&lt;/code&gt; if the text is an identifier keyword.
     */
    public static boolean isIdentifierKeyword(CharSequence text)
    {
<span class="fc" id="L410">        int pos = 0;</span>
<span class="fc" id="L411">        int valuelen = text.length();</span>

<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if(valuelen == 0)</span>
        {
<span class="nc" id="L415">            return false;</span>
        }

<span class="fc" id="L418">        boolean keyword = false;</span>

        // there has to be at least 1 character or we wouldn't be here
<span class="fc bfc" id="L421" title="All 5 branches covered.">        switch (text.charAt(pos++)) {</span>
        case '$':
<span class="fc bfc" id="L423" title="All 2 branches covered.">            if (valuelen == 1) return false;</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            while (pos &lt; valuelen) {</span>
<span class="fc" id="L425">                char c = text.charAt(pos++);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">                if (! isDecimalDigit(c)) return false;</span>
<span class="fc" id="L427">            }</span>
<span class="fc" id="L428">            return true;</span>
        case 'f':
<span class="fc bfc" id="L430" title="All 2 branches covered.">            if (valuelen == 5 //      'f'</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">             &amp;&amp; text.charAt(pos++) == 'a'</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 'l'</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 's'</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 'e'</span>
            ) {
<span class="fc" id="L436">                keyword = true;</span>
            }
            break;
        case 'n':
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (valuelen == 4 //      'n'</span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">             &amp;&amp; text.charAt(pos++) == 'u'</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 'l'</span>
<span class="pc bpc" id="L443" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 'l'</span>
            ) {
<span class="fc" id="L445">                keyword = true;</span>
            }
<span class="fc bfc" id="L447" title="All 2 branches covered.">            else if (valuelen == 3 // 'n'</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">             &amp;&amp; text.charAt(pos++) == 'a'</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 'n'</span>
            ) {
<span class="fc" id="L451">                keyword = true;</span>
            }
            break;
        case 't':
<span class="fc bfc" id="L455" title="All 2 branches covered.">            if (valuelen == 4 //      't'</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">             &amp;&amp; text.charAt(pos++) == 'r'</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 'u'</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">             &amp;&amp; text.charAt(pos++) == 'e'</span>
            ) {
<span class="fc" id="L460">                keyword = true;</span>
            }
            break;
        }

<span class="fc" id="L465">        return keyword;</span>
    }


    /**
     * Determines whether the text of a symbol requires (single) quotes.
     *
     * @param symbol must be a non-empty string.
     * @param quoteOperators indicates whether the caller wants operators to be
     * quoted; if &lt;code&gt;true&lt;/code&gt; then operator symbols like &lt;code&gt;!=&lt;/code&gt;
     * will return &lt;code&gt;true&lt;/code&gt;.
     * has looser quoting requirements than other containers.
     * @return &lt;code&gt;true&lt;/code&gt; if the given symbol requires quoting.
     *
     * @throws NullPointerException
     *         if &lt;code&gt;symbol&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public static boolean symbolNeedsQuoting(CharSequence symbol,
                                             boolean      quoteOperators)
    {
<span class="fc" id="L485">        int length = symbol.length();</span>

        // If the symbol's text matches an Ion keyword or it's an empty symbol, we must quote it.
        // Eg, the symbol 'false' and '' must be rendered quoted.
<span class="fc bfc" id="L489" title="All 4 branches covered.">        if(length == 0 || isIdentifierKeyword(symbol))</span>
        {
<span class="fc" id="L491">            return true;</span>
        }

<span class="fc" id="L494">        char c = symbol.charAt(0);</span>

        // Surrogates are neither identifierStart nor operatorPart, so the
        // first one we hit will fall through and return true.
        // TODO test that

<span class="fc bfc" id="L500" title="All 4 branches covered.">        if (!quoteOperators &amp;&amp; isOperatorPart(c))</span>
        {
<span class="fc bfc" id="L502" title="All 2 branches covered.">            for (int ii = 0; ii &lt; length; ii++) {</span>
<span class="fc" id="L503">                c = symbol.charAt(ii);</span>
                // We don't need to look for escapes since all
                // operator characters are ASCII.
<span class="fc bfc" id="L506" title="All 2 branches covered.">                if (!isOperatorPart(c)) {</span>
<span class="fc" id="L507">                    return true;</span>
                }
            }
<span class="fc" id="L510">            return false;</span>
        }
<span class="fc bfc" id="L512" title="All 2 branches covered.">        else if (isIdentifierStart(c))</span>
        {
<span class="fc bfc" id="L514" title="All 2 branches covered.">            for (int ii = 0; ii &lt; length; ii++) {</span>
<span class="fc" id="L515">                c = symbol.charAt(ii);</span>
<span class="pc bpc" id="L516" title="3 of 6 branches missed.">                if ((c == '\'' || c &lt; 32 || c &gt; 126)</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                    || !isIdentifierPart(c))</span>
                {
<span class="fc" id="L519">                    return true;</span>
                }
            }
<span class="fc" id="L522">            return false;</span>
        }

        // quote by default
<span class="fc" id="L526">        return true;</span>
    }


    /**
     * Print an Ion Symbol type. This method will check if symbol needs quoting
     * @param text
     * @throws IOException
     */
    public final void printSymbol(CharSequence text)
        throws IOException
    {
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        if (text == null)</span>
        {
<span class="nc" id="L540">            appendAscii(&quot;null.symbol&quot;);</span>
        }
<span class="fc bfc" id="L542" title="All 2 branches covered.">        else if (symbolNeedsQuoting(text, true)) {</span>
<span class="fc" id="L543">            appendAscii('\'');</span>
<span class="fc" id="L544">            printCodePoints(text, SYMBOL_ESCAPE_CODES);</span>
<span class="fc" id="L545">            appendAscii('\'');</span>
        }
        else
        {
<span class="fc" id="L549">            appendAscii(text);</span>
        }
<span class="fc" id="L551">    }</span>

    /**
     * Print single-quoted Ion Symbol type
     * @param text
     * @throws IOException
     */
    public final void printQuotedSymbol(CharSequence text)
        throws IOException
    {
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">        if (text == null)</span>
        {
<span class="nc" id="L563">            appendAscii(&quot;null.symbol&quot;);</span>
        }
        else
        {
<span class="fc" id="L567">            appendAscii('\'');</span>
<span class="fc" id="L568">            printCodePoints(text, SYMBOL_ESCAPE_CODES);</span>
<span class="fc" id="L569">            appendAscii('\'');</span>
        }
<span class="fc" id="L571">    }</span>

    private final void printCodePoints(CharSequence text, String[] escapes)
        throws IOException
    {
<span class="fc" id="L576">        int len = text.length();</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        for (int i = 0; i &lt; len; ++i)</span>
        {
            // Find a span of non-escaped ASCII code points so we can write
            // them as quickly as possible.
<span class="fc" id="L581">            char c = 0;</span>
            int j;
<span class="fc bfc" id="L583" title="All 2 branches covered.">            for (j = i; j &lt; len; ++j) {</span>
<span class="fc" id="L584">                c = text.charAt(j);</span>
                // The escapes array always includes U+80 through U+FF.
<span class="fc bfc" id="L586" title="All 4 branches covered.">                if (c &gt;= 0x100 || escapes[c] != null)</span>
                {
                    // c is escaped and/or outside ASCII range.
<span class="fc bfc" id="L589" title="All 2 branches covered.">                    if (j &gt; i) {</span>
<span class="fc" id="L590">                        appendAscii(text, i, j);</span>
<span class="fc" id="L591">                        i = j;</span>
                    }
                    break;
                }
            }
<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (j == len) {</span>
                // we've reached the end of sequence; append it and break
<span class="fc" id="L598">                appendAscii(text, i, j);</span>
<span class="fc" id="L599">                break;</span>
            }

            // We've found a code point that's escaped and/or non-ASCII.

<span class="fc bfc" id="L604" title="All 2 branches covered.">            if (c &lt; 0x80)</span>
            {
                // An escaped ASCII character.
<span class="pc bpc" id="L607" title="2 of 4 branches missed.">                assert escapes[c] != null;</span>
<span class="fc" id="L608">                appendAscii(escapes[c]);</span>
            }
<span class="fc bfc" id="L610" title="All 2 branches covered.">            else if (c &lt; 0x100)</span>
            {
                // Non-ASCII LATIN-1; we will have an escape sequence but may
                // not use it.
<span class="pc bpc" id="L614" title="2 of 4 branches missed.">                assert escapes[c] != null;</span>

                // Always escape the C1 control codes U+80 through U+9F.
<span class="fc bfc" id="L617" title="All 4 branches covered.">                if (escapeNonAscii || c &lt;= 0x9F) {</span>
<span class="fc" id="L618">                    appendAscii(escapes[c]);</span>
                } else {
<span class="fc" id="L620">                    appendUtf16(c);</span>
                }
            }
<span class="fc bfc" id="L623" title="All 4 branches covered.">            else if (c &lt; 0xD800 || c &gt;= 0xE000)</span>
            {
                // Not LATIN-1, but still in the BMP.
<span class="fc" id="L626">                String s = Integer.toHexString(c);</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">                if (escapeNonAscii) {</span>
<span class="fc" id="L628">                    appendAscii(HEX_4_PREFIX);</span>
<span class="fc" id="L629">                    appendAscii(ZERO_PADDING[4 - s.length()]);</span>
<span class="fc" id="L630">                    appendAscii(s);</span>
                } else {
<span class="fc" id="L632">                    appendUtf16(c);</span>
                }
<span class="fc" id="L634">            }</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">            else if (isHighSurrogate(c))</span>
            {
                // Outside the BMP! High surrogate must be followed by low.
                char c2;
<span class="fc bfc" id="L639" title="All 4 branches covered.">                if (++i == len || !isLowSurrogate(c2 = text.charAt(i))) {</span>
<span class="fc" id="L640">                    String message =</span>
                        &quot;text is invalid UTF-16. It contains an unmatched &quot; +
<span class="fc" id="L642">                        &quot;leading surrogate 0x&quot; + Integer.toHexString(c) +</span>
                        &quot; at index &quot; + (i-1);
<span class="fc" id="L644">                    throw new IllegalArgumentException(message);</span>
                }
<span class="fc bfc" id="L646" title="All 2 branches covered.">                if (escapeNonAscii) {</span>
<span class="fc" id="L647">                    int cp = makeUnicodeScalar(c, c2);</span>
<span class="fc" id="L648">                    String s = Integer.toHexString(cp);</span>
<span class="fc" id="L649">                    appendAscii(HEX_8_PREFIX);</span>
<span class="fc" id="L650">                    appendAscii(ZERO_PADDING[8 - s.length()]);</span>
<span class="fc" id="L651">                    appendAscii(s);</span>
<span class="fc" id="L652">                } else {</span>
<span class="fc" id="L653">                    appendUtf16Surrogate(c, c2);</span>
                }
<span class="fc" id="L655">            }</span>
            else
            {
                // unmatched low surrogate
<span class="pc bpc" id="L659" title="2 of 4 branches missed.">                assert isLowSurrogate(c);</span>

<span class="fc" id="L661">                String message =</span>
                    &quot;text is invalid UTF-16. It contains an unmatched &quot; +
<span class="fc" id="L663">                    &quot;trailing surrogate 0x&quot; + Integer.toHexString(c) +</span>
                    &quot; at index &quot; + i;
<span class="fc" id="L665">                throw new IllegalArgumentException(message);</span>
            }
        }
<span class="fc" id="L668">    }</span>


    //=========================================================================
    // Numeric scalars


    /** ONLY FOR USE BY {@link #printInt(long)}. */
<span class="fc" id="L676">    private final char[] _fixedIntBuffer = new char[MAX_LONG_TEXT_SIZE];</span>

    public void printInt(long value)
        throws IOException
    {
<span class="fc" id="L681">        int j = _fixedIntBuffer.length;</span>
<span class="fc bfc" id="L682" title="All 2 branches covered.">        if (value == 0) {</span>
<span class="fc" id="L683">            _fixedIntBuffer[--j] = '0';</span>
        } else {
<span class="fc bfc" id="L685" title="All 2 branches covered.">            if (value &lt; 0) {</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                while (value != 0) {</span>
<span class="fc" id="L687">                    _fixedIntBuffer[--j] = (char)(0x30 - value % 10);</span>
<span class="fc" id="L688">                    value /= 10;</span>
                }
<span class="fc" id="L690">                _fixedIntBuffer[--j] = '-';</span>
            } else {
<span class="fc bfc" id="L692" title="All 2 branches covered.">                while (value != 0) {</span>
<span class="fc" id="L693">                    _fixedIntBuffer[--j] = (char)(0x30 + value % 10);</span>
<span class="fc" id="L694">                    value /= 10;</span>
                }
            }
        }

        // Using CharBuffer avoids copying the _fixedIntBuffer into a String
<span class="fc" id="L700">        appendAscii(CharBuffer.wrap(_fixedIntBuffer),</span>
                    j,
                    _fixedIntBuffer.length);
<span class="fc" id="L703">    }</span>


    public void printInt(BigInteger value)
        throws IOException
    {
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        if (value == null)</span>
        {
<span class="nc" id="L711">            appendAscii(&quot;null.int&quot;);</span>
<span class="nc" id="L712">            return;</span>
        }

<span class="fc" id="L715">        appendAscii(value.toString());</span>
<span class="fc" id="L716">    }</span>


    public void printDecimal(PrivateIonTextWriterBuilder _options,
                             BigDecimal                    value)
        throws IOException
    {
<span class="fc bfc" id="L723" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L725">            appendAscii(&quot;null.decimal&quot;);</span>
<span class="fc" id="L726">            return;</span>
        }

<span class="fc" id="L729">        BigInteger unscaled = value.unscaledValue();</span>

<span class="fc" id="L731">        int signum = value.signum();</span>
<span class="fc bfc" id="L732" title="All 2 branches covered.">        if (signum &lt; 0)</span>
        {
<span class="fc" id="L734">            appendAscii('-');</span>
<span class="fc" id="L735">            unscaled = unscaled.negate();</span>
        }
<span class="fc bfc" id="L737" title="All 2 branches covered.">        else if (value instanceof Decimal</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">             &amp;&amp; ((Decimal)value).isNegativeZero())</span>
        {
            // for the various forms of negative zero we have to
            // write the sign ourselves, since neither BigInteger
            // nor BigDecimal recognize negative zero, but Ion does.
<span class="fc" id="L743">            appendAscii('-');</span>
        }

<span class="fc" id="L746">        final String unscaledText = unscaled.toString();</span>
<span class="fc" id="L747">        final int significantDigits = unscaledText.length();</span>

<span class="fc" id="L749">        final int scale = value.scale();</span>
<span class="fc" id="L750">        final int exponent = -scale;</span>

<span class="pc bpc" id="L752" title="1 of 2 branches missed.">        if (_options._decimal_as_float)</span>
        {
<span class="nc" id="L754">            appendAscii(unscaledText);</span>
<span class="nc" id="L755">            appendAscii('e');</span>
<span class="nc" id="L756">            appendAscii(Integer.toString(exponent));</span>
        }
<span class="fc bfc" id="L758" title="All 2 branches covered.">        else if (exponent == 0)</span>
        {
<span class="fc" id="L760">            appendAscii(unscaledText);</span>
<span class="fc" id="L761">            appendAscii('.');</span>
        }
<span class="fc bfc" id="L763" title="All 2 branches covered.">        else if (exponent &lt; 0)</span>
        {
            // Avoid printing small negative exponents using a heuristic
            // adapted from http://speleotrove.com/decimal/daconvs.html

<span class="fc" id="L768">            final int adjustedExponent = significantDigits - 1 - scale;</span>
<span class="fc bfc" id="L769" title="All 2 branches covered.">            if (adjustedExponent &gt;= 0)</span>
            {
<span class="fc" id="L771">                int wholeDigits = significantDigits - scale;</span>
<span class="fc" id="L772">                appendAscii(unscaledText, 0, wholeDigits);</span>
<span class="fc" id="L773">                appendAscii('.');</span>
<span class="fc" id="L774">                appendAscii(unscaledText, wholeDigits,</span>
                                    significantDigits);
<span class="fc" id="L776">            }</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">            else if (adjustedExponent &gt;= -6)</span>
            {
<span class="fc" id="L779">                appendAscii(&quot;0.&quot;);</span>
<span class="fc" id="L780">                appendAscii(&quot;00000&quot;, 0, scale - significantDigits);</span>
<span class="fc" id="L781">                appendAscii(unscaledText);</span>
            }
            else
            {
<span class="fc" id="L785">                appendAscii(unscaledText);</span>
<span class="fc" id="L786">                appendAscii(&quot;d-&quot;);</span>
<span class="fc" id="L787">                appendAscii(Integer.toString(scale));</span>
            }
<span class="fc" id="L789">        }</span>
        else // (exponent &gt; 0)
        {
            // We cannot move the decimal point to the right, adding
            // rightmost zeros, because that would alter the precision.
<span class="fc" id="L794">            appendAscii(unscaledText);</span>
<span class="fc" id="L795">            appendAscii('d');</span>
<span class="fc" id="L796">            appendAscii(Integer.toString(exponent));</span>
        }
<span class="fc" id="L798">    }</span>


    public void printFloat(double value)
        throws IOException
    {
        // shortcut zero cases
<span class="fc bfc" id="L805" title="All 2 branches covered.">        if (value == 0.0)</span>
        {
<span class="fc bfc" id="L807" title="All 2 branches covered.">            if (Double.compare(value, 0d) == 0)  // Only matches positive zero</span>
            {
<span class="fc" id="L809">                appendAscii(&quot;0e0&quot;);</span>
            }
            else
            {
<span class="fc" id="L813">                appendAscii(&quot;-0e0&quot;);</span>
            }
        }
<span class="fc bfc" id="L816" title="All 2 branches covered.">        else if (Double.isNaN(value))</span>
        {
<span class="fc" id="L818">            appendAscii(&quot;nan&quot;);</span>
        }
<span class="fc bfc" id="L820" title="All 2 branches covered.">        else if (value == Double.POSITIVE_INFINITY)</span>
        {
<span class="fc" id="L822">            appendAscii(&quot;+inf&quot;);</span>
        }
<span class="fc bfc" id="L824" title="All 2 branches covered.">        else if (value == Double.NEGATIVE_INFINITY)</span>
        {
<span class="fc" id="L826">            appendAscii(&quot;-inf&quot;);</span>
        }
        else
        {
            // Double.toString() forces a digit after the decimal point.
            // Remove it when it's not meaningful.
<span class="fc" id="L832">            String str = Double.toString(value);</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">            if (str.endsWith(&quot;.0&quot;))</span>
            {
<span class="fc" id="L835">                appendAscii(str, 0, str.length() - 2);</span>
<span class="fc" id="L836">                appendAscii(&quot;e0&quot;);</span>
            }
            else
            {
<span class="fc" id="L840">                appendAscii(str);</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">                if (str.indexOf('E') == -1)</span>
                {
<span class="fc" id="L843">                    appendAscii(&quot;e0&quot;);</span>
                }
            }
        }
<span class="fc" id="L847">    }</span>

    public void printFloat(Double value)
        throws IOException
    {
<span class="fc bfc" id="L852" title="All 2 branches covered.">        if (value == null)</span>
        {
<span class="fc" id="L854">            appendAscii(&quot;null.float&quot;);</span>
        }
        else
        {
<span class="fc" id="L858">            printFloat(value.doubleValue());</span>
        }
<span class="fc" id="L860">    }</span>


    //=========================================================================
    // LOBs


    public void printBlob(PrivateIonTextWriterBuilder _options,
                          byte[] value, int start, int len)
        throws IOException
    {
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">        if (value == null)</span>
        {
<span class="nc" id="L873">            appendAscii(&quot;null.blob&quot;);</span>
<span class="nc" id="L874">            return;</span>
        }

        @SuppressWarnings(&quot;resource&quot;)
<span class="fc" id="L878">        TextStream ts =</span>
            new TextStream(new ByteArrayInputStream(value, start, len));

        // base64 encoding is 6 bits per char so
        // it evens out at 3 bytes in 4 characters
<span class="fc bfc" id="L883" title="All 2 branches covered.">        char[] buf = new char[_options.isPrettyPrintOn() ? 80 : 400];</span>
<span class="fc" id="L884">        CharBuffer cb = CharBuffer.wrap(buf);</span>

<span class="pc bpc" id="L886" title="1 of 2 branches missed.">        if (_options._blob_as_string)</span>
        {
<span class="nc" id="L888">            appendAscii('&quot;');</span>
        }
        else
        {
<span class="fc" id="L892">            appendAscii(&quot;{{&quot;);</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">            if (_options.isPrettyPrintOn())</span>
            {
<span class="fc" id="L895">                appendAscii(' ');</span>
            }
        }

        for (;;)
        {
            // TODO is it better to fill up the CharBuffer before outputting?
<span class="fc" id="L902">            int clen = ts.read(buf, 0, buf.length);</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">            if (clen &lt; 1) break;</span>
<span class="fc" id="L904">            appendAscii(cb, 0, clen);</span>
<span class="fc" id="L905">        }</span>

<span class="pc bpc" id="L907" title="1 of 2 branches missed.">        if (_options._blob_as_string)</span>
        {
<span class="nc" id="L909">            appendAscii('&quot;');</span>
        }
        else
        {
<span class="fc bfc" id="L913" title="All 2 branches covered.">            if (_options.isPrettyPrintOn())</span>
            {
<span class="fc" id="L915">                appendAscii(' ');</span>
            }
<span class="fc" id="L917">            appendAscii(&quot;}}&quot;);</span>
        }
<span class="fc" id="L919">    }</span>


    private void printClobBytes(byte[] value, int start, int end,
                                String[] escapes)
        throws IOException
    {
<span class="fc bfc" id="L926" title="All 2 branches covered.">        for (int i = start; i &lt; end; i++) {</span>
<span class="fc" id="L927">            char c = (char)(value[i] &amp; 0xff);</span>
<span class="fc" id="L928">            String escapedByte = escapes[c];</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">            if (escapedByte != null) {</span>
<span class="fc" id="L930">                appendAscii(escapedByte);</span>
            } else {
<span class="fc" id="L932">                appendAscii(c);</span>
            }
        }
<span class="fc" id="L935">    }</span>


    public void printClob(PrivateIonTextWriterBuilder _options,
                          byte[] value, int start, int len)
        throws IOException
    {
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        if (value == null)</span>
        {
<span class="nc" id="L944">            appendAscii(&quot;null.clob&quot;);</span>
<span class="nc" id="L945">            return;</span>
        }


<span class="pc bpc" id="L949" title="1 of 4 branches missed.">        final boolean json =</span>
            _options._clob_as_string &amp;&amp; _options._string_as_json;

<span class="fc" id="L952">        final int threshold = _options.getLongStringThreshold();</span>
<span class="fc bfc" id="L953" title="All 4 branches covered.">        final boolean longString = (0 &lt; threshold &amp;&amp; threshold &lt; value.length);</span>

<span class="fc bfc" id="L955" title="All 2 branches covered.">        if (!_options._clob_as_string)</span>
        {
<span class="fc" id="L957">            appendAscii(&quot;{{&quot;);</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">            if (_options.isPrettyPrintOn())</span>
            {
<span class="fc" id="L960">                appendAscii(' ');</span>
            }
        }

<span class="fc bfc" id="L964" title="All 2 branches covered.">        if (json)</span>
        {
<span class="fc" id="L966">            appendAscii('&quot;');</span>
<span class="fc" id="L967">            printClobBytes(value, start, start + len, JSON_ESCAPE_CODES);</span>
<span class="fc" id="L968">            appendAscii('&quot;');</span>
        }
<span class="fc bfc" id="L970" title="All 2 branches covered.">        else if (longString)</span>
        {
            // This may escape more often than is necessary, but doing it
            // minimally is very tricky. Must be sure to account for
            // quotes at the end of the content.

            // TODO Account for NL versus CR+NL streams
<span class="fc" id="L977">            appendAscii(TRIPLE_QUOTES);</span>
<span class="fc" id="L978">            printClobBytes(value, start, start + len, LONG_STRING_ESCAPE_CODES);</span>
<span class="fc" id="L979">            appendAscii(TRIPLE_QUOTES);</span>
        }
        else
        {
<span class="fc" id="L983">            appendAscii('&quot;');</span>
<span class="fc" id="L984">            printClobBytes(value, start, start + len, STRING_ESCAPE_CODES);</span>
<span class="fc" id="L985">            appendAscii('&quot;');</span>
        }

<span class="fc bfc" id="L988" title="All 2 branches covered.">        if (! _options._clob_as_string)</span>
        {
<span class="fc bfc" id="L990" title="All 2 branches covered.">            if (_options.isPrettyPrintOn())</span>
            {
<span class="fc" id="L992">                appendAscii(' ');</span>
            }
<span class="fc" id="L994">            appendAscii(&quot;}}&quot;);</span>
        }
<span class="fc" id="L996">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>