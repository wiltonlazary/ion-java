<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>_Private_Utils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">_Private_Utils.java</span></div><h1>_Private_Utils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import static com.amazon.ion.SymbolTable.UNKNOWN_SYMBOL_ID;
import static com.amazon.ion.SystemSymbols.IMPORTS;
import static com.amazon.ion.SystemSymbols.IMPORTS_SID;
import static com.amazon.ion.SystemSymbols.ION_SYMBOL_TABLE;
import static com.amazon.ion.SystemSymbols.MAX_ID;
import static com.amazon.ion.SystemSymbols.MAX_ID_SID;
import static com.amazon.ion.SystemSymbols.NAME;
import static com.amazon.ion.SystemSymbols.NAME_SID;
import static com.amazon.ion.SystemSymbols.SYMBOLS;
import static com.amazon.ion.SystemSymbols.SYMBOLS_SID;
import static com.amazon.ion.SystemSymbols.VERSION;
import static com.amazon.ion.SystemSymbols.VERSION_SID;
import static com.amazon.ion.util.IonStreamUtils.isIonBinary;

import com.amazon.ion.IonException;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonSystem;
import com.amazon.ion.IonType;
import com.amazon.ion.IonValue;
import com.amazon.ion.SubstituteSymbolTableException;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.UnknownSymbolException;
import com.amazon.ion.ValueFactory;
import com.amazon.ion.impl.IonBinary.BufferManager;
import com.amazon.ion.impl.IonBinary.Reader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharacterCodingException;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CharsetEncoder;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;
import java.util.TimeZone;

/**
 * NOT FOR APPLICATION USE!
 */
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">public final class _Private_Utils</span>
{
    /**
     * Marker for code points relevant to removal of IonReader.hasNext().
     */
    public static final boolean READER_HASNEXT_REMOVED = false;


    /** Just a zero-length byte array, used to avoid allocation. */
<span class="fc" id="L75">    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];</span>

    /** Just a zero-length String array, used to avoid allocation. */
<span class="fc" id="L78">    public final static String[] EMPTY_STRING_ARRAY = new String[0];</span>

    /** Just a zero-length int array, used to avoid allocation. */
<span class="fc" id="L81">    public final static int[] EMPTY_INT_ARRAY = new int[0];</span>

    /**
     * (null.timestamp) requires 11 ASCII chars to distinguish from
     * (null.timestamps) aka (null '.' 'timestamps')
     *
     * @see IonCharacterReader#DEFAULT_BUFFER_SIZE
     * @see IonCharacterReader#BUFFER_PADDING
     */
    public static final int MAX_LOOKAHEAD_UTF16 = 11;



    public static final String ASCII_CHARSET_NAME = &quot;US-ASCII&quot;;

<span class="fc" id="L96">    public static final Charset ASCII_CHARSET =</span>
<span class="fc" id="L97">        Charset.forName(ASCII_CHARSET_NAME);</span>

    /** The string {@code &quot;UTF-8&quot;}. */
    public static final String UTF8_CHARSET_NAME = &quot;UTF-8&quot;;

<span class="fc" id="L102">    public static final Charset UTF8_CHARSET =</span>
<span class="fc" id="L103">        Charset.forName(UTF8_CHARSET_NAME);</span>


    /**
     * The UTC {@link TimeZone}.
     *
     * TODO determine if this is well-defined.
     */
<span class="fc" id="L111">    public static final TimeZone UTC = TimeZone.getTimeZone(&quot;UTC&quot;);</span>



<span class="fc" id="L115">    public static final ListIterator&lt;?&gt; EMPTY_ITERATOR = new ListIterator() {</span>
<span class="fc" id="L116">        public boolean hasNext()     { return false; }</span>
<span class="fc" id="L117">        public boolean hasPrevious() { return false; }</span>

<span class="fc" id="L119">        public Object  next()     { throw new NoSuchElementException(); }</span>
<span class="nc" id="L120">        public Object  previous() { throw new NoSuchElementException(); }</span>
<span class="nc" id="L121">        public void    remove()   { throw new IllegalStateException(); }</span>

<span class="fc" id="L123">        public int nextIndex()     { return  0; }</span>
<span class="fc" id="L124">        public int previousIndex() { return -1; }</span>

<span class="nc" id="L126">        public void add(Object o) { throw new UnsupportedOperationException(); }</span>
<span class="nc" id="L127">        public void set(Object o) { throw new UnsupportedOperationException(); }</span>
    };

    @SuppressWarnings(&quot;unchecked&quot;)
    public static final &lt;T&gt; ListIterator&lt;T&gt; emptyIterator()
    {
<span class="fc" id="L133">        return (ListIterator&lt;T&gt;) EMPTY_ITERATOR;</span>
    }

    public static boolean safeEquals(Object a, Object b)
    {
        // Written for the common case where they are not the same instance
<span class="pc bpc" id="L139" title="1 of 4 branches missed.">        return (a != null ? a.equals(b) : b == null);</span>
    }

    /**
     * Replacement for Java6 {@link Arrays#copyOf(byte[], int)}.
     */
    public static byte[] copyOf(byte[] original, int newLength)
    {
<span class="fc" id="L147">        byte[] result = new byte[newLength];</span>
<span class="fc" id="L148">        System.arraycopy(original, 0, result, 0,</span>
<span class="fc" id="L149">                         Math.min(newLength, original.length));</span>
<span class="fc" id="L150">        return result;</span>
    }

    public static String[] copyOf(String[] original, int newLength)
    {
<span class="fc" id="L155">        String[] result = new String[newLength];</span>
<span class="fc" id="L156">        System.arraycopy(original, 0, result, 0,</span>
<span class="fc" id="L157">                         Math.min(newLength, original.length));</span>
<span class="fc" id="L158">        return result;</span>
    }

    public static &lt;T&gt; void addAll(Collection&lt;T&gt; dest, Iterator&lt;T&gt; src)
    {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (src != null)</span>
        {
<span class="nc bnc" id="L165" title="All 2 branches missed.">            while (src.hasNext())</span>
            {
<span class="nc" id="L167">                T value = src.next();</span>
<span class="nc" id="L168">                dest.add(value);</span>
<span class="nc" id="L169">            }</span>
        }
<span class="nc" id="L171">    }</span>

    public static &lt;T&gt; void addAllNonNull(Collection&lt;T&gt; dest, Iterator&lt;T&gt; src)
    {
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (src != null)</span>
        {
<span class="fc bfc" id="L177" title="All 2 branches covered.">            while (src.hasNext())</span>
            {
<span class="fc" id="L179">                T value = src.next();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                if (value != null)</span>
                {
<span class="fc" id="L182">                    dest.add(value);</span>
                }
<span class="fc" id="L184">            }</span>
        }
<span class="fc" id="L186">    }</span>

    /**
     * @return not null
     */
    public static SymbolTokenImpl newSymbolToken(String text, int sid)
    {
<span class="fc" id="L193">        return new SymbolTokenImpl(text, sid);</span>
    }

    /**
     * @return not null
     */
    public static SymbolTokenImpl newSymbolToken(int sid)
    {
<span class="fc" id="L201">        return new SymbolTokenImpl(sid);</span>
    }

    /**
     * Checks symbol content.
     * @return not null
     */
    public static SymbolToken newSymbolToken(SymbolTable symtab,
                                             String text)
    {
        // TODO amzn/ion-java/issues/21 symtab should not be null
<span class="fc" id="L212">        text.getClass(); // quick null check</span>

<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        SymbolToken tok = (symtab == null ? null : symtab.find(text));</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (tok == null)</span>
        {
<span class="fc" id="L217">            tok = new SymbolTokenImpl(text, UNKNOWN_SYMBOL_ID);</span>
        }
<span class="fc" id="L219">        return tok;</span>
    }

    /**
     * @return not null
     */
    public static SymbolToken newSymbolToken(SymbolTable symtab,
                                             int sid)
    {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (sid &lt; 1) throw new IllegalArgumentException();</span>

        // TODO amzn/ion-java/issues/21 symtab should not be null
<span class="nc bnc" id="L231" title="All 2 branches missed.">        String text = (symtab == null ? null : symtab.findKnownSymbol(sid));</span>
<span class="nc" id="L232">        return new SymbolTokenImpl(text, sid);</span>
    }

    /**
     * Validates each text element.
     * @param text may be null or empty.
     * @return not null.
     */
    public static SymbolToken[] newSymbolTokens(SymbolTable symtab,
                                                String... text)
    {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (text != null)</span>
        {
<span class="fc" id="L245">            int count = text.length;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">            if (count != 0)</span>
            {
<span class="fc" id="L248">                SymbolToken[] result = new SymbolToken[count];</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                for (int i = 0; i &lt; count; i++)</span>
                {
<span class="fc" id="L251">                    String s = text[i];</span>
<span class="fc" id="L252">                    result[i] = newSymbolToken(symtab, s);</span>
                }
<span class="fc" id="L254">                return result;</span>
            }
        }
<span class="fc" id="L257">        return SymbolToken.EMPTY_ARRAY;</span>
    }

    /**
     * @param syms may be null or empty.
     * @return not null.
     */
    public static SymbolToken[] newSymbolTokens(SymbolTable symtab,
                                                int... syms)
    {
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (syms != null)</span>
        {
<span class="nc" id="L269">            int count = syms.length;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (syms.length != 0)</span>
            {
<span class="nc" id="L272">                SymbolToken[] result = new SymbolToken[count];</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                for (int i = 0; i &lt; count; i++)</span>
                {
<span class="nc" id="L275">                    int s = syms[i];</span>
<span class="nc" id="L276">                    result[i] = newSymbolToken(symtab, s);</span>
                }
<span class="nc" id="L278">                return result;</span>
            }
        }
<span class="nc" id="L281">        return SymbolToken.EMPTY_ARRAY;</span>
    }


    public static SymbolToken localize(SymbolTable symtab,
                                       SymbolToken sym)
    {
<span class="fc" id="L288">        String text = sym.getText();</span>
<span class="fc" id="L289">        int sid = sym.getSid();</span>

<span class="pc bpc" id="L291" title="1 of 2 branches missed.">        if (symtab != null)  // TODO amzn/ion-java/issues/21 require symtab</span>
        {
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (text == null)</span>
            {
<span class="fc" id="L295">                text = symtab.findKnownSymbol(sid);</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                if (text != null)</span>
                {
<span class="fc" id="L298">                    sym = new SymbolTokenImpl(text, sid);</span>
                }
            }
            else
            {
<span class="fc" id="L303">                SymbolToken newSym = symtab.find(text);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                if (newSym != null)</span>
                {
<span class="fc" id="L306">                    sym = newSym;</span>
                }
<span class="fc bfc" id="L308" title="All 2 branches covered.">                else if (sid &gt;= 0)</span>
                {
                    // We can't trust the sid, discard it.
<span class="fc" id="L311">                    sym = new SymbolTokenImpl(text, UNKNOWN_SYMBOL_ID);</span>
                }
<span class="fc" id="L313">            }</span>
        }
<span class="nc bnc" id="L315" title="All 4 branches missed.">        else if (text != null &amp;&amp; sid &gt;= 0)</span>
        {
            // We can't trust the sid, discard it.
<span class="nc" id="L318">            sym = new SymbolTokenImpl(text, UNKNOWN_SYMBOL_ID);</span>
        }
<span class="fc" id="L320">        return sym;</span>
    }


    /**
    *
    * @param syms may be mutated, replacing entries with localized updates!
    */
    public static void localize(SymbolTable symtab,
                                SymbolToken[] syms,
                                int count)
    {
<span class="nc bnc" id="L332" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="nc" id="L334">            SymbolToken sym = syms[i];</span>
<span class="nc" id="L335">            SymbolToken updated = localize(symtab, sym);</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (updated != sym) syms[i] = updated;</span>
        }
<span class="nc" id="L338">    }</span>

    /**
     *
     * @param syms may be mutated, replacing entries with localized updates!
     */
    public static void localize(SymbolTable symtab,
                                SymbolToken[] syms)
    {
<span class="nc" id="L347">        localize(symtab, syms, syms.length);</span>
<span class="nc" id="L348">    }</span>


    /**
     * Extracts the non-null text from a list of symbol tokens.
     *
     * @return not null.
     *
     * @throws UnknownSymbolException if any token is missing text.
     */
    public static String[] toStrings(SymbolToken[] symbols, int count)
    {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (count == 0) return _Private_Utils.EMPTY_STRING_ARRAY;</span>

<span class="fc" id="L362">        String[] annotations = new String[count];</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="fc" id="L365">            SymbolToken tok = symbols[i];</span>
<span class="fc" id="L366">            String text = tok.getText();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">            if (text == null)</span>
            {
<span class="fc" id="L369">                throw new UnknownSymbolException(tok.getSid());</span>
            }
<span class="fc" id="L371">            annotations[i] = text;</span>
        }
<span class="fc" id="L373">        return annotations;</span>
    }

    public static int[] toSids(SymbolToken[] symbols, int count)
    {
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (count == 0) return _Private_Utils.EMPTY_INT_ARRAY;</span>

<span class="nc" id="L380">        int[] sids = new int[count];</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        for (int i = 0; i &lt; count; i++)</span>
        {
<span class="nc" id="L383">            sids[i] = symbols[i].getSid();</span>
        }
<span class="nc" id="L385">        return sids;</span>
    }

    //========================================================================

    /**
     * Encodes a String into bytes of a given encoding.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#encode(String)} and
     * {@link String#getBytes(String)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param s the string to encode.
     *
     * @return the encoded string, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static byte[] encode(String s, Charset charset)
    {
<span class="fc" id="L406">        CharsetEncoder encoder = charset.newEncoder();</span>
        try
        {
<span class="fc" id="L409">            ByteBuffer buffer = encoder.encode(CharBuffer.wrap(s));</span>
<span class="fc" id="L410">            byte[] bytes = buffer.array();</span>

            // Make another copy iff there's garbage after the limit.
<span class="fc" id="L413">            int limit = buffer.limit();</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">            if (limit &lt; bytes.length)</span>
            {
<span class="fc" id="L416">                bytes = copyOf(bytes, limit);</span>
            }

<span class="fc" id="L419">            return bytes;</span>
        }
<span class="nc" id="L421">        catch (CharacterCodingException e)</span>
        {
<span class="nc" id="L423">            throw new IonException(&quot;Invalid string data&quot;, e);</span>
        }
    }


    /**
     * Decodes a byte sequence into a string, given a {@link Charset}.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#decode(ByteBuffer)} and
     * {@link String#String(byte[], Charset)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param bytes the data to decode.
     *
     * @return the decoded string, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static String decode(byte[] bytes, Charset charset)
    {
<span class="fc" id="L444">        CharsetDecoder decoder = charset.newDecoder();</span>
        try
        {
<span class="fc" id="L447">            CharBuffer buffer = decoder.decode(ByteBuffer.wrap(bytes));</span>
<span class="fc" id="L448">            return buffer.toString();</span>
        }
<span class="fc" id="L450">        catch (CharacterCodingException e)</span>
        {
<span class="fc" id="L452">            String message =</span>
<span class="fc" id="L453">                &quot;Input is not valid &quot; + charset.displayName() + &quot; data&quot;;</span>
<span class="fc" id="L454">            throw new IonException(message, e);</span>
        }
    }


    /**
     * Encodes a String into UTF-8 bytes.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#encode(String)} and
     * {@link String#getBytes(String)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param s the string to encode.
     *
     * @return the encoded UTF-8 bytes, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static byte[] utf8(String s)
    {
<span class="fc" id="L475">        return encode(s, UTF8_CHARSET);</span>
    }

    /**
     * Decodes a UTF-8 byte sequence to a String.
     * &lt;p&gt;
     * This method is preferred to {@link Charset#decode(ByteBuffer)} and
     * {@link String#String(byte[], Charset)} (&lt;em&gt;etc.&lt;/em&gt;)
     * since those methods will replace or ignore bad input, and here we throw
     * an exception.
     *
     * @param bytes the data to decode.
     *
     * @return the decoded string, not null.
     *
     * @throws IonException if there's a {@link CharacterCodingException}.
     */
    public static String utf8(byte[] bytes)
    {
<span class="fc" id="L494">        return decode(bytes, UTF8_CHARSET);</span>
    }


    /**
     * This differs from {@link #utf8(String)} by using our custem encoder.
     * Not sure which is better.
     * TODO benchmark the two approaches
     */
    public static byte[] convertUtf16UnitsToUtf8(String text)
    {
<span class="fc" id="L505">        byte[] data = new byte[4*text.length()];</span>
<span class="fc" id="L506">        int limit = 0;</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        for (int i = 0; i &lt; text.length(); i++)</span>
        {
<span class="fc" id="L509">            char c = text.charAt(i);</span>
<span class="fc" id="L510">            limit += IonUTF8.convertToUTF8Bytes(c, data, limit,</span>
                                                data.length - limit);
        }

<span class="fc" id="L514">        byte[] result = new byte[limit];</span>
<span class="fc" id="L515">        System.arraycopy(data, 0, result, 0, limit);</span>
<span class="fc" id="L516">        return result;</span>
    }


    //========================================================================

    /**
     * Calls {@link InputStream#read(byte[], int, int)} until the buffer is
     * filled or EOF is encountered.
     * This method will block until the request is satisfied.
     *
     * @param in        The stream to read from.
     * @param buf       The buffer to read to.
     *
     * @return the number of bytes read from the stream.  May be less than
     *  {@code buf.length} if EOF is encountered before reading that far.
     *
     * @see #readFully(InputStream, byte[], int, int)
     */
    public static int readFully(InputStream in, byte[] buf)
    throws IOException
    {
<span class="nc" id="L538">        return readFully(in, buf, 0, buf.length);</span>
    }


    /**
     * Calls {@link InputStream#read(byte[], int, int)} until the requested
     * length is read or EOF is encountered.
     * This method will block until the request is satisfied.
     *
     * @param in        The stream to read from.
     * @param buf       The buffer to read to.
     * @param offset    The offset of the buffer to read from.
     * @param length    The length of the data to read.
     *
     * @return the number of bytes read from the stream.  May be less than
     *  {@code length} if EOF is encountered before reading that far.
     *
     * @see #readFully(InputStream, byte[])
     */
    public static int readFully(InputStream in, byte[] buf,
                                int offset, int length)
    throws IOException
    {
<span class="fc" id="L561">        int readBytes = 0;</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">        while (readBytes &lt; length)</span>
        {
<span class="fc" id="L564">            int amount = in.read(buf, offset, length - readBytes);</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">            if (amount &lt; 0)</span>
            {
                // EOF
<span class="nc" id="L568">                return readBytes;</span>
            }
<span class="fc" id="L570">            readBytes += amount;</span>
<span class="fc" id="L571">            offset += amount;</span>
<span class="fc" id="L572">        }</span>
<span class="fc" id="L573">        return readBytes;</span>
    }


    public static byte[] loadFileBytes(File file)
        throws IOException
    {
<span class="fc" id="L580">        long len = file.length();</span>
<span class="pc bpc" id="L581" title="2 of 4 branches missed.">        if (len &lt; 0 || len &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L582">            throw new IllegalArgumentException(&quot;File too long: &quot; + file);</span>
        }

<span class="fc" id="L585">        byte[] buf = new byte[(int) len];</span>

<span class="fc" id="L587">        FileInputStream in = new FileInputStream(file);</span>
        try {
<span class="fc" id="L589">            int readBytesCount = in.read(buf);</span>
<span class="pc bpc" id="L590" title="2 of 4 branches missed.">            if (readBytesCount != len || in.read() != -1)</span>
            {
<span class="nc" id="L592">                throw new IOException(&quot;Read the wrong number of bytes from &quot;</span>
                                       + file);
            }
        }
        finally {
<span class="fc" id="L597">            in.close();</span>
        }

<span class="fc" id="L600">        return buf;</span>
    }

    public static String utf8FileToString(File file)
        throws IonException, IOException
    {
<span class="fc" id="L606">        byte[] utf8Bytes = _Private_Utils.loadFileBytes(file);</span>
<span class="fc" id="L607">        String s = utf8(utf8Bytes);</span>
<span class="fc" id="L608">        return s;</span>
    }

    public static byte[] loadStreamBytes(InputStream in)
        throws IOException
    {
<span class="nc" id="L614">        BufferManager buffer = new BufferManager(in);</span>
<span class="nc" id="L615">        Reader bufReader = buffer.reader();</span>
<span class="nc" id="L616">        bufReader.sync();</span>
<span class="nc" id="L617">        bufReader.setPosition(0);</span>
<span class="nc" id="L618">        byte[] bytes = bufReader.getBytes();</span>
<span class="nc" id="L619">        return bytes;</span>
    }


    public static String loadReader(java.io.Reader in)
        throws IOException
    {
<span class="nc" id="L626">        StringBuilder buf = new StringBuilder(2048);</span>

<span class="nc" id="L628">        char[] chars = new char[2048];</span>

        int len;
<span class="nc bnc" id="L631" title="All 2 branches missed.">        while ((len = in.read(chars)) != -1)</span>
        {
<span class="nc" id="L633">            buf.append(chars, 0, len);</span>
        }

<span class="nc" id="L636">        return buf.toString();</span>
    }


    public static boolean streamIsIonBinary(PushbackInputStream pushback)
        throws IonException, IOException
    {
<span class="nc" id="L643">        boolean isBinary = false;</span>
<span class="nc" id="L644">        byte[] cookie = new byte[_Private_IonConstants.BINARY_VERSION_MARKER_SIZE];</span>

<span class="nc" id="L646">        int len = readFully(pushback, cookie);</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">        if (len == _Private_IonConstants.BINARY_VERSION_MARKER_SIZE) {</span>
<span class="nc" id="L648">            isBinary = isIonBinary(cookie);</span>
        }
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if (len &gt; 0) {</span>
<span class="nc" id="L651">            pushback.unread(cookie, 0, len);</span>
        }
<span class="nc" id="L653">        return isBinary;</span>
    }


    /**
     * Create a value iterator from a reader.
     * Primarily a trampoline for access permission.
     */
    public static Iterator&lt;IonValue&gt; iterate(ValueFactory valueFactory,
                                             IonReader input)
     {
<span class="fc" id="L664">        return new IonIteratorImpl(valueFactory, input);</span>
     }

    //========================================================================
    // Symbol Table helpers

    /**
     * Checks the passed in value and returns whether or not
     * the value could be a local symbol table.  It does this
     * by checking the type and annotations.
     *
     * @return boolean true if v can be a local symbol table otherwise false
     */
    public static boolean valueIsLocalSymbolTable(_Private_IonValue v)
    {
<span class="fc bfc" id="L679" title="All 2 branches covered.">        return (v instanceof IonStruct</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                &amp;&amp; v.findTypeAnnotation(ION_SYMBOL_TABLE) == 0);</span>
    }


    /** Indicates whether a table is shared but not a system table. */
    public static final boolean symtabIsSharedNotSystem(SymbolTable symtab)
    {
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        return (symtab != null</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">                &amp;&amp; symtab.isSharedTable()</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">                &amp;&amp; ! symtab.isSystemTable());</span>
    }


    public static boolean symtabIsLocalAndNonTrivial(SymbolTable symtab)
    {
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (symtab == null) return false;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (!symtab.isLocalTable()) return false;</span>

        // If symtab has imports we must retain it.
        // Note that I chose to retain imports even in the degenerate case
        // where the imports have no symbols.
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (symtab.getImportedTables().length &gt; 0) {</span>
<span class="nc" id="L702">            return true;</span>
        }

<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (symtab.getImportedMaxId() &lt; symtab.getMaxId()) {</span>
<span class="nc" id="L706">            return true;</span>
        }

<span class="nc" id="L709">        return false;</span>
    }


    /**
     * Is the table null, system, or local without imported symbols?
     */
    public static boolean isTrivialTable(SymbolTable table)
    {
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (table == null)         return true;</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (table.isSystemTable()) return true;</span>
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (table.isLocalTable()) {</span>
            // this is only true when there are no local
            // symbols defined
            // and there are no imports with any symbols
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (table.getMaxId() == table.getSystemSymbolTable().getMaxId()) {</span>
<span class="nc" id="L725">                return true;</span>
            }
        }
<span class="nc" id="L728">        return false;</span>
    }


    public static SymbolTable systemSymtab(int version)
    {
<span class="fc" id="L734">        return SharedSymbolTable.getSystemSymbolTable(version);</span>
    }


    public static SymbolTable newSharedSymtab(IonStruct ionRep)
    {
<span class="fc" id="L740">        return SharedSymbolTable.newSharedSymbolTable(ionRep);</span>
    }


    public static SymbolTable newSharedSymtab(IonReader reader,
                                              boolean alreadyInStruct)
    {
<span class="fc" id="L747">        return SharedSymbolTable.newSharedSymbolTable(reader, alreadyInStruct);</span>
    }


    /**
     * As per {@link IonSystem#newSharedSymbolTable(String, int, Iterator, SymbolTable...)},
     * any duplicate or null symbol texts are skipped.
     * Therefore, &lt;b&gt;THIS METHOD IS NOT SUITABLE WHEN READING SERIALIZED
     * SHARED SYMBOL TABLES&lt;/b&gt; since that scenario must preserve all sids.
     *
     * @param priorSymtab may be null.
     */
    public static SymbolTable newSharedSymtab(String name,
                                              int version,
                                              SymbolTable priorSymtab,
                                              Iterator&lt;String&gt; symbols)
    {
<span class="fc" id="L764">        return SharedSymbolTable.newSharedSymbolTable(name,</span>
                                                      version,
                                                      priorSymtab,
                                                      symbols);
    }


    /**
     * Creates a mutable copy of this local symbol table. The cloned table
     * will be created in the context of the same {@link ValueFactory}.
     * &lt;p&gt;
     * Note that the resulting symbol table holds a distinct, deep copy of the
     * given table, adding symbols on either instances will not modify the
     * other.
     *
     * @param symtab
     *
     * @return a new mutable {@link SymbolTable} instance; not null
     *
     * @throws IllegalArgumentException
     *          if the given table is not a local symbol table
     * @throws SubstituteSymbolTableException
     *          if any imported table by the given local symbol table is a
     *          substituted table (whereby no exact match was found in its
     *          catalog)
     */
    // TODO We need to think about providing a suitable recovery process
    //      or configuration for users to properly handle the case when the
    //      local symtab has substituted symtabs for imports.
    public static SymbolTable copyLocalSymbolTable(SymbolTable symtab)
        throws SubstituteSymbolTableException
    {
<span class="fc bfc" id="L796" title="All 2 branches covered.">        if (! symtab.isLocalTable())</span>
        {
<span class="fc" id="L798">            String message = &quot;symtab should be a local symtab&quot;;</span>
<span class="fc" id="L799">            throw new IllegalArgumentException(message);</span>
        }

<span class="fc" id="L802">        SymbolTable[] imports =</span>
<span class="fc" id="L803">            ((LocalSymbolTable) symtab).getImportedTablesNoCopy();</span>

        // Iterate over each import, we assume that the list of imports
        // rarely exceeds 5.
<span class="fc bfc" id="L807" title="All 2 branches covered.">        for (int i = 0; i &lt; imports.length; i++)</span>
        {
<span class="fc bfc" id="L809" title="All 2 branches covered.">            if (imports[i].isSubstitute())</span>
            {
<span class="fc" id="L811">                String message =</span>
                    &quot;local symtabs with substituted symtabs for imports &quot; +
                    &quot;(indicating no exact match within the catalog) cannot &quot; +
                    &quot;be copied&quot;;
<span class="fc" id="L815">                throw new SubstituteSymbolTableException(message);</span>
            }
        }

<span class="fc" id="L819">        return ((LocalSymbolTable) symtab).makeCopy();</span>
    }

    /**
     * Trampoline to {@link LocalSymbolTableAsStruct.Factory#Factory(ValueFactory)}
     * @param imageFactory
     *          the ValueFactory from which to construct the IonStruct representation of the LST
     * @return a new {@link LocalSymbolTableAsStruct.Factory}
     * @deprecated due to DOM entanglement. Streaming applications should use
     *             {@value LocalSymbolTable#DEFAULT_LST_FACTORY}.
     */
    @Deprecated
    public static _Private_LocalSymbolTableFactory newLocalSymbolTableAsStructFactory(ValueFactory imageFactory)
    {
<span class="fc" id="L833">        return new LocalSymbolTableAsStruct.Factory(imageFactory);</span>
    }

    /**
     * Returns a minimal symtab that, either system or local depending on the
     * given values, that supports representation as an IonStruct. If the
     * imports are empty, the default system symtab is returned.
     *
     * @param lstFactory
     *          the factory to use to build the local symbol table, never null
     * @param defaultSystemSymtab
     *          the default system symtab, which will be used if the first
     *          import in {@code imports} isn't a system symtab, never null
     * @param imports
     * the set of shared symbol tables to import; may be null or empty.
     * The first (and only the first) may be a system table, in which case the
     * {@code defaultSystemSymtab} is ignored.
     */
    public static SymbolTable initialSymtab(_Private_LocalSymbolTableFactory lstFactory,
                                            SymbolTable defaultSystemSymtab,
                                            SymbolTable... imports)
    {
<span class="pc bpc" id="L855" title="1 of 4 branches missed.">        if (imports == null || imports.length == 0)</span>
        {
<span class="fc" id="L857">            return defaultSystemSymtab;</span>
        }

<span class="pc bpc" id="L860" title="1 of 4 branches missed.">        if (imports.length == 1 &amp;&amp; imports[0].isSystemTable())</span>
        {
<span class="nc" id="L862">            return imports[0];</span>
        }

<span class="fc" id="L865">        return lstFactory.newLocalSymtab(defaultSystemSymtab, imports);</span>
    }


    @SuppressWarnings(&quot;deprecation&quot;)
    /**
     * Trampoline to
     * {@link LocalSymbolTableAsStruct#getIonRepresentation()};
     */
    public static IonStruct symtabTree(SymbolTable symtab)
    {
<span class="fc" id="L876">        return ((LocalSymbolTableAsStruct)symtab).getIonRepresentation();</span>
    }

    /**
     * Determines, for two local symbol tables, whether the passed-in {@code superset} symtab is an extension
     * of {@code subset}.  This works independent of implementation details--particularly in cases
     * where {@link LocalSymbolTable#symtabExtends(SymbolTable)} cannot be used.
     *
     * @see #symtabExtends(SymbolTable, SymbolTable)
     */
    private static boolean localSymtabExtends(SymbolTable superset, SymbolTable subset)
    {
<span class="fc bfc" id="L888" title="All 2 branches covered.">        if (subset.getMaxId() &gt; superset.getMaxId())</span>
        {
            // the subset has more symbols
<span class="fc" id="L891">            return false;</span>
        }

        // NB this API almost certainly requires cloning--symbol table's API doesn't give us a way to polymorphically
        //    get this without materializing an array
<span class="fc" id="L896">        final SymbolTable[] supersetImports     = superset.getImportedTables();</span>
<span class="fc" id="L897">        final SymbolTable[] subsetImports       = subset.getImportedTables();</span>

        // TODO this is over-strict, but not as strict as LocalSymbolTable.symtabExtends()
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">        if (supersetImports.length != subsetImports.length)</span>
        {
<span class="nc" id="L902">            return false;</span>
        }
        // NB we cannot trust Arrays.equals--we don't know how an implementation will implement it...
<span class="fc bfc" id="L905" title="All 2 branches covered.">        for (int i = 0; i &lt; supersetImports.length; i++)</span>
        {
<span class="fc" id="L907">            final SymbolTable supersetImport = supersetImports[i];</span>
<span class="fc" id="L908">            final SymbolTable subsetImport = subsetImports[i];</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">            if (!supersetImport.getName().equals(subsetImport.getName())</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">                 || supersetImport.getVersion() != subsetImport.getVersion())</span>
            {
                // bad match on import
<span class="fc" id="L913">                return false;</span>
            }
        }

        // all the imports lined up, lets make sure the locals line up too
<span class="fc" id="L918">        final Iterator&lt;String&gt; supersetIter     = superset.iterateDeclaredSymbolNames();</span>
<span class="fc" id="L919">        final Iterator&lt;String&gt; subsetIter       = subset.iterateDeclaredSymbolNames();</span>
<span class="fc bfc" id="L920" title="All 2 branches covered.">        while (subsetIter.hasNext())</span>
        {
<span class="fc" id="L922">            final String nextSubsetSymbol       = subsetIter.next();</span>
<span class="fc" id="L923">            final String nextSupersetSymbol     = supersetIter.next();</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">            if (!nextSubsetSymbol.equals(nextSupersetSymbol))</span>
            {
                // local symbol mismatch
<span class="fc" id="L927">                return false;</span>
            }
<span class="fc" id="L929">        }</span>

        // we made it this far--superset is really a superset of subset
<span class="fc" id="L932">        return true;</span>
    }

    /**
     * Determines whether the passed-in {@code superset} symtab is an extension
     * of {@code subset}.
     * &lt;p&gt;
     * If both are LSTs, their imported tables and locally declared symbols are
     * exhaustively checked, which can be expensive. Callers of this method
     * should cache the results of these comparisons.
     *
     * @param superset
     *                  either a system or local symbol table
     * @param subset
     *                  either a system or local symbol table
     *
     * @return true if {@code superset} extends {@code subset}, false if not
     */
    public static boolean symtabExtends(SymbolTable superset, SymbolTable subset)
    {
<span class="pc bpc" id="L952" title="2 of 6 branches missed.">        assert superset.isSystemTable() || superset.isLocalTable();</span>
<span class="pc bpc" id="L953" title="2 of 6 branches missed.">        assert subset.isSystemTable() || subset.isLocalTable();</span>

        // NB: system symtab 1.0 is a singleton, hence if both symtabs
        //     are one this will be true.
<span class="fc bfc" id="L957" title="All 2 branches covered.">        if (superset == subset) return true;</span>

        // If the subset's symtab is a system symtab, the superset's is always
        // an extension of the subset's as system symtab-ness is irrelevant to
        // the conditions for copy opt. to be safe.
        // TODO amzn/ion-java/issues/24 System symtab-ness ARE relevant if there's multiple
        //      versions.
<span class="fc bfc" id="L964" title="All 2 branches covered.">        if (subset.isSystemTable()) return true;</span>

        // From here on, subset is a LST because isSystemTable() is false.

<span class="fc bfc" id="L968" title="All 2 branches covered.">        if (superset.isLocalTable())</span>
        {
<span class="pc bpc" id="L970" title="3 of 4 branches missed.">            if (superset instanceof LocalSymbolTable &amp;&amp; subset instanceof LocalSymbolTable)</span>
            {
                // use the internal comparison
<span class="nc" id="L973">                return ((LocalSymbolTable) superset).symtabExtends(subset);</span>
            }
            // TODO reason about symbol tables that don't extend LocalSymbolTable but are still local
<span class="fc" id="L976">            return localSymtabExtends(superset, subset);</span>
        }

        // From here on, superset is a system symtab.

        // If LST subset has no local symbols or imports, and it's system
        // symbols are same as those of system symtab superset's, then
        // superset extends subset
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">        return subset.getMaxId() == superset.getMaxId();</span>
    }


    /**
     * Determines whether the passed-in data type is a scalar and not a symbol.
     */
    public static boolean isNonSymbolScalar(IonType type)
    {
<span class="fc bfc" id="L993" title="All 4 branches covered.">        return ! IonType.isContainer(type) &amp;&amp; ! type.equals(IonType.SYMBOL);</span>
    }


    /**
     * Returns the symbol ID matching a system symbol text of a
     * local or shared symtab field.
     */
    public static final int getSidForSymbolTableField(String text)
    {
<span class="fc" id="L1003">        final int shortestFieldNameLength = 4; // 'name'</span>

<span class="pc bpc" id="L1005" title="2 of 4 branches missed.">        if (text != null &amp;&amp; text.length() &gt;= shortestFieldNameLength)</span>
        {
<span class="fc" id="L1007">            int c = text.charAt(0);</span>
<span class="pc bpc" id="L1008" title="5 of 6 branches missed.">            switch (c)</span>
            {
                case 'v':
<span class="nc bnc" id="L1011" title="All 2 branches missed.">                    if (VERSION.equals(text))</span>
                    {
<span class="nc" id="L1013">                        return VERSION_SID;</span>
                    }
                    break;
                case 'n':
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                    if (NAME.equals(text))</span>
                    {
<span class="nc" id="L1019">                        return NAME_SID;</span>
                    }
                    break;
                case 's':
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                    if (SYMBOLS.equals(text))</span>
                    {
<span class="nc" id="L1025">                        return  SYMBOLS_SID;</span>
                    }
                    break;

                case 'i':
<span class="nc bnc" id="L1030" title="All 2 branches missed.">                    if (IMPORTS.equals(text))</span>
                    {
<span class="nc" id="L1032">                        return IMPORTS_SID;</span>
                    }
                    break;
                case 'm':
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                    if (MAX_ID.equals(text))</span>
                    {
<span class="nc" id="L1038">                        return MAX_ID_SID;</span>
                    }
                    break;
                default:
                    break;
            }
        }
<span class="fc" id="L1045">        return UNKNOWN_SYMBOL_ID;</span>
    }


    //========================================================================


    /**
     * Private to route clients through the static methods, which can
     * optimize the empty-list case.
     */
    private static final class StringIterator implements Iterator&lt;String&gt;
    {
        private final String[] _values;
        private int            _pos;
        private final int      _len;

<span class="fc" id="L1062">        StringIterator(String[] values, int len) {</span>
<span class="fc" id="L1063">            _values = values;</span>
<span class="fc" id="L1064">            _len = len;</span>
<span class="fc" id="L1065">        }</span>
        public boolean hasNext() {
<span class="fc bfc" id="L1067" title="All 2 branches covered.">            return (_pos &lt; _len);</span>
        }
        public String next() {
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">            if (!hasNext()) throw new NoSuchElementException();</span>
<span class="fc" id="L1071">            return _values[_pos++];</span>
        }
        public void remove() {
<span class="nc" id="L1074">            throw new UnsupportedOperationException();</span>
        }
    }

    public static final Iterator&lt;String&gt; stringIterator(String... values)
    {
<span class="pc bpc" id="L1080" title="1 of 4 branches missed.">        if (values == null || values.length == 0)</span>
        {
<span class="fc" id="L1082">            return _Private_Utils.&lt;String&gt;emptyIterator();</span>
        }
<span class="fc" id="L1084">        return new StringIterator(values, values.length);</span>
    }

    public static final Iterator&lt;String&gt; stringIterator(String[] values, int len)
    {
<span class="nc bnc" id="L1089" title="All 6 branches missed.">        if (values == null || values.length == 0 || len == 0)</span>
        {
<span class="nc" id="L1091">            return _Private_Utils.&lt;String&gt;emptyIterator();</span>
        }
<span class="nc" id="L1093">        return new StringIterator(values, len);</span>
    }

    /**
     * Private to route clients through the static methods, which can
     * optimize the empty-list case.
     */
    private static final class IntIterator implements Iterator&lt;Integer&gt;
    {
        private final int []  _values;
        private int           _pos;
        private final int     _len;

        IntIterator(int[] values) {
<span class="nc" id="L1107">            this(values, 0, values.length);</span>
<span class="nc" id="L1108">        }</span>
<span class="nc" id="L1109">        IntIterator(int[] values, int off, int len) {</span>
<span class="nc" id="L1110">            _values = values;</span>
<span class="nc" id="L1111">            _len = len;</span>
<span class="nc" id="L1112">            _pos = off;</span>
<span class="nc" id="L1113">        }</span>
        public boolean hasNext() {
<span class="nc bnc" id="L1115" title="All 2 branches missed.">            return (_pos &lt; _len);</span>
        }
        public Integer next() {
<span class="nc bnc" id="L1118" title="All 2 branches missed.">            if (!hasNext()) throw new NoSuchElementException();</span>
<span class="nc" id="L1119">            int value = _values[_pos++];</span>
<span class="nc" id="L1120">            return value;</span>
        }
        public void remove() {
<span class="nc" id="L1123">            throw new UnsupportedOperationException();</span>
        }
    }

    public static final Iterator&lt;Integer&gt; intIterator(int... values)
    {
<span class="nc bnc" id="L1129" title="All 4 branches missed.">        if (values == null || values.length == 0)</span>
        {
<span class="nc" id="L1131">            return _Private_Utils.&lt;Integer&gt;emptyIterator();</span>
        }
<span class="nc" id="L1133">        return new IntIterator(values);</span>
    }

    public static final Iterator&lt;Integer&gt; intIterator(int[] values, int len)
    {
<span class="nc bnc" id="L1138" title="All 6 branches missed.">        if (values == null || values.length == 0 || len == 0)</span>
        {
<span class="nc" id="L1140">            return _Private_Utils.&lt;Integer&gt;emptyIterator();</span>
        }
<span class="nc" id="L1142">        return new IntIterator(values, 0, len);</span>
    }

    public static void writeAsBase64(InputStream byteStream, Appendable out)
        throws IOException
    {
<span class="fc" id="L1148">        Base64Encoder.TextStream ts = new Base64Encoder.TextStream(byteStream);</span>

        for (;;) {
<span class="fc" id="L1151">            int c = ts.read();</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">            if (c == -1) break;</span>
<span class="fc" id="L1153">            out.append((char) c);</span>
<span class="fc" id="L1154">        }</span>
<span class="fc" id="L1155">    }</span>

    public static SymbolTable newSubstituteSymtab(SymbolTable original,
                                                  int version,
                                                  int maxId)
    {
<span class="nc" id="L1161">        return new SubstituteSymbolTable(original, version, maxId);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>