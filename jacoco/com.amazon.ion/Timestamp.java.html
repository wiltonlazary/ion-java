<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Timestamp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion</a> &gt; <span class="el_source">Timestamp.java</span></div><h1>Timestamp.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion;

import static com.amazon.ion.impl._Private_Utils.safeEquals;
import static com.amazon.ion.util.IonTextUtils.printCodePointAsString;

import com.amazon.ion.impl._Private_Utils;
import com.amazon.ion.util.IonTextUtils;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;

/**
 * An immutable representation of a point in time. Ion defines a simple
 * representation of time based on Coordinated Universal Time (UTC).
 * In practice the use of time could be more accurately described as
 * UTC-SLS (UTC Smoothed Leap Seconds) as there is no representation for the
 * leap second discontinuities that UTC has added.
 * &lt;p&gt;
 * Timestamps preserve precision, meaning the fields that are included, and the
 * significant digits of any fractional second.  Only common break
 * points in the values are supported.  Any unspecified fields are handled
 * as the start of the new year/month/day.
 *
 *
 * &lt;h3&gt;Equality and Comparison&lt;/h3&gt;
 *
 * As with {@link IonValue} classes, the {@link #equals equals} methods on this class
 * perform a strict equivalence that observes the precision and local offset
 * of each timestamp.
 * This means that it's possible to have two {@link Timestamp} instances that
 * represent the same point in time but are not {@code equals}.
 * &lt;p&gt;
 * On the other hand, the {@link #compareTo} methods perform point in time
 * comparison, ignoring precision and local offset.
 * Thus the &lt;em&gt;natural comparison method&lt;/em&gt; of this class is &lt;em&gt;not
 * consistent with equals&lt;/em&gt;. See the documentation of {@link Comparable} for
 * further discussion.
 * &lt;p&gt;
 * To illustrate this distinction, consider the following timestamps. None are
 * {@link #equals} to each other, but any pair will return a zero result from
 * {@link #compareTo}.
 * &lt;ul&gt;
 *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
 *   &lt;li&gt;{@code 2009-01-01T00:00:00.000Z} &lt;em&gt;etc.&lt;/em&gt;&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @see #equals(Timestamp)
 * @see #compareTo(Timestamp)
 */
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">public final class Timestamp</span>
    implements Comparable&lt;Timestamp&gt;, Cloneable
{
    private static final boolean APPLY_OFFSET_YES = true;
    private static final boolean APPLY_OFFSET_NO = false;

    private static final int NO_MONTH = 0;
    private static final int NO_DAY = 0;
    private static final int NO_HOURS = 0;
    private static final int NO_MINUTES = 0;
    private static final int NO_SECONDS = 0;
<span class="fc" id="L85">    private static final BigDecimal NO_FRACTIONAL_SECONDS = null;</span>

    /**
     * 0001-01-01T00:00:00.0Z in millis.
     */
    static final long MINIMUM_TIMESTAMP_IN_MILLIS = -62135769600000L;

    /**
     * 0001-01-01T00:00:00.0Z in millis.
     */
<span class="fc" id="L95">    static final BigDecimal MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(MINIMUM_TIMESTAMP_IN_MILLIS);</span>

    /**
     * 10000T in millis, upper bound exclusive.
     */
    static final long MAXIMUM_TIMESTAMP_IN_MILLIS = 253402300800000L;

    /**
     * 10000T in millis, upper bound exclusive.
     */
<span class="fc" id="L105">    static final BigDecimal MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL = new BigDecimal(MAXIMUM_TIMESTAMP_IN_MILLIS);</span>


    /**
     * 0001-01-01T00:00:00.0Z epoch seconds.
     */
    static final long MINIMUM_TIMESTAMP_IN_EPOCH_SECONDS = MINIMUM_TIMESTAMP_IN_MILLIS / 1000;

    /**
     * 10000T in epoch seconds, upper bound exclusive.
     */
    static final long MAXIMUM_TIMESTAMP_IN_EPOCH_SECONDS = MAXIMUM_TIMESTAMP_IN_MILLIS / 1000;

    /**
     * Unknown local offset from UTC.
     */
<span class="fc" id="L121">    public static final Integer UNKNOWN_OFFSET = null;</span>

    /**
     * Local offset of zero hours from UTC.
     */
<span class="fc" id="L126">    public static final Integer UTC_OFFSET = Integer.valueOf(0);</span>

    private static final int FLAG_YEAR      = 0x01;
    private static final int FLAG_MONTH     = 0x02;
    private static final int FLAG_DAY       = 0x04;
    private static final int FLAG_MINUTE    = 0x08;
    private static final int FLAG_SECOND    = 0x10;

    /**
     * The precision of the Timestamp.
     */
<span class="fc" id="L137">    public static enum Precision {</span>
<span class="fc" id="L138">        YEAR    (FLAG_YEAR),</span>
<span class="fc" id="L139">        MONTH   (FLAG_YEAR | FLAG_MONTH),</span>
<span class="fc" id="L140">        DAY     (FLAG_YEAR | FLAG_MONTH | FLAG_DAY),</span>
        // HOUR is not a supported precision per https://www.w3.org/TR/NOTE-datetime
<span class="fc" id="L142">        MINUTE  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE),</span>
<span class="fc" id="L143">        SECOND  (FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE | FLAG_SECOND),</span>

        /**
         * DEPRECATED! Treating the fractional part of seconds separate from
         * the integer part has led to countless bugs. We intend to combine
         * the two under the SECOND precision.
         *
         */
<span class="fc" id="L151">        @Deprecated</span>
        FRACTION(FLAG_YEAR | FLAG_MONTH | FLAG_DAY | FLAG_MINUTE | FLAG_SECOND);

        /** Bit flags for the precision. */
        private final int flags;

        private Precision(int flags)
<span class="fc" id="L158">        {</span>
<span class="fc" id="L159">            this.flags = flags;</span>
<span class="fc" id="L160">        }</span>

        public boolean includes(Precision isIncluded)
        {
<span class="pc bpc" id="L164" title="1 of 6 branches missed.">            switch (isIncluded)</span>
            {
                case FRACTION:
<span class="fc bfc" id="L167" title="All 2 branches covered.">                case SECOND:    return (flags &amp; FLAG_SECOND)   != 0;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">                case MINUTE:    return (flags &amp; FLAG_MINUTE)   != 0;</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                case DAY:       return (flags &amp; FLAG_DAY)      != 0;</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                case MONTH:     return (flags &amp; FLAG_MONTH)    != 0;</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">                case YEAR:      return (flags &amp; FLAG_YEAR)     != 0;</span>
                default:        break;
            }
<span class="nc" id="L174">            throw new IllegalStateException(&quot;unrecognized precision&quot; + isIncluded);</span>
        }

        private boolean alwaysUnknownOffset()
        {
<span class="fc bfc" id="L179" title="All 2 branches covered.">            return this.ordinal() &lt;= DAY.ordinal();</span>
        }
    }

<span class="fc" id="L183">    private static final int HASH_SIGNATURE =</span>
<span class="fc" id="L184">        &quot;INTERNAL TIMESTAMP&quot;.hashCode();</span>

    /**
     * The precision of the Timestamp. The fractional seconds component is
     * defined by a BigDecimal.
     * &lt;p&gt;
     * During construction of all Timestamps, they will have a
     * date value (i.e. Year, Month, Day) but with reduced precision they may
     * exclude any time values that are more precise than the precision that is
     * being defined.
     */
    private Precision   _precision;

    // These are the time field values for the Timestamp.
    // _month and _day are 1-based (0 is an invalid value for
    // these in a non-null Timestamp).
    private short       _year;
<span class="fc" id="L201">    private byte        _month = 1; // Initialized to valid default</span>
<span class="fc" id="L202">    private byte        _day   = 1; // Initialized to valid default</span>
    private byte        _hour;
    private byte        _minute;
    private byte        _second;
    private BigDecimal  _fraction;  // fractional seconds, must be within range [0, 1)

    /**
     * Minutes offset from UTC; zero means UTC proper,
     * &lt;code&gt;null&lt;/code&gt; means that the offset is unknown.
     */
    private Integer     _offset;

                                                      //   jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
                                                      // the first 0 is to make these arrays 1 based (since month values are 1-12)
<span class="fc" id="L216">    private static final int[] LEAP_DAYS_IN_MONTH   = { 0,  31,  29,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };</span>
<span class="fc" id="L217">    private static final int[] NORMAL_DAYS_IN_MONTH = { 0,  31,  28,  31,  30,  31,  30,  31,  31,  30,  31,  30,  31 };</span>

    private static int last_day_in_month(int year, int month) {
        boolean is_leap;
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if ((year % 4) == 0) {</span>
            // divisible by 4 (lower 2 bits are zero) - may be a leap year
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if ((year % 100) == 0) {</span>
                // and divisible by 100 - not a leap year
<span class="fc bfc" id="L225" title="All 2 branches covered.">                if ((year % 400) == 0) {</span>
                    // but divisible by 400 - then it is a leap year
<span class="fc" id="L227">                    is_leap = true;</span>
                }
                else {
<span class="fc" id="L230">                    is_leap = false;</span>
                }
            }
            else {
<span class="fc" id="L234">                is_leap = true;</span>
            }
        }
        else {
<span class="fc" id="L238">            is_leap = false;</span>
        }
<span class="fc bfc" id="L240" title="All 2 branches covered.">        return is_leap ? LEAP_DAYS_IN_MONTH[month] : NORMAL_DAYS_IN_MONTH[month];</span>
    }

    /**
     * Applies the local time zone offset from UTC to the applicable time field
     * values. Depending on the local time zone offset, adjustments
     * (i.e. rollover) will be made to the Year, Day, Hour, Minute time field
     * values.
     *
     * @param offset the local offset, in minutes from UTC.
     */
    private void apply_offset(int offset)
    {
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (offset == 0) return;</span>
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">        if (offset &lt; -24*60 || offset &gt; 24*60) {</span>
<span class="nc" id="L255">            throw new IllegalArgumentException(&quot;bad offset &quot; + offset);</span>
        }
        // To convert _to_ UTC you must SUBTRACT the local offset
<span class="fc" id="L258">        offset = -offset;</span>
<span class="fc" id="L259">        int hour_offset = offset / 60;</span>
<span class="fc" id="L260">        int min_offset = offset - (hour_offset * 60);</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">        if (offset &lt; 0) {</span>
<span class="fc" id="L263">            _minute += min_offset;  // lower the minute value by adding a negative offset</span>
<span class="fc" id="L264">            _hour += hour_offset;</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">            if (_minute &lt; 0) {</span>
<span class="fc" id="L266">                _minute += 60;</span>
<span class="fc" id="L267">                _hour -= 1;</span>
            }
<span class="fc bfc" id="L269" title="All 2 branches covered.">            if (_hour &gt;= 0) return;  // hour is 0-23</span>
<span class="fc" id="L270">            _hour += 24;</span>
<span class="fc" id="L271">            _day -= 1;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">            if (_day &gt;= 1) return;  // day is 1-31</span>
            // we can't do this until we've figured out the month and year: _day += last_day_in_month(_year, _month);
<span class="fc" id="L274">            _month -= 1;</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">            if (_month &gt;= 1) {</span>
<span class="fc" id="L276">                _day += last_day_in_month(_year, _month);  // now we know (when the year doesn't change</span>
<span class="pc bpc" id="L277" title="2 of 4 branches missed.">                assert(_day == last_day_in_month(_year, _month));</span>
<span class="fc" id="L278">                return;  // 1-12</span>
            }
<span class="fc" id="L280">            _month += 12;</span>
<span class="fc" id="L281">            _year -= 1;</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            if (_year &lt; 1) throw new IllegalArgumentException(&quot;year is less than 1&quot;);</span>
<span class="fc" id="L283">            _day += last_day_in_month(_year, _month);  // and now we know, even if the year did change</span>
<span class="pc bpc" id="L284" title="2 of 4 branches missed.">            assert(_day == last_day_in_month(_year, _month));</span>
        }
        else {
<span class="fc" id="L287">            _minute += min_offset;  // lower the minute value by adding a negative offset</span>
<span class="fc" id="L288">            _hour += hour_offset;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (_minute &gt; 59) {</span>
<span class="fc" id="L290">                _minute -= 60;</span>
<span class="fc" id="L291">                _hour += 1;</span>
            }
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (_hour &lt; 24) return;  // hour is 0-23</span>
<span class="fc" id="L294">            _hour -= 24;</span>
<span class="fc" id="L295">            _day += 1;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (_day &lt;= last_day_in_month(_year, _month)) return;  // day is 1-31</span>
            // we can't do this until we figure out the final month and year: _day -= last_day_in_month(_year, _month);
<span class="fc" id="L298">            _day = 1; // this is always the case</span>
<span class="fc" id="L299">            _month += 1;</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">            if (_month &lt;= 12) {</span>
<span class="fc" id="L301">                return;  // 1-12</span>
            }
<span class="fc" id="L303">            _month -= 12;</span>
<span class="fc" id="L304">            _year += 1;</span>
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">            if (_year &gt; 9999) throw new IllegalArgumentException(&quot;year exceeds 9999&quot;);</span>
        }
<span class="fc" id="L307">    }</span>

    private static byte requireByte(int value, String location) {
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">        if (value &gt; Byte.MAX_VALUE || value &lt; Byte.MIN_VALUE) {</span>
<span class="nc" id="L311">            throw new IllegalArgumentException(String.format(&quot;%s of %d is out of range.&quot;, location, value));</span>
        }
<span class="fc" id="L313">        return (byte) value;</span>
    }

    private static short requireShort(int value, String location) {
<span class="pc bpc" id="L317" title="2 of 4 branches missed.">        if (value &gt; Short.MAX_VALUE || value &lt; Short.MIN_VALUE) {</span>
<span class="nc" id="L318">            throw new IllegalArgumentException(String.format(&quot;%s of %d is out of range.&quot;, location, value));</span>
        }
<span class="fc" id="L320">        return (short) value;</span>
    }

    /**
     * This method uses deprecated methods from {@link java.util.Date}
     * instead of {@link Calendar} so that this code can be used (more easily)
     * on the mobile Java platform (which has Date but does not have Calendar).
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    private void set_fields_from_millis(long millis)
    {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if(millis &lt; MINIMUM_TIMESTAMP_IN_MILLIS){</span>
<span class="nc" id="L332">            throw new IllegalArgumentException(&quot;year is less than 1&quot;);</span>
        }

<span class="fc" id="L335">        Date date = new Date(millis);</span>

        // The Date getters return values in the Date's time zone (i.e. the system time zone).
        // The components need to be converted to UTC before being validated for exact ranges, because the offset
        // conversion can affect which values are considered valid. Simply verify that the values can fit in the
        // destination type here. If they do not, they would be out of range no matter the offset.
<span class="fc" id="L341">        _minute = requireByte(date.getMinutes(), &quot;Minute&quot;);</span>
<span class="fc" id="L342">        _second = requireByte(date.getSeconds(), &quot;Second&quot;);</span>
<span class="fc" id="L343">        _hour = requireByte(date.getHours(), &quot;Hour&quot;);</span>
<span class="fc" id="L344">        _day = requireByte(date.getDate(), &quot;Day&quot;);</span>
<span class="fc" id="L345">        _month = requireByte(date.getMonth() + 1, &quot;Month&quot;);</span>

        // Date does not correctly handle year values that represent year 0 or earlier in the system time zone through
        // getYear(). This case is detected and forced to zero.
<span class="fc" id="L349">        int offset = -date.getTimezoneOffset();</span>
<span class="pc bpc" id="L350" title="3 of 4 branches missed.">        if(offset &lt; 0 &amp;&amp; MINIMUM_TIMESTAMP_IN_MILLIS - offset &gt; millis) {</span>
<span class="nc" id="L351">            _year = 0;</span>
        } else {
<span class="fc" id="L353">            _year = requireShort(date.getYear() + 1900, &quot;Year&quot;);</span>
        }

        // Now apply the offset to convert the components to UTC.
<span class="fc" id="L357">        apply_offset(offset);</span>

        // Now that all components are in UTC, they may be validated for exact ranges.
<span class="fc" id="L360">        this._year    = checkAndCastYear(_year);</span>
<span class="fc" id="L361">        this._month   = checkAndCastMonth(_month);</span>
<span class="fc" id="L362">        this._day     = checkAndCastDay(_day, _year, _month);</span>
<span class="fc" id="L363">        this._hour    = checkAndCastHour(_hour);</span>
<span class="fc" id="L364">        this._minute  = checkAndCastMinute(_minute);</span>
<span class="fc" id="L365">        this._second  = checkAndCastSecond(_second);</span>
<span class="fc" id="L366">    }</span>

    /**
     * Copies data from a {@link Calendar} into this timestamp.
     * Must only be called during construction due to timestamp immutabliity.
     *
     * @param cal must have at least one field set.
     *
     * @throws IllegalArgumentException if the calendar has no fields set.
     */
    private void set_fields_from_calendar(Calendar cal,
                                          Precision precision,
                                          boolean setLocalOffset)
    {
<span class="fc" id="L380">        _precision = precision;</span>
<span class="fc" id="L381">        _offset = UNKNOWN_OFFSET;</span>
<span class="fc" id="L382">        boolean dayPrecision = false;</span>
<span class="fc" id="L383">        boolean calendarHasMilliseconds = cal.isSet(Calendar.MILLISECOND);</span>

<span class="pc bpc" id="L385" title="1 of 6 branches missed.">        switch (this._precision) {</span>
            case FRACTION:
            case SECOND:
<span class="fc" id="L388">                this._second = checkAndCastSecond(cal.get(Calendar.SECOND));</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                if (calendarHasMilliseconds) {</span>
<span class="fc" id="L390">                    BigDecimal millis = BigDecimal.valueOf(cal.get(Calendar.MILLISECOND));</span>
<span class="fc" id="L391">                    this._fraction = millis.movePointLeft(3); // convert to fraction</span>
<span class="fc" id="L392">                    checkFraction(precision, this._fraction);</span>
                }
            case MINUTE:
            {
<span class="fc" id="L396">                this._hour   = checkAndCastHour(cal.get(Calendar.HOUR_OF_DAY));</span>
<span class="fc" id="L397">                this._minute = checkAndCastMinute(cal.get(Calendar.MINUTE));</span>

                // If this test is made before calling get(), it will return
                // false even when Calendar.setTimeZone() was called.
<span class="pc bpc" id="L401" title="1 of 4 branches missed.">                if (setLocalOffset &amp;&amp; cal.isSet(Calendar.ZONE_OFFSET))</span>
                {
<span class="fc" id="L403">                    int offset = cal.get(Calendar.ZONE_OFFSET);</span>
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">                    if (cal.isSet(Calendar.DST_OFFSET)) {</span>
<span class="fc" id="L405">                        offset += cal.get(Calendar.DST_OFFSET);</span>
                    }

                    // convert ms to minutes
<span class="fc" id="L409">                    _offset = offset / (1000*60);</span>
                }
            }
            case DAY:
<span class="fc" id="L413">                dayPrecision = true;</span>
            case MONTH:
                // Calendar months are 0 based, Timestamp months are 1 based
<span class="fc" id="L416">                this._month  = checkAndCastMonth((cal.get(Calendar.MONTH) + 1));</span>
            case YEAR:
                int year;
<span class="fc bfc" id="L419" title="All 2 branches covered.">                if(cal.get(Calendar.ERA) == GregorianCalendar.AD) {</span>
<span class="fc" id="L420">                    year = cal.get(Calendar.YEAR);</span>
                }
                else {
<span class="fc" id="L423">                    year = -cal.get(Calendar.YEAR);</span>
                }

<span class="fc" id="L426">                this._year = checkAndCastYear(year);</span>
        }

<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (dayPrecision)</span>
        {
<span class="fc" id="L431">            this._day = checkAndCastDay(cal.get(Calendar.DAY_OF_MONTH), _year, _month);</span>
        }

<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (_offset != UNKNOWN_OFFSET) {</span>
            // Transform our members from local time to Zulu
<span class="fc" id="L436">            this.apply_offset(_offset);</span>
        }
<span class="fc" id="L438">    }</span>

    /**
     * Creates a new Timestamp, precise to the year, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    private Timestamp(int zyear)
    {
<span class="fc" id="L447">        this(Precision.YEAR, zyear, NO_MONTH, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L448">    }</span>

    /**
     * Creates a new Timestamp, precise to the month, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    private Timestamp(int zyear, int zmonth)
    {
<span class="fc" id="L457">        this(Precision.MONTH, zyear, zmonth, NO_DAY, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L458">    }</span>

    /**
     * Creates a new Timestamp, precise to the day, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     *
     * @deprecated Use {@link #forDay(int, int, int)} instead.
     */
    @Deprecated
    public Timestamp(int zyear, int zmonth, int zday)
    {
<span class="fc" id="L470">        this(Precision.DAY, zyear, zmonth, zday, NO_HOURS, NO_MINUTES, NO_SECONDS, NO_FRACTIONAL_SECONDS, UNKNOWN_OFFSET, APPLY_OFFSET_NO);</span>
<span class="fc" id="L471">    }</span>


    /**
     * Creates a new Timestamp, precise to the minute, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @deprecated Use {@link #forMinute(int, int, int, int, int, Integer)} instead.
     */
    @Deprecated
    public Timestamp(int year, int month, int day,
                     int hour, int minute,
                     Integer offset)
    {
<span class="fc" id="L493">        this(Precision.MINUTE, year, month, day, hour, minute, NO_SECONDS, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L494">    }</span>

    /**
     * Creates a new Timestamp, precise to the second, with a given local
     * offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     * @deprecated Use {@link #forSecond(int, int, int, int, int, int, Integer)} instead.
     */
    @Deprecated
    public Timestamp(int year, int month, int day,
                     int hour, int minute, int second,
                     Integer offset)
    {
<span class="fc" id="L515">        this(Precision.SECOND, year, month, day, hour, minute, second, NO_FRACTIONAL_SECONDS, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L516">    }</span>

    /**
     * Creates a new Timestamp, precise to the second or fractional second,
     * with a given local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss.fff+-oo:oo}, where {@code oo:oo} represents
     * the hour and minutes of the local offset from UTC, and {@code fff}
     * represents the fractional seconds.
     *
     * @param frac
     *          the fractional seconds; must not be {@code null}; if negative,
     *          its absolute value is used
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code frac} is {@code null}
     *
     * @deprecated Use {@link #forSecond(int, int, int, int, int, BigDecimal, Integer)}
     * instead.
     */
    @Deprecated
    public Timestamp(int year, int month, int day,
                     int hour, int minute, int second, BigDecimal frac,
                     Integer offset)
    {
<span class="fc" id="L544">        this(Precision.SECOND, year, month, day, hour, minute, second, frac, offset, APPLY_OFFSET_YES);</span>
<span class="fc" id="L545">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     *
     * @param frac must be &gt;= 0 and &lt; 1
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @see #createFromUtcFields(Precision, int, int, int, int, int, int, BigDecimal, Integer)
     */
    private Timestamp(Precision p, int zyear, int zmonth, int zday,
                      int zhour, int zminute, int zsecond, BigDecimal frac,
                      Integer offset, boolean shouldApplyOffset)
<span class="fc" id="L568">    {</span>
<span class="fc" id="L569">        boolean dayPrecision = false;</span>

<span class="pc bpc" id="L571" title="1 of 6 branches missed.">        switch (p) {</span>
        default:
<span class="nc" id="L573">            throw new IllegalArgumentException(&quot;invalid Precision passed to constructor&quot;);</span>
        case FRACTION:
        case SECOND:
<span class="fc bfc" id="L576" title="All 4 branches covered.">            if (frac == null || frac.equals(BigDecimal.ZERO))</span>
            {
<span class="fc" id="L578">                _fraction = null;</span>
            }
            else
            {
<span class="fc" id="L582">                _fraction = frac.abs();</span>
            }
<span class="fc" id="L584">            _second = checkAndCastSecond(zsecond);</span>
        case MINUTE:
<span class="fc" id="L586">            _minute = checkAndCastMinute(zminute);</span>
<span class="fc" id="L587">            _hour   = checkAndCastHour(zhour);</span>
<span class="fc" id="L588">            _offset = offset;      // offset must be null for years/months/days</span>
        case DAY:
<span class="fc" id="L590">             dayPrecision = true;</span>
        case MONTH:
<span class="fc" id="L592">            _month  = checkAndCastMonth(zmonth);</span>
        case YEAR:
<span class="fc" id="L594">            _year   = checkAndCastYear(zyear);</span>
        }

<span class="fc bfc" id="L597" title="All 2 branches covered.">        if (dayPrecision)</span>
        {
<span class="fc" id="L599">            _day    = checkAndCastDay(zday, zyear, zmonth);</span>
        }

<span class="fc" id="L602">        _precision = checkFraction(p, _fraction);</span>

<span class="fc bfc" id="L604" title="All 4 branches covered.">        if (shouldApplyOffset &amp;&amp; offset != null) {</span>
<span class="fc" id="L605">            apply_offset(offset);</span>
        }
<span class="fc" id="L607">    }</span>

    /**
     * Creates a new Timestamp from the individual time components. The
     * individual time components are expected to be in UTC,
     * with the local offset from UTC (i.e. {@code offset}) &lt;em&gt;already
     * applied&lt;/em&gt; to the time components.
     * As such, if the given {@code offset} is non-null or zero, the resulting
     * Timestamp will have time values that &lt;em&gt;DO NOT&lt;/em&gt; match the time
     * parameters. This method also has a behavior of precision &quot;narrowing&quot;,
     * detailed in the sub-section below.
     *
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values (in its local time) respectively:
     *&lt;pre&gt;
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;null&lt;/b&gt;)    will return 2012-02-03T04:05:06.007-00:00 (match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;0&lt;/b&gt;)       will return 2012-02-03T04:05:06.007+00:00 (match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;480&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;12&lt;/b&gt;:05:06.007&lt;b&gt;+08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-480&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;20&lt;/b&gt;:05:06.007&lt;b&gt;-08:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;720&lt;/b&gt;)     will return 2012-02-03T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;+12:00&lt;/b&gt; (do not match)
     * createFromUtcFields(Precision.SECOND, 2012, 2, 3, 4, 5, 6, 0.007, &lt;b&gt;-720&lt;/b&gt;)    will return 2012-02-&lt;b&gt;02&lt;/b&gt;T&lt;b&gt;16&lt;/b&gt;:05:06.007&lt;b&gt;-12:00&lt;/b&gt; (do not match)
     *&lt;/pre&gt;
     * Note: All of these resulting Timestamps have the similar value (in UTC) 2012-02-03T04:05:06.007Z.
     *
     * &lt;h3&gt;Precision &quot;Narrowing&quot;&lt;/h3&gt;
     *
     * &lt;p&gt;
     * Any time component that is more precise
     * than the precision parameter {@code p} will be &lt;em&gt;excluded&lt;/em&gt; from the
     * calculation of the resulting Timestamp's point in time.
     * &lt;p&gt;
     * For example, the following method calls will return Timestamps with
     * values respectively:
     *&lt;pre&gt;
     * createFromUtcFields(&lt;b&gt;Precision.YEAR&lt;/b&gt;    , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012T
     * createFromUtcFields(&lt;b&gt;Precision.MONTH&lt;/b&gt;   , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02T
     * createFromUtcFields(&lt;b&gt;Precision.DAY&lt;/b&gt;     , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T
     * createFromUtcFields(&lt;b&gt;Precision.MINUTE&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05Z
     * createFromUtcFields(&lt;b&gt;Precision.SECOND&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6,  null, 0)    will return 2012-02-03T04:05:06Z
     * createFromUtcFields(&lt;b&gt;Precision.SECOND&lt;/b&gt;  , 2012, 2, 3, 4, 5, 6, 0.007, 0)    will return 2012-02-03T04:05:06.007Z
     *&lt;/pre&gt;
     *
     * @param p the desired timestamp precision. The result may have a
     * different precision if the input data isn't precise enough.
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     */
    @Deprecated
    public static Timestamp
    createFromUtcFields(Precision p, int zyear, int zmonth, int zday,
                        int zhour, int zminute, int zsecond, BigDecimal frac,
                        Integer offset)
    {
<span class="fc" id="L663">        return new Timestamp(p, zyear, zmonth, zday,</span>
                             zhour, zminute, zsecond, frac,
                             offset, APPLY_OFFSET_NO);
    }

    /**
     * Creates a new Timestamp from a {@link Calendar}, preserving the
     * {@link Calendar}'s precision and local offset from UTC.
     * &lt;p&gt;
     * The most precise calendar field of {@code cal} will be used to determine
     * the precision of the resulting Timestamp.
     *
     * For example, the calendar field will have a Timestamp precision accordingly:
     * &lt;ul&gt;
     *   &lt;li&gt;{@link Calendar#YEAR} - year precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MONTH} - month precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#DAY_OF_MONTH} - day precision, unknown local offset&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#HOUR_OF_DAY} or {@link Calendar#MINUTE} - minute precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#SECOND} - second precision&lt;/li&gt;
     *   &lt;li&gt;{@link Calendar#MILLISECOND} - fractional second precision&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @throws IllegalArgumentException
     *          if {@code cal} has no appropriate calendar fields set.
     *
     * @deprecated Use {@link #forCalendar(Calendar)} instead.
     */
    @Deprecated
    public Timestamp(Calendar cal)
<span class="fc" id="L692">    {</span>
        Precision precision;

<span class="fc bfc" id="L695" title="All 4 branches covered.">        if (cal.isSet(Calendar.MILLISECOND) || cal.isSet(Calendar.SECOND)) {</span>
<span class="fc" id="L696">            precision = Precision.SECOND;</span>
        }
<span class="pc bpc" id="L698" title="1 of 4 branches missed.">        else if (cal.isSet(Calendar.HOUR_OF_DAY) || cal.isSet(Calendar.MINUTE)) {</span>
<span class="fc" id="L699">            precision = Precision.MINUTE;</span>
        }
<span class="fc bfc" id="L701" title="All 2 branches covered.">        else if (cal.isSet(Calendar.DAY_OF_MONTH)) {</span>
<span class="fc" id="L702">            precision = Precision.DAY;</span>
        }
<span class="fc bfc" id="L704" title="All 2 branches covered.">        else if (cal.isSet(Calendar.MONTH)) {</span>
<span class="fc" id="L705">            precision = Precision.MONTH;</span>
        }
<span class="fc bfc" id="L707" title="All 2 branches covered.">        else if (cal.isSet(Calendar.YEAR)) {</span>
<span class="fc" id="L708">            precision = Precision.YEAR;</span>
        }
        else {
<span class="fc" id="L711">            throw new IllegalArgumentException(&quot;Calendar has no fields set&quot;);</span>
        }

<span class="fc" id="L714">        set_fields_from_calendar(cal, precision, true);</span>
<span class="fc" id="L715">    }</span>


    private Timestamp(Calendar cal, Precision precision, BigDecimal fraction,
                      Integer offset)
<span class="fc" id="L720">    {</span>
<span class="fc" id="L721">        set_fields_from_calendar(cal, precision, false);</span>
<span class="fc" id="L722">        _fraction = fraction;</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">        if (offset != null)</span>
        {
<span class="fc" id="L725">            _offset = offset;</span>
<span class="fc" id="L726">            apply_offset(offset);</span>
        }
<span class="fc" id="L728">    }</span>


    private Timestamp(BigDecimal millis, Precision precision, Integer localOffset)
<span class="fc" id="L732">    {</span>
        // check bounds to avoid hanging when calling longValue() on decimals with large positive exponents,
        // e.g. 1e10000000
<span class="fc bfc" id="L735" title="All 2 branches covered.">        if(millis.compareTo(MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL) &lt; 0 ||</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">                MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL.compareTo(millis) &lt;= 0) {</span>
<span class="nc" id="L737">            throwTimestampOutOfRangeError(millis);</span>
        }
        // quick handle integral zero
<span class="fc bfc" id="L740" title="All 2 branches covered.">        long ms = isIntegralZero(millis) ? 0 : millis.longValue();</span>
<span class="fc" id="L741">        set_fields_from_millis(ms);</span>

<span class="fc bfc" id="L743" title="All 5 branches covered.">        switch (precision)</span>
        {
            case YEAR:
<span class="fc" id="L746">                _month  = 1;</span>
            case MONTH:
<span class="fc" id="L748">                _day    = 1;</span>
            case DAY:
<span class="fc" id="L750">                _hour   = 0;</span>
<span class="fc" id="L751">                _minute = 0;</span>
            case MINUTE:
<span class="fc" id="L753">                _second = 0;</span>
            case SECOND:
            case FRACTION:
        }

<span class="fc" id="L758">        _offset = localOffset;</span>
        // The given BigDecimal may contain greater than milliseconds precision, which is the maximum precision that
        // a Calendar can handle. Set the _fraction here so that extra precision (if any) is not lost.
        // However, don't set the fraction if the given BigDecimal does not have precision at least to the tenth of
        // a second.
<span class="pc bpc" id="L763" title="1 of 4 branches missed.">        if ((precision.includes(Precision.SECOND)) &amp;&amp; millis.scale() &gt; -3) {</span>
<span class="fc" id="L764">            BigDecimal secs = millis.movePointLeft(3);</span>
<span class="fc" id="L765">            BigDecimal secsDown = fastRoundZeroFloor(secs);</span>
<span class="fc" id="L766">            _fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L767">        } else {</span>
<span class="fc" id="L768">            _fraction = null;</span>
        }
<span class="fc" id="L770">        _precision = checkFraction(precision, _fraction);</span>
<span class="fc" id="L771">    }</span>


    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds (including any fractional
     * milliseconds) from the epoch, with a given local offset.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the second if {@code millis}
     * doesn't contain information that is more granular than seconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;132541995e4 (132541995 &amp;times; 10&lt;sup&gt;4&lt;/sup&gt;)&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30Z},
     * precise to the second.
     *
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second if
     * {@code millis} contains information that is at least granular to
     * milliseconds.
     * For example, a {@code BigDecimal} of
     * value &lt;tt&gt;1325419950555&lt;/tt&gt;
     * will return a Timestamp of {@code 2012-01-01T12:12:30.555Z},
     * precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     *
     * @deprecated Use {@link #forMillis(BigDecimal, Integer)} instead.
     */
    @Deprecated
    public Timestamp(BigDecimal millis, Integer localOffset)
<span class="fc" id="L810">    {</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">        if (millis == null) throw new NullPointerException(&quot;millis is null&quot;);</span>

        // check bounds to avoid hanging when calling longValue() on decimals with large positive exponents,
        // e.g. 1e10000000
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if(millis.compareTo(MINIMUM_TIMESTAMP_IN_MILLIS_DECIMAL) &lt; 0 ||</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">            MAXIMUM_ALLOWED_TIMESTAMP_IN_MILLIS_DECIMAL.compareTo(millis) &lt; 0) {</span>
<span class="nc" id="L817">            throwTimestampOutOfRangeError(millis);</span>
        }

        // quick handle integral zero
<span class="fc bfc" id="L821" title="All 2 branches covered.">        long ms = isIntegralZero(millis) ? 0 : millis.longValue();</span>

<span class="fc" id="L823">        set_fields_from_millis(ms);</span>

<span class="fc" id="L825">        int scale = millis.scale();</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">        if (scale &lt;= -3) {</span>
<span class="fc" id="L827">            this._precision = Precision.SECOND;</span>
<span class="fc" id="L828">            this._fraction = null;</span>
        }
        else {
<span class="fc" id="L831">            BigDecimal secs = millis.movePointLeft(3);</span>
<span class="fc" id="L832">            BigDecimal secsDown = fastRoundZeroFloor(secs);</span>
<span class="fc" id="L833">            this._fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L834">            this._precision = checkFraction(Precision.SECOND, _fraction);</span>
        }
<span class="fc" id="L836">        this._offset = localOffset;</span>
<span class="fc" id="L837">    }</span>

    private BigDecimal fastRoundZeroFloor(final BigDecimal decimal) {
<span class="fc bfc" id="L840" title="All 2 branches covered.">        BigDecimal fastValue = decimal.signum() &lt; 0 ? BigDecimal.ONE.negate() : BigDecimal.ZERO;</span>

<span class="fc bfc" id="L842" title="All 2 branches covered.">        return isIntegralZero(decimal) ? fastValue : decimal.setScale(0, RoundingMode.FLOOR);</span>
    }

    private boolean isIntegralZero(final BigDecimal decimal) {
        // zero || no low-order bits || &lt; 1.0
<span class="fc bfc" id="L847" title="All 2 branches covered.">        return  decimal.signum() == 0</span>
<span class="pc bpc" id="L848" title="1 of 2 branches missed.">            || decimal.scale() &lt; -63</span>
<span class="fc bfc" id="L849" title="All 2 branches covered.">            || (decimal.precision() - decimal.scale() &lt;= 0);</span>
    }

    private static void throwTimestampOutOfRangeError(Number millis) {
<span class="fc" id="L853">        throw new IllegalArgumentException(&quot;millis: &quot; + millis + &quot; is outside of valid the range: from &quot;</span>
                + MINIMUM_TIMESTAMP_IN_MILLIS
                + &quot; (0001T)&quot;
                + &quot;, inclusive, to &quot;
                + MAXIMUM_TIMESTAMP_IN_MILLIS
                + &quot; (10000T)&quot;
                + &quot; , exclusive&quot;);
    }

    /**
     * Creates a new Timestamp that represents the point in time that is
     * {@code millis} milliseconds from the epoch, with a given local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the fractional second.
     *
     * @param millis
     *          number of milliseconds from the epoch (1970-01-01T00:00:00.000Z)
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset.
     *
     * @deprecated Use {@link #forMillis(long, Integer)} instead.
     */
    @Deprecated
    public Timestamp(long millis, Integer localOffset)
<span class="fc" id="L878">    {</span>
<span class="fc bfc" id="L879" title="All 4 branches covered.">        if(millis &lt; MINIMUM_TIMESTAMP_IN_MILLIS || millis &gt;= MAXIMUM_TIMESTAMP_IN_MILLIS) {</span>
<span class="nc" id="L880">            throwTimestampOutOfRangeError(millis);</span>
        }
<span class="fc" id="L882">        this.set_fields_from_millis(millis);</span>

        // fractional seconds portion
<span class="fc" id="L885">        BigDecimal secs = BigDecimal.valueOf(millis).movePointLeft(3);</span>
<span class="fc" id="L886">        BigDecimal secsDown = secs.setScale(0, RoundingMode.FLOOR);</span>
<span class="fc" id="L887">        this._fraction = secs.subtract(secsDown);</span>
<span class="fc" id="L888">        this._precision = checkFraction(Precision.SECOND, _fraction);</span>

<span class="fc" id="L890">        this._offset = localOffset;</span>
<span class="fc" id="L891">    }</span>


    private static IllegalArgumentException fail(CharSequence input, String reason)
    {
<span class="fc" id="L896">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L897">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + reason</span>
                                            + &quot;: &quot; + input);
    }

    private static IllegalArgumentException fail(CharSequence input)
    {
<span class="fc" id="L903">        input = IonTextUtils.printString(input);</span>
<span class="fc" id="L904">        return new IllegalArgumentException(&quot;invalid timestamp: &quot; + input);</span>
    }

    static final String NULL_TIMESTAMP_IMAGE = &quot;null.timestamp&quot;;
<span class="fc" id="L908">    static final int    LEN_OF_NULL_IMAGE    = NULL_TIMESTAMP_IMAGE.length();</span>
    static final int    END_OF_YEAR          =  4;  // 1234T
    static final int    END_OF_MONTH         =  7;  // 1234-67T
    static final int    END_OF_DAY           = 10;  // 1234-67-90T
    static final int    END_OF_MINUTES       = 16;
    static final int    END_OF_SECONDS       = 19;


    /**
     * Returns a new Timestamp that represents the point in time, precision
     * and local offset defined in Ion format by the {@link CharSequence}.
     *
     * @param ionFormattedTimestamp
     *          a sequence of characters that is the Ion representation of a
     *          Timestamp
     *
     * @throws IllegalArgumentException
     *          if the {@code CharSequence} is an invalid Ion representation
     *          of a Timestamp;
     *          or if the {@code CharSequence} has excess characters which
     *          are not one of the following valid thirteen numeric-stop
     *          characters (escaped accordingly for readability):
     *          &lt;code&gt;{}[](),\&quot;\'\ \t\n\r}&lt;/code&gt;
     *
     * @return
     *          {@code null} if the {@code CharSequence} is &quot;null.timestamp&quot;
     *
     * @see &lt;a href=&quot;http://amzn.github.io/ion-docs/docs/spec.html#timestamp&quot;&gt;Ion Timestamp Page&lt;/a&gt;
     * @see &lt;a href=&quot;http://www.w3.org/TR/NOTE-datetime&quot;&gt;W3C Note on Date and Time Formats&lt;/a&gt;
     */
    public static Timestamp valueOf(CharSequence ionFormattedTimestamp)
    {
<span class="fc" id="L940">        final CharSequence in = ionFormattedTimestamp;</span>
        int pos;

<span class="fc" id="L943">        final int length = in.length();</span>
<span class="pc bpc" id="L944" title="1 of 2 branches missed.">        if (length == 0)</span>
        {
<span class="nc" id="L946">            throw fail(in);</span>
        }

        // check for 'null.timestamp'
<span class="fc bfc" id="L950" title="All 2 branches covered.">        if (in.charAt(0) == 'n') {</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">            if (length &gt;= LEN_OF_NULL_IMAGE</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">                &amp;&amp; NULL_TIMESTAMP_IMAGE.contentEquals(in.subSequence(0, LEN_OF_NULL_IMAGE)))</span>
            {
<span class="fc bfc" id="L954" title="All 2 branches covered.">                if (length &gt; LEN_OF_NULL_IMAGE) {</span>
<span class="pc bpc" id="L955" title="1 of 2 branches missed.">                    if (!isValidFollowChar(in.charAt(LEN_OF_NULL_IMAGE))) {</span>
<span class="fc" id="L956">                        throw fail(in);</span>
                    }
                }
<span class="fc" id="L959">                return null;</span>
            }
<span class="fc" id="L961">            throw fail(in);</span>
        }

<span class="fc" id="L964">        int year  = 1;</span>
<span class="fc" id="L965">        int month = 1;</span>
<span class="fc" id="L966">        int day   = 1;</span>
<span class="fc" id="L967">        int hour  = 0;</span>
<span class="fc" id="L968">        int minute = 0;</span>
<span class="fc" id="L969">        int seconds = 0;</span>
<span class="fc" id="L970">        BigDecimal fraction = null;</span>
        Precision precision;

        // fake label to turn goto's into a break so Java is happy :) enjoy
        do {
            // otherwise we expect yyyy-mm-ddThh:mm:ss.ssss+hh:mm
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">            if (length &lt; END_OF_YEAR + 1) {  // +1 for the &quot;T&quot;</span>
<span class="nc" id="L977">                throw fail(in, &quot;year is too short (must be at least yyyyT)&quot;);</span>
            }
<span class="fc" id="L979">            pos = END_OF_YEAR;</span>
<span class="fc" id="L980">            precision = Precision.YEAR;</span>
<span class="fc" id="L981">            year  = read_digits(in, 0, 4, -1, &quot;year&quot;);</span>

<span class="fc" id="L983">            char c = in.charAt(END_OF_YEAR);</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L985" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L986">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between year and month, found &quot;
<span class="fc" id="L988">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L990" title="All 2 branches covered.">            if (length &lt; END_OF_MONTH + 1) {  // +1 for the &quot;T&quot;</span>
<span class="fc" id="L991">                throw fail(in, &quot;month is too short (must be yyyy-mmT)&quot;);</span>
            }
<span class="fc" id="L993">            pos = END_OF_MONTH;</span>
<span class="fc" id="L994">            precision = Precision.MONTH;</span>
<span class="fc" id="L995">            month = read_digits(in, END_OF_YEAR + 1, 2, -1,  &quot;month&quot;);</span>

<span class="fc" id="L997">            c = in.charAt(END_OF_MONTH);</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">            if (c == 'T') break;</span>
<span class="fc bfc" id="L999" title="All 2 branches covered.">            if (c != '-') {</span>
<span class="fc" id="L1000">                throw fail(in,</span>
                           &quot;expected \&quot;-\&quot; between month and day, found &quot;
<span class="fc" id="L1002">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L1004" title="All 2 branches covered.">            if (length &lt; END_OF_DAY) {</span>
<span class="fc" id="L1005">                throw fail(in, &quot;too short for yyyy-mm-dd&quot;);</span>
            }
<span class="fc" id="L1007">            pos = END_OF_DAY;</span>
<span class="fc" id="L1008">            precision = Precision.DAY;</span>
<span class="fc" id="L1009">            day   = read_digits(in, END_OF_MONTH + 1, 2, -1, &quot;day&quot;);</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            if (length == END_OF_DAY) break;</span>
<span class="fc" id="L1011">            c = in.charAt(END_OF_DAY);</span>
<span class="fc bfc" id="L1012" title="All 2 branches covered.">            if (c != 'T') {</span>
<span class="fc" id="L1013">                throw fail(in,</span>
                           &quot;expected \&quot;T\&quot; after day, found &quot;
<span class="fc" id="L1015">                               + printCodePointAsString(c));</span>
            }
<span class="fc bfc" id="L1017" title="All 2 branches covered.">            if (length == END_OF_DAY + 1) break;</span>

            // now lets see if we have a time value
<span class="fc bfc" id="L1020" title="All 2 branches covered.">            if (length &lt; END_OF_MINUTES) {</span>
<span class="fc" id="L1021">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm&quot;);</span>
            }
<span class="fc" id="L1023">            hour   = read_digits(in, 11, 2, ':', &quot;hour&quot;);</span>
<span class="fc" id="L1024">            minute = read_digits(in, 14, 2, -1, &quot;minutes&quot;);</span>
<span class="fc" id="L1025">            pos = END_OF_MINUTES;</span>
<span class="fc" id="L1026">            precision = Precision.MINUTE;</span>

            // we may have seconds
<span class="fc bfc" id="L1029" title="All 4 branches covered.">            if (length &lt;= END_OF_MINUTES || in.charAt(END_OF_MINUTES) != ':')</span>
            {
<span class="fc" id="L1031">                break;</span>
            }
<span class="fc bfc" id="L1033" title="All 2 branches covered.">            if (length &lt; END_OF_SECONDS) {</span>
<span class="fc" id="L1034">                throw fail(in, &quot;too short for yyyy-mm-ddThh:mm:ss&quot;);</span>
            }
<span class="fc" id="L1036">            seconds = read_digits(in, 17, 2, -1, &quot;seconds&quot;);</span>
<span class="fc" id="L1037">            pos = END_OF_SECONDS;</span>
<span class="fc" id="L1038">            precision = Precision.SECOND;</span>

<span class="fc bfc" id="L1040" title="All 4 branches covered.">            if (length &lt;= END_OF_SECONDS || in.charAt(END_OF_SECONDS) != '.')</span>
            {
<span class="fc" id="L1042">                break;</span>
            }
<span class="fc" id="L1044">            pos = END_OF_SECONDS + 1;</span>
<span class="fc bfc" id="L1045" title="All 4 branches covered.">            while (length &gt; pos &amp;&amp; Character.isDigit(in.charAt(pos))) {</span>
<span class="fc" id="L1046">                pos++;</span>
            }
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            if (pos &lt;= END_OF_SECONDS + 1) {</span>
<span class="fc" id="L1049">                throw fail(in,</span>
                           &quot;must have at least one digit after decimal point&quot;);
            }
<span class="fc" id="L1052">            fraction = new BigDecimal(in.subSequence(19, pos).toString());</span>
        } while (false);

        Integer offset;

        // now see if they included a timezone offset
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        char timezone_start = pos &lt; length ? in.charAt(pos) : '\n';</span>
<span class="fc bfc" id="L1059" title="All 2 branches covered.">        if (timezone_start == 'Z') {</span>
<span class="fc" id="L1060">            offset = 0;</span>
<span class="fc" id="L1061">            pos++;</span>
        }
<span class="fc bfc" id="L1063" title="All 4 branches covered.">        else if (timezone_start == '+' || timezone_start == '-')</span>
        {
<span class="fc bfc" id="L1065" title="All 2 branches covered.">            if (length &lt; pos + 5) {</span>
<span class="fc" id="L1066">                throw fail(in, &quot;local offset too short&quot;);</span>
            }
            // +/- hh:mm
<span class="fc" id="L1069">            pos++;</span>
<span class="fc" id="L1070">            int tzdHours = read_digits(in, pos, 2, ':', &quot;local offset hours&quot;);</span>
<span class="pc bpc" id="L1071" title="1 of 4 branches missed.">            if (tzdHours &lt; 0 || tzdHours &gt; 23) {</span>
<span class="fc" id="L1072">                throw fail(in,</span>
                           &quot;local offset hours must be between 0 and 23 inclusive&quot;);
            }
<span class="fc" id="L1075">            pos += 3;</span>

<span class="fc" id="L1077">            int tzdMinutes = read_digits(in, pos, 2, -1, &quot;local offset minutes&quot;);</span>
<span class="fc bfc" id="L1078" title="All 2 branches covered.">            if (tzdMinutes &gt; 59) {</span>
<span class="fc" id="L1079">                throw fail(in,</span>
                           &quot;local offset minutes must be between 0 and 59 inclusive&quot;);
            }
<span class="fc" id="L1082">            pos += 2;</span>

<span class="fc" id="L1084">            int temp = tzdHours * 60 + tzdMinutes;</span>
<span class="fc bfc" id="L1085" title="All 2 branches covered.">            if (timezone_start == '-') {</span>
<span class="fc" id="L1086">                temp = -temp;</span>
            }
<span class="fc bfc" id="L1088" title="All 4 branches covered.">            if (temp == 0 &amp;&amp; timezone_start == '-') {</span>
                // int doesn't do negative zero very elegantly
<span class="fc" id="L1090">                offset = null;</span>
            }
            else {
<span class="fc" id="L1093">                offset = temp;</span>
            }
<span class="fc" id="L1095">        }</span>
        else {
<span class="fc bfc" id="L1097" title="All 2 branches covered.">            switch (precision) {</span>
                case YEAR:
                case MONTH:
                case DAY:
<span class="fc" id="L1101">                    break;</span>
                default:
<span class="fc" id="L1103">                    throw fail(in, &quot;missing local offset&quot;);</span>
            }
<span class="fc" id="L1105">            offset = null;</span>
        }
<span class="pc bpc" id="L1107" title="1 of 4 branches missed.">        if (length &gt; (pos + 1) &amp;&amp; !isValidFollowChar(in.charAt(pos + 1)))</span>
        {
<span class="fc" id="L1109">            throw fail(in, &quot;invalid excess characters&quot;);</span>
        }

<span class="fc" id="L1112">        Timestamp ts =</span>
            new Timestamp(precision, year, month, day,
                          hour, minute, seconds, fraction, offset, APPLY_OFFSET_YES);
<span class="fc" id="L1115">        return ts;</span>
    }

    private static int read_digits(CharSequence in, int start, int length,
                                   int terminator, String field)
    {
<span class="fc" id="L1121">        int ii, value = 0;</span>
<span class="fc" id="L1122">        int end = start + length;</span>

<span class="fc bfc" id="L1124" title="All 2 branches covered.">        if (in.length() &lt; end) {</span>
<span class="fc" id="L1125">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits&quot;);
        }

<span class="fc bfc" id="L1129" title="All 2 branches covered.">        for (ii=start; ii&lt;end; ii++) {</span>
<span class="fc" id="L1130">            char c = in.charAt(ii);</span>
<span class="fc bfc" id="L1131" title="All 2 branches covered.">            if (!Character.isDigit(c)) {</span>
                // FIXME this will give incorrect message if c is a surrogate
<span class="fc" id="L1133">                throw fail(in,</span>
                           field + &quot; has non-digit character &quot;
<span class="fc" id="L1135">                               + printCodePointAsString(c));</span>
            }
<span class="fc" id="L1137">            value *= 10;</span>
<span class="fc" id="L1138">            value += c - '0';</span>
        }

        // Check the terminator if requested.
<span class="fc bfc" id="L1142" title="All 2 branches covered.">        if (terminator != -1) {</span>
<span class="pc bpc" id="L1143" title="1 of 4 branches missed.">            if (ii &gt;= in.length() || in.charAt(ii) != terminator) {</span>
<span class="fc" id="L1144">                throw fail(in,</span>
                           field + &quot; should end with &quot;
<span class="fc" id="L1146">                               + printCodePointAsString(terminator));</span>
            }
        }
        // Otherwise make sure we don't have too many digits.
<span class="fc bfc" id="L1150" title="All 4 branches covered.">        else if (ii &lt; in.length() &amp;&amp; Character.isDigit(in.charAt(ii))) {</span>
<span class="fc" id="L1151">            throw fail(in,</span>
                       field + &quot; requires &quot; + length + &quot; digits but has more&quot;);
        }

<span class="fc" id="L1155">        return value;</span>
    }

    private static boolean isValidFollowChar(char c) {
<span class="pc bpc" id="L1159" title="1 of 2 branches missed.">        switch (c) {</span>
        default:
<span class="fc" id="L1161">            return false;</span>
        case '{':
        case '}':
        case '[':
        case ']':
        case '(':
        case ')':
        case ',':
        case '\&quot;':
        case '\'':
        case '\\':
        case '\t':
        case '\n':
        case '\r':
<span class="nc" id="L1175">            return true;</span>
        }
    }

    /**
     * Creates a copy of this Timestamp. The resulting Timestamp will
     * represent the same point in time and has the same precision and local
     * offset.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public Timestamp clone()
    {
        // The Copy-Constructor we're using here already expects the time field
        // values to be in UTC, and that is already what we have for this
        // Timestamp -- no adjustment necessary to make it local time.
<span class="fc" id="L1192">        return new Timestamp(_precision,</span>
                             _year,
                             _month,
                             _day,
                             _hour,
                             _minute,
                             _second,
                             _fraction,
                             _offset,
                             APPLY_OFFSET_NO);
    }

    /**
     * Applies the local offset from UTC to each of the applicable time field
     * values and returns the new Timestamp. In short, this makes the Timestamp
     * represent local time.
     *
     * @return a new Timestamp in its local time
     */
    private Timestamp make_localtime()
    {
<span class="fc bfc" id="L1213" title="All 2 branches covered.">        int offset = _offset != null</span>
<span class="fc" id="L1214">            ? _offset.intValue()</span>
<span class="fc" id="L1215">            : 0;</span>

        // We use a Copy-Constructor that expects the time parameters to be in
        // UTC, as that's what we're supposed to have.
        // As this Copy-Constructor doesn't apply local offset to the time
        // field values (it assumes that the local offset is already applied to
        // them), we explicitly apply the local offset to the time field values
        // after we obtain the new Timestamp instance.
<span class="fc" id="L1223">        Timestamp localtime = new Timestamp(_precision,</span>
                                            _year,
                                            _month,
                                            _day,
                                            _hour,
                                            _minute,
                                            _second,
                                            _fraction,
                                            _offset,
                                            APPLY_OFFSET_NO);
        // explicitly apply the local offset to the time field values
<span class="fc" id="L1234">        localtime.apply_offset(-offset);</span>

<span class="pc bpc" id="L1236" title="2 of 4 branches missed.">        assert localtime._offset == _offset;</span>

<span class="fc" id="L1238">        return localtime;</span>
    }

    /**
     * Returns a Timestamp, precise to the year, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYYT}.
     */
    public static Timestamp forYear(int yearZ)
    {
<span class="fc" id="L1248">        return new Timestamp(yearZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the month, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MMT}.
     */
    public static Timestamp forMonth(int yearZ, int monthZ)
    {
<span class="fc" id="L1258">        return new Timestamp(yearZ, monthZ);</span>
    }

    /**
     * Returns a Timestamp, precise to the day, with unknown local offset.
     * &lt;p&gt;
     * This is equivalent to the corresponding Ion value {@code YYYY-MM-DD}.
     *
     */
    public static Timestamp forDay(int yearZ, int monthZ, int dayZ)
    {
<span class="fc" id="L1269">        return new Timestamp(yearZ, monthZ, dayZ);</span>
    }


    /**
     * Returns a Timestamp, precise to the minute, with a given local
     * offset.
     *
     * &lt;p&gt;This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.&lt;/p&gt;
     *
     * &lt;p&gt;The values of the {@code year}, {@code month}, {@code day},
     * {@code hour}, and {@code minute} parameters are relative to the
     * local {@code offset}.&lt;/p&gt;
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forMinute(int year, int month, int day,
                                      int hour, int minute,
                                      Integer offset)
    {
<span class="nc" id="L1294">        return new Timestamp(year, month, day, hour, minute, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     *
     * &lt;p&gt;This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss+-oo:oo}, where {@code oo:oo} represents the
     * hour and minutes of the local offset from UTC.&lt;/p&gt;
     *
     * &lt;p&gt;The values of the {@code year}, {@code month}, {@code day},
     * {@code hour}, {@code minute} and {@code second} parameters are relative
     * to the local {@code offset}.&lt;/p&gt;
     *
     * @param offset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *

     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, int second,
                                      Integer offset)
    {
<span class="fc" id="L1319">        return new Timestamp(year, month, day, hour, minute, second, offset);</span>
    }


    /**
     * Returns a Timestamp, precise to the second, with a given local offset.
     *
     * &lt;p&gt;This is equivalent to the corresponding Ion value
     * {@code YYYY-MM-DDThh:mm:ss.sss+-oo:oo}, where {@code oo:oo} represents
     * the hour and minutes of the local offset from UTC.&lt;/p&gt;
     *
     * &lt;p&gt;The values of the {@code year}, {@code month}, {@code day},
     * {@code hour}, {@code minute} and {@code second} parameters are relative
     * to the local {@code offset}.&lt;/p&gt;
     *
     * @param second must be at least zero and less than 60. Must not be null.
     * @param offset the local offset from UTC, measured in minutes;
     *              may be {@code null} to represent an unknown local offset
     *
     */
    public static Timestamp forSecond(int year, int month, int day,
                                      int hour, int minute, BigDecimal second,
                                      Integer offset)
    {
        // Tease apart the whole and fractional seconds.
        // Storing them separately is silly.
<span class="fc" id="L1345">        int s = second.intValue();</span>
<span class="fc" id="L1346">        BigDecimal frac = second.subtract(BigDecimal.valueOf(s));</span>
<span class="fc" id="L1347">        return new Timestamp(Precision.SECOND, year, month, day, hour, minute, s, frac, offset, APPLY_OFFSET_YES);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is {@code millis} milliseconds from the epoch,
     * with a given local offset.
     *
     * &lt;p&gt;The resulting Timestamp will be precise to the millisecond.&lt;/p&gt;
     *
     * &lt;p&gt;{@code millis} is relative to UTC, regardless of the value supplied for {@code localOffset}.  This
     * varies from the {@link #forMinute} and {@link #forSecond} methods that assume the specified date and time
     * values are relative to the local offset.  For example, the following two Timestamps represent
     * the same point in time:&lt;/p&gt;
     *
     * &lt;code&gt;
     * Timestamp theEpoch = Timestamp.forMillis(0, 0);
     * Timestamp alsoTheEpoch = Timestamp.forSecond(1969, 12, 31, 23, 0, BigDecimal.ZERO, -60);
     * &lt;/code&gt;
     *
     * @param millis the number of milliseconds from the epoch (1970-01-01T00:00:00.000Z) in UTC.
     * @param localOffset the local offset from UTC, measured in minutes;
     *                    may be {@code null} to represent an unknown local offset.
     */
    public static Timestamp forMillis(long millis, Integer localOffset)
    {
<span class="fc" id="L1373">        return new Timestamp(millis, localOffset);</span>
    }

    /**
     * The same as {@link #forMillis(long, Integer)} but the millisecond component is specified using a
     * {@link BigDecimal} and therefore may include fractional milliseconds.
     *
     * @param millis
     *          number of milliseconds (including any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z);
     *          must not be {@code null}
     * @param localOffset
     *          the local offset from UTC, measured in minutes;
     *          may be {@code null} to represent an unknown local offset
     *
     * @throws NullPointerException if {@code millis} is {@code null}
     *
     */
    public static Timestamp forMillis(BigDecimal millis, Integer localOffset)
    {
<span class="fc" id="L1393">        return new Timestamp(millis, localOffset);</span>
    }


    /**
     * Returns a Timestamp that represents the point in time that is {@code seconds} from the unix epoch
     * (1970-01-01T00:00:00.000Z), with the {@code nanoOffset} applied and a given local offset.
     *
     * &lt;p&gt;This function is intended to allow easy conversion to Timestamp from Java 8's {@code java.time.Instant}
     * without having to port this library to Java 8.  The following snippet will yield a Timestamp {@code ts}
     * that equivalent to the {@code java.time.Instant} {@code i}:&lt;/p&gt;
     *
     * &lt;code&gt;
     *     Instant i = Instant.now();
     *     Timestamp ts = Timestamp.forEpochSecond(i.getEpochSecond(), i.getNano(), 0);
     * &lt;/code&gt;
     *
     * &lt;p&gt;Like {@link #forMillis}, {@code seconds} is relative to UTC, regardless of the value
     * supplied for {@code localOffset}.&lt;/p&gt;
     *
     * @param seconds The number of seconds from the unix epoch (1970-01-01T00:00:00.000Z) UTC.
     * @param nanoOffset The number of nanoseconds for the fractional component. Must be between 0 and 999,999,999.
     * @param localOffset the local offset from UTC, measured in minutes;
     *                    may be {@code null} to represent an unknown local offset.
     */
    public static Timestamp forEpochSecond(long seconds, int nanoOffset, Integer localOffset) {
        // We do not validate seconds here because that is done within the forMillis static constructor.
<span class="fc" id="L1420">        long millis = seconds * 1000L;</span>
<span class="fc" id="L1421">        Timestamp ts = forMillis(millis, localOffset);</span>
<span class="fc bfc" id="L1422" title="All 2 branches covered.">        if(nanoOffset != 0) {</span>
<span class="fc bfc" id="L1423" title="All 4 branches covered.">            if(nanoOffset &lt; 0 || nanoOffset &gt; 999999999) {</span>
<span class="fc" id="L1424">                throw new IllegalArgumentException(&quot;nanoOffset must be between 0 and 999,999,999&quot;);</span>
            }
<span class="fc" id="L1426">            ts._fraction = ts._fraction.add(BigDecimal.valueOf(nanoOffset).movePointLeft(9));</span>
        }
<span class="fc" id="L1428">        return ts;</span>
    }


    /**
     * Converts a {@link Calendar} to a Timestamp, preserving the calendar's
     * time zone as the equivalent local offset when it has at least minutes
     * precision.
     *
     * @return a Timestamp instance, with precision determined by the smallest
     *   field set in the {@code Calendar};
     *   or {@code null} if {@code calendar} is {@code null}
     *

     */
    public static Timestamp forCalendar(Calendar calendar)
    {
<span class="pc bpc" id="L1445" title="1 of 2 branches missed.">        if (calendar == null) return null;</span>
<span class="fc" id="L1446">        return new Timestamp(calendar);</span>
    }


    /**
     * Converts a {@link Date} to a Timestamp in UTC representing the same
     * point in time.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the millisecond;
     *          {@code null} if {@code date} is {@code null}
     *

     */
    public static Timestamp forDateZ(Date date)
    {
<span class="fc bfc" id="L1464" title="All 2 branches covered.">        if (date == null) return null;</span>
<span class="fc" id="L1465">        long millis = date.getTime();</span>
<span class="fc" id="L1466">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts a {@link java.sql.Timestamp} to a Timestamp in UTC representing
     * the same point in time.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the nanosecond.
     *
     * @param sqlTimestamp assumed to have nanoseconds precision
     *
     * @return
     *          a new Timestamp instance, in UTC, precise to the
     *          nanosecond
     *          {@code null} if {@code sqlTimestamp} is {@code null}
     *

     */
    public static Timestamp forSqlTimestampZ(java.sql.Timestamp sqlTimestamp)
    {
<span class="fc bfc" id="L1487" title="All 2 branches covered.">        if (sqlTimestamp == null) return null;</span>

<span class="fc" id="L1489">        long millis = sqlTimestamp.getTime();</span>
<span class="fc" id="L1490">        Timestamp ts = new Timestamp(millis, UTC_OFFSET);</span>
<span class="fc" id="L1491">        int nanos = sqlTimestamp.getNanos();</span>
<span class="fc" id="L1492">        BigDecimal frac = BigDecimal.valueOf(nanos).movePointLeft(9);</span>
<span class="fc" id="L1493">        ts._fraction = frac;</span>
<span class="fc" id="L1494">        return ts;</span>
    }


    /**
     * Returns a Timestamp representing the current time (based on the JVM
     * clock), with an unknown local offset.
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance representing the current time.
     */
    public static Timestamp now()
    {
<span class="nc" id="L1509">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1510">        return new Timestamp(millis, UNKNOWN_OFFSET);</span>
    }

    /**
     * Returns a Timestamp in UTC representing the current time (based on the
     * the JVM clock).
     * &lt;p&gt;
     * The resulting Timestamp will be precise to the millisecond.
     *
     * @return
     *          a new Timestamp instance, in UTC, representing the current
     *          time.
     *

     */
    public static Timestamp nowZ()
    {
<span class="nc" id="L1527">        long millis = System.currentTimeMillis();</span>
<span class="nc" id="L1528">        return new Timestamp(millis, UTC_OFFSET);</span>
    }


    /**
     * Converts the value of this Timestamp into a {@link Date},
     * representing the time in UTC.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     * &lt;p&gt;
     * Because {@link Date} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Date} instance, in UTC
     */
    public Date dateValue()
    {
<span class="fc" id="L1546">        long millis = getMillis();</span>
<span class="fc" id="L1547">        return new Date(millis);</span>
    }


    /**
     * Converts the value of this Timestamp as a {@link Calendar}, in its
     * local time.
     * &lt;p&gt;
     * Because {@link Calendar} instances are mutable, this method returns a
     * new instance from each call.
     *
     * @return a new {@code Calendar} instance, in its local time.
     *

     */
    public Calendar calendarValue()
    {
<span class="fc" id="L1564">        Calendar cal = new GregorianCalendar(_Private_Utils.UTC);</span>

<span class="fc" id="L1566">        long millis = getMillis();</span>
<span class="fc" id="L1567">        Integer offset = _offset;</span>
<span class="fc bfc" id="L1568" title="All 4 branches covered.">        if (offset != null &amp;&amp; offset != 0)</span>
        {
<span class="fc" id="L1570">            int offsetMillis = offset * 60 * 1000;</span>
<span class="fc" id="L1571">            millis += offsetMillis;</span>
<span class="fc" id="L1572">            cal.setTimeInMillis(millis);                // Resets the offset!</span>
<span class="fc" id="L1573">            cal.set(Calendar.ZONE_OFFSET, offsetMillis);</span>
<span class="fc" id="L1574">        }</span>
        else
        {
<span class="fc" id="L1577">            cal.setTimeInMillis(millis);</span>
        }

<span class="pc bpc" id="L1580" title="1 of 6 branches missed.">        switch (_precision) {</span>
            case YEAR:
<span class="fc" id="L1582">                cal.clear(Calendar.MONTH);</span>
            case MONTH:
<span class="fc" id="L1584">                cal.clear(Calendar.DAY_OF_MONTH);</span>
            case DAY:
<span class="fc" id="L1586">                cal.clear(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L1587">                cal.clear(Calendar.MINUTE);</span>
            case MINUTE:
<span class="fc" id="L1589">                cal.clear(Calendar.SECOND);</span>
<span class="fc" id="L1590">                cal.clear(Calendar.MILLISECOND);</span>
            case SECOND:
<span class="fc bfc" id="L1592" title="All 2 branches covered.">                if (_fraction == null) {</span>
<span class="fc" id="L1593">                    cal.clear(Calendar.MILLISECOND);</span>
                }
        }

<span class="fc" id="L1597">        return cal;</span>
    }


    /**
     * Returns a number representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional milliseconds)
     * from the epoch.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;ignoring&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public long getMillis()
    {
        //                                        month is 0 based for Date
<span class="fc" id="L1617">        long millis = Date.UTC(this._year - 1900, this._month - 1, this._day, this._hour, this._minute, this._second);</span>
<span class="fc bfc" id="L1618" title="All 2 branches covered.">        if (this._fraction != null) {</span>
<span class="fc" id="L1619">            BigDecimal fracAsDecimal = this._fraction.movePointRight(3);</span>
<span class="fc bfc" id="L1620" title="All 2 branches covered.">            int frac = isIntegralZero(fracAsDecimal) ? 0 : fracAsDecimal.intValue();</span>
<span class="fc" id="L1621">            millis += frac;</span>
        }
<span class="fc" id="L1623">        return millis;</span>

    }

    /**
     * Returns a BigDecimal representing the Timestamp's point in time that is
     * the number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional milliseconds)
     * from the epoch.
     * &lt;p&gt;
     * This method will return the same result for all Timestamps representing
     * the same point in time, regardless of the local offset.
     *
     * @return
     *          number of milliseconds (&lt;em&gt;including&lt;/em&gt; any fractional
     *          milliseconds) from the epoch (1970-01-01T00:00:00.000Z)
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public BigDecimal getDecimalMillis()
    {
<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">        switch (this._precision) {</span>
        case YEAR:
        case MONTH:
        case DAY:
        case MINUTE:
        case SECOND:
        case FRACTION:
<span class="fc" id="L1649">            long millis = Date.UTC(this._year - 1900, this._month - 1, this._day, this._hour, this._minute, this._second);</span>
<span class="fc" id="L1650">            BigDecimal dec = BigDecimal.valueOf(millis);</span>
<span class="fc bfc" id="L1651" title="All 2 branches covered.">            if (_fraction != null) {</span>
<span class="fc" id="L1652">                dec = dec.add(this._fraction.movePointRight(3));</span>
            }
<span class="fc" id="L1654">            return dec;</span>
        }
<span class="nc" id="L1656">        throw new IllegalArgumentException();</span>
    }


    /**
     * Returns the precision of this Timestamp.
     */
    public Precision getPrecision()
    {
<span class="fc" id="L1665">        return this._precision;</span>
    }

    /**
     * Returns the offset of this Timestamp, measured in minutes, for the local
     * timezone in UTC.
     * &lt;p&gt;
     * For example, calling this method on Timestamps of:
     * &lt;ul&gt;
     *     &lt;li&gt;{@code 1969-02-23T07:00+07:00} will return {@code 420}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-22T22:45:00.00-01:15} will return {@code -75}&lt;/li&gt;
     *     &lt;li&gt;{@code 1969-02-23} (by Ion's definition, equivalent to
     *     {@code 1969-02-23T00:00-00:00}) will return {@code null}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @return
     *          {@code null} if the local offset is unknown
     *          (i.e. {@code -00:00})
     */
    public Integer getLocalOffset()
    {
<span class="fc" id="L1686">        return _offset;</span>
    }


    /**
     * Returns the year of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 9999], in its local time
     */
    public int getYear()
    {
<span class="fc" id="L1698">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1700" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1702">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1705">        return adjusted._year;</span>
    }


    /**
     * Returns the month of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in its local time;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getMonth()
    {
<span class="fc" id="L1720">        Timestamp adjusted = this;</span>

<span class="fc bfc" id="L1722" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1723" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1724">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1727">        return adjusted._month;</span>
    }


    /**
     * Returns the day (within the month) of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [1, 31], in its local time;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getDay()
    {
<span class="fc" id="L1741">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1742" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1743" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1744">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1747">        return adjusted._day;</span>
    }


    /**
     * Returns the hour of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 23], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getHour()
    {
<span class="fc" id="L1761">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1762" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1763" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1764">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1767">        return adjusted._hour;</span>
    }


    /**
     * Returns the minute of this Timestamp, in its local time.
     *
     * @return
     *          a number within the range [0, 59], in its local time;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getMinute()
    {
<span class="fc" id="L1781">        Timestamp adjusted = this;</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L1783" title="All 2 branches covered.">            if (this._offset.intValue() != 0) {</span>
<span class="fc" id="L1784">                adjusted = make_localtime();</span>
            }
        }
<span class="fc" id="L1787">        return adjusted._minute;</span>
    }


    /**
     * Returns the seconds of this Timestamp, truncated to an integer.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getZSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZSecond()
     */
    public int getSecond()
    {
<span class="fc" id="L1805">        return this._second;</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getZDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getZDecimalSecond()
     */
    public BigDecimal getDecimalSecond()
    {
<span class="fc" id="L1824">        BigDecimal sec = BigDecimal.valueOf(_second);</span>
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">        if (_fraction != null)</span>
        {
<span class="fc" id="L1827">            sec = sec.add(_fraction);</span>
        }
<span class="fc" id="L1829">        return sec;</span>
    }


    /**
     * Returns the fractional second of this Timestamp.
     * &lt;p&gt;
     * Fractional seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getZFractionalSecond()}.
     *
     * @return
     *          a BigDecimal within the range [0, 1);
     *          {@code null} is returned if the Timestamp isn't
     *          precise to the fractional second
     *
     * @see #getZFractionalSecond()
     *
     * Use {@link #getDecimalSecond()} instead.
     */
    @Deprecated
    public BigDecimal getFractionalSecond()
    {
<span class="fc" id="L1852">        return this._fraction;</span>
    }


    /**
     * Returns the year of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 9999], in UTC
     */
    public int getZYear()
    {
<span class="fc" id="L1864">        return this._year;</span>
    }


    /**
     * Returns the month of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 12], whereby 1 refers to January
     *          and 12 refers to December, in UTC;
     *          1 is returned if the Timestamp isn't precise to
     *          the month
     */
    public int getZMonth()
    {
<span class="fc" id="L1879">        return this._month;</span>
    }


    /**
     * Returns the day of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [1, 31], in UTC;
     *          1 is returned if the Timestamp isn't
     *          precise to the day
     */
    public int getZDay()
    {
<span class="fc" id="L1893">        return this._day;</span>
    }


    /**
     * Returns the hour of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 23], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the hour
     */
    public int getZHour()
    {
<span class="fc" id="L1907">        return this._hour;</span>
    }


    /**
     * Returns the minute of this Timestamp, in UTC.
     *
     * @return
     *          a number within the range [0, 59], in UTC;
     *          0 is returned if the Timestamp isn't
     *          precise to the minute
     */
    public int getZMinute()
    {
<span class="fc" id="L1921">        return this._minute;</span>
    }


    /**
     * Returns the second of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as {@link #getSecond()}.
     *
     * @return
     *          a number within the range [0, 59];
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getSecond()
     */
    public int getZSecond()
    {
<span class="fc" id="L1939">        return this._second;</span>
    }


    /**
     * Returns the seconds of this Timestamp.
     * &lt;p&gt;
     * Seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getDecimalSecond()}.
     *
     * @return
     *          a number within the range [0, 60);
     *          0 is returned if the Timestamp isn't precise to the second
     *
     * @see #getDecimalSecond()
     */
    public BigDecimal getZDecimalSecond()
    {
<span class="nc" id="L1958">        return getDecimalSecond();</span>
    }


    /**
     * Returns the fractional second of this Timestamp.
     * &lt;p&gt;
     * Fractional seconds are not affected by local offsets.
     * As such, this method produces the same output as
     * {@link #getFractionalSecond()}.
     *
     * @return
     *          a BigDecimal within the range [0, 1);
     *          {@code null} is returned if the Timestamp isn't
     *          precise to the fractional second
     *
     * @see #getFractionalSecond()
     *
     * @deprecated Use {@link #getZDecimalSecond()} instead.
     */
    @Deprecated
    public BigDecimal getZFractionalSecond()
    {
<span class="fc" id="L1981">        return this._fraction;</span>
    }


    //=========================================================================
    // Modification methods


    /**
     * Returns a timestamp at the same point in time, but with the given local
     * offset.  If this timestamp has precision coarser than minutes, then it
     * is returned unchanged since such timestamps always have an unknown
     * offset.
     */
    public Timestamp withLocalOffset(Integer offset)
    {
<span class="fc" id="L1997">        Precision precision = getPrecision();</span>
<span class="fc bfc" id="L1998" title="All 2 branches covered.">        if (precision.alwaysUnknownOffset() ||</span>
<span class="fc bfc" id="L1999" title="All 2 branches covered.">            safeEquals(offset, getLocalOffset()))</span>
        {
<span class="fc" id="L2001">            return this;</span>
        }

<span class="fc" id="L2004">        Timestamp ts = createFromUtcFields(precision,</span>
<span class="fc" id="L2005">                                           getZYear(),</span>
<span class="fc" id="L2006">                                           getZMonth(),</span>
<span class="fc" id="L2007">                                           getZDay(),</span>
<span class="fc" id="L2008">                                           getZHour(),</span>
<span class="fc" id="L2009">                                           getZMinute(),</span>
<span class="fc" id="L2010">                                           getZSecond(),</span>
<span class="fc" id="L2011">                                           getZFractionalSecond(),</span>
                                           offset);
<span class="fc" id="L2013">        return ts;</span>
    }


    //=========================================================================


    /**
     * Returns the string representation (in Ion format) of this Timestamp in
     * its local time.
     *
     * @see #toZString()
     * @see #print(Appendable)
     */
    @Override
    public String toString()
    {
<span class="fc" id="L2030">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L2033">            print(buffer);</span>
        }
<span class="nc" id="L2035">        catch (IOException e)</span>
        {
<span class="nc" id="L2037">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                                       e);
<span class="fc" id="L2039">        }</span>
<span class="fc" id="L2040">        return buffer.toString();</span>
    }


    /**
     * Returns the string representation (in Ion format) of this Timestamp
     * in UTC.
     *
     * @see #toString()
     * @see #printZ(Appendable)
     */
    public String toZString()
    {
<span class="fc" id="L2053">        StringBuilder buffer = new StringBuilder(32);</span>
        try
        {
<span class="fc" id="L2056">            printZ(buffer);</span>
        }
<span class="nc" id="L2058">        catch (IOException e)</span>
        {
<span class="nc" id="L2060">            throw new RuntimeException(&quot;Exception printing to StringBuilder&quot;,</span>
                                       e);
<span class="fc" id="L2062">        }</span>
<span class="fc" id="L2063">        return buffer.toString();</span>
    }


    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in its local time.
     * &lt;p&gt;
     * This method produces the same output as {@link #toString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@link Appendable} throws it
     *
     * @see #printZ(Appendable)
     */
    public void print(Appendable out)
        throws IOException
    {
        // we have to make a copy to preserve the &quot;immutable&quot; contract
        // on Timestamp and we don't want someone reading the calendar
        // member while we've shifted it around.
<span class="fc" id="L2085">        Timestamp adjusted = this;</span>

        // Adjust UTC time back to local time
<span class="fc bfc" id="L2088" title="All 4 branches covered.">        if (this._offset != null &amp;&amp; this._offset.intValue() != 0) {</span>
<span class="fc" id="L2089">            adjusted = make_localtime();</span>
        }

<span class="fc" id="L2092">        print(out, adjusted);</span>
<span class="fc" id="L2093">    }</span>


    /**
     * Prints to an {@code Appendable} the string representation (in Ion format)
     * of this Timestamp in UTC.
     * &lt;p&gt;
     * This method produces the same output as {@link #toZString()}.
     *
     * @param out not {@code null}
     *
     * @throws IOException propagated when the {@code Appendable} throws it.
     *
     * @see #print(Appendable)
     */
    public void printZ(Appendable out)
        throws IOException
    {
<span class="pc bpc" id="L2111" title="1 of 3 branches missed.">        switch (_precision)</span>
        {
            case YEAR:
            case MONTH:
            case DAY:
            {
<span class="pc bpc" id="L2117" title="2 of 4 branches missed.">                assert _offset == UNKNOWN_OFFSET;</span>
                // No need to adjust offset, we won't be using it.
<span class="fc" id="L2119">                print(out);</span>
<span class="fc" id="L2120">                break;</span>
            }
            case MINUTE:
            case SECOND:
            case FRACTION:
            {
<span class="fc" id="L2126">                Timestamp ztime = this.clone();</span>
<span class="fc" id="L2127">                ztime._offset = UTC_OFFSET;</span>
<span class="fc" id="L2128">                ztime.print(out);</span>
<span class="fc" id="L2129">                break;</span>
            }
        }
<span class="fc" id="L2132">    }</span>


    /**
     * helper for print(out) and printZ(out) so that printZ can create
     * a zulu time and pass it directly and print can apply the local
     * offset and adjust the various fields (without breaking the
     * contract to be immutable).
     * @param out destination for the text image of the value
     * @param adjusted the time value with the fields adjusted to match the desired text output
     * @throws IOException
     */
    private static void print(Appendable out, Timestamp adjusted)
        throws IOException
    {
        // null is our first &quot;guess&quot; to get it out of the way
<span class="pc bpc" id="L2148" title="1 of 2 branches missed.">        if (adjusted == null) {</span>
<span class="nc" id="L2149">            out.append(&quot;null.timestamp&quot;);</span>
<span class="nc" id="L2150">            return;</span>
        }

        // so we have a real value - we'll start with the date portion
        // which we always have
<span class="fc" id="L2155">        print_digits(out, adjusted._year, 4);</span>
<span class="fc bfc" id="L2156" title="All 2 branches covered.">        if (adjusted._precision == Precision.YEAR) {</span>
<span class="pc bpc" id="L2157" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L2158">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L2159">            return;</span>
        }

<span class="fc" id="L2162">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L2163">        print_digits(out, adjusted._month, 2);  // convert calendar months to a base 1 value</span>
<span class="fc bfc" id="L2164" title="All 2 branches covered.">        if (adjusted._precision == Precision.MONTH) {</span>
<span class="pc bpc" id="L2165" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
<span class="fc" id="L2166">            out.append(&quot;T&quot;);</span>
<span class="fc" id="L2167">            return;</span>
        }

<span class="fc" id="L2170">        out.append(&quot;-&quot;);</span>
<span class="fc" id="L2171">        print_digits(out, adjusted._day, 2);</span>
<span class="fc bfc" id="L2172" title="All 2 branches covered.">        if (adjusted._precision == Precision.DAY) {</span>
<span class="pc bpc" id="L2173" title="2 of 4 branches missed.">            assert adjusted._offset == UNKNOWN_OFFSET;</span>
            // out.append(&quot;T&quot;);
<span class="fc" id="L2175">            return;</span>
        }

<span class="fc" id="L2178">        out.append(&quot;T&quot;);</span>
<span class="fc" id="L2179">        print_digits(out, adjusted._hour, 2);</span>
<span class="fc" id="L2180">        out.append(&quot;:&quot;);</span>
<span class="fc" id="L2181">        print_digits(out, adjusted._minute, 2);</span>
        // ok, so how much time do we have ?
<span class="fc bfc" id="L2183" title="All 2 branches covered.">        if (adjusted._precision == Precision.SECOND) {</span>
<span class="fc" id="L2184">            out.append(&quot;:&quot;);</span>
<span class="fc" id="L2185">            print_digits(out, adjusted._second, 2);</span>
<span class="fc bfc" id="L2186" title="All 2 branches covered.">            if (adjusted._fraction != null) {</span>
<span class="fc" id="L2187">                print_fractional_digits(out, adjusted._fraction);</span>
            }
        }

<span class="fc bfc" id="L2191" title="All 2 branches covered.">        if (adjusted._offset != UNKNOWN_OFFSET) {</span>
            int min, hour;
<span class="fc" id="L2193">            min = adjusted._offset;</span>
<span class="fc bfc" id="L2194" title="All 2 branches covered.">            if (min == 0) {</span>
<span class="fc" id="L2195">                out.append('Z');</span>
            }
            else {
<span class="fc bfc" id="L2198" title="All 2 branches covered.">                if (min &lt; 0) {</span>
<span class="fc" id="L2199">                    min = -min;</span>
<span class="fc" id="L2200">                    out.append('-');</span>
                }
                else {
<span class="fc" id="L2203">                    out.append('+');</span>
                }
<span class="fc" id="L2205">                hour = min / 60;</span>
<span class="fc" id="L2206">                min = min - hour*60;</span>
<span class="fc" id="L2207">                print_digits(out, hour, 2);</span>
<span class="fc" id="L2208">                out.append(&quot;:&quot;);</span>
<span class="fc" id="L2209">                print_digits(out, min, 2);</span>
            }
<span class="fc" id="L2211">        }</span>
        else {
<span class="fc" id="L2213">            out.append(&quot;-00:00&quot;);</span>
        }
<span class="fc" id="L2215">    }</span>
    private static void print_digits(Appendable out, int value, int length)
        throws IOException
    {
<span class="fc" id="L2219">        char temp[] = new char[length];</span>
<span class="fc bfc" id="L2220" title="All 2 branches covered.">        while (length &gt; 0) {</span>
<span class="fc" id="L2221">            length--;</span>
<span class="fc" id="L2222">            int next = value / 10;</span>
<span class="fc" id="L2223">            temp[length] =  (char)('0' + (value - next*10));</span>
<span class="fc" id="L2224">            value = next;</span>
<span class="fc" id="L2225">        }</span>
<span class="pc bpc" id="L2226" title="1 of 2 branches missed.">        while (length &gt; 0) {</span>
<span class="nc" id="L2227">            length--;</span>
<span class="nc" id="L2228">            temp[length] =  '0';</span>
        }
<span class="fc bfc" id="L2230" title="All 2 branches covered.">        for (char c : temp) {</span>
<span class="fc" id="L2231">            out.append(c);</span>
        }
<span class="fc" id="L2233">    }</span>
    private static void print_fractional_digits(Appendable out, BigDecimal value)
        throws IOException
    {
<span class="fc" id="L2237">        String temp = value.toPlainString(); // crude, but it works</span>
<span class="pc bpc" id="L2238" title="1 of 2 branches missed.">        if (temp.charAt(0) == '0') { // this should always be true</span>
<span class="fc" id="L2239">            temp = temp.substring(1);</span>
        }
<span class="fc" id="L2241">        out.append(temp);</span>
<span class="fc" id="L2242">    }</span>


    //=========================================================================
    // Timestamp arithmetic


    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. After performing the arithmetic, the resulting Timestamp's
     * seconds value will be truncated to the same fractional precision as the
     * original. For example, adjusting {@code 2012-04-01T00:00:00Z} by one
     * millisecond results in {@code 2012-04-01T00:00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00.0010Z} by -1 millisecond results in
     * {@code 2012-04-01T00:00:00.0000Z}. To extend the precision when the
     * original Timestamp has coarser than SECOND precision and to avoid
     * truncation of the seconds value, use {@link #addSecond(int)}.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp adjustMillis(long amount) {
<span class="fc bfc" id="L2266" title="All 2 branches covered.">        if (amount == 0) return this;</span>
<span class="fc" id="L2267">        Timestamp ts = addMillisForPrecision(amount, _precision, false);</span>
        //ts._precision = _precision;
<span class="fc" id="L2269">        ts.clearUnusedPrecision();</span>
<span class="fc bfc" id="L2270" title="All 2 branches covered.">        if (ts._precision.includes(Precision.SECOND)) {</span>
            // Maintain the same amount of fractional precision.
<span class="fc bfc" id="L2272" title="All 2 branches covered.">            if (_fraction == null) {</span>
<span class="fc" id="L2273">                ts._fraction = null;</span>
            } else {
                // Truncate the result only if it exceeds the fractional precision of the original.
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">                if (ts._fraction.scale() &gt; _fraction.scale()) {</span>
<span class="nc" id="L2277">                    ts._fraction = ts._fraction.setScale(_fraction.scale(), RoundingMode.FLOOR);</span>
                }
            }
        }
<span class="fc" id="L2281">        return ts;</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of
     * milliseconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision and a seconds
     * value precise at least to the millisecond. For example, adding one millisecond
     * to {@code 2011T} results in {@code 2011-01-01T00:00:00.001-00:00}. To receive
     * a Timestamp that always maintains the same precision as the original, use
     * {@link #adjustMillis(long)}.
     * milliseconds.
     *
     * @param amount a number of milliseconds.
     */
    public final Timestamp addMillis(long amount)
    {
<span class="fc bfc" id="L2299" title="All 8 branches covered.">        if (amount == 0 &amp;&amp; _precision.includes(Precision.SECOND) &amp;&amp; _fraction != null &amp;&amp; _fraction.scale() &gt;= 3) {</span>
            // Zero milliseconds are to be added, and the precision does not need to be increased.
<span class="fc" id="L2301">            return this;</span>
        }
<span class="fc" id="L2303">        return addMillisForPrecision(amount, Precision.SECOND, true);</span>
    }

    /**
     * Adds the given number of milliseconds, extending (if necessary) the resulting Timestamp to the given
     * precision.
     * @param amount the number of milliseconds to add.
     * @param precision the precision that the Timestamp will be extended to, if it does not already include that
     *                  precision.
     * @param millisecondsPrecision true if and only if the `amount` includes milliseconds precision. If true, the
     *                              resulting timestamp's fraction will have precision at least to the millisecond.
     * @return a new Timestamp.
     */
    private Timestamp addMillisForPrecision(long amount, Precision precision, boolean millisecondsPrecision) {
        // When millisecondsPrecision is true, the caller must do its own short-circuiting because it must
        // check the fractional precision.
<span class="fc bfc" id="L2319" title="All 6 branches covered.">        if (!millisecondsPrecision &amp;&amp; amount == 0 &amp;&amp; _precision == precision) return this;</span>
        // This strips off the local offset, expressing our fields as if they
        // were UTC.
<span class="fc" id="L2322">        BigDecimal millis = make_localtime().getDecimalMillis();</span>
<span class="fc" id="L2323">        millis = millis.add(BigDecimal.valueOf(amount));</span>
<span class="fc bfc" id="L2324" title="All 2 branches covered.">        Precision newPrecision = _precision.includes(precision) ? _precision : precision;</span>


<span class="fc" id="L2327">        Timestamp ts = new Timestamp(millis, newPrecision, _offset);</span>
        // Anything with courser-than-millis precision will have been extended
        // to 3 decimal places due to use of getDecimalMillis(). Compensate for
        // that by setting the scale such that it is never extended unless
        // milliseconds precision is being added and the fraction does not yet
        // have milliseconds precision.
<span class="fc bfc" id="L2333" title="All 2 branches covered.">        int newScale = millisecondsPrecision ? 3 : 0;</span>
<span class="fc bfc" id="L2334" title="All 2 branches covered.">        if (_fraction != null) {</span>
<span class="fc" id="L2335">            newScale = Math.max(newScale, _fraction.scale());</span>
        }
<span class="fc bfc" id="L2337" title="All 2 branches covered.">        if (ts._fraction != null) {</span>
<span class="fc bfc" id="L2338" title="All 2 branches covered.">            ts._fraction = newScale == 0 ? null : ts._fraction.setScale(newScale, RoundingMode.FLOOR);</span>
        }
<span class="fc bfc" id="L2340" title="All 4 branches covered.">        if (_offset != null &amp;&amp; _offset != 0)</span>
        {
<span class="fc" id="L2342">            ts.apply_offset(_offset);</span>
        }
<span class="fc" id="L2344">        return ts;</span>
    }

    /**
     * Clears any fields more precise than this Timestamp's precision supports.
     */
    private void clearUnusedPrecision() {
<span class="fc bfc" id="L2351" title="All 5 branches covered.">        switch (_precision) {</span>
            case YEAR:
<span class="fc" id="L2353">                _month = 1;</span>
            case MONTH:
<span class="fc" id="L2355">                _day = 1;</span>
            case DAY:
<span class="fc" id="L2357">                _hour = 0;</span>
<span class="fc" id="L2358">                _minute = 0;</span>
            case MINUTE:
<span class="fc" id="L2360">                _second = 0;</span>
<span class="fc" id="L2361">                _fraction = null;</span>
            case SECOND:
        }
<span class="fc" id="L2364">    }</span>

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T00:00Z} by one
     * second results in {@code 2012-04-01T00:00Z}; adjusting
     * {@code 2012-04-01T00:00:00Z} by -1 second results in
     * {@code 2012-03-31T23:59:59Z}. To extend the precision when the original
     * Timestamp has coarser than SECOND precision, use {@link #addSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp adjustSecond(int amount)
    {
<span class="fc" id="L2380">        long delta = (long) amount * 1000;</span>
<span class="fc" id="L2381">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of seconds.
     * &lt;p&gt;
     * This method always returns a Timestamp with SECOND precision.
     * For example, adding one second to {@code 2011T} results in
     * {@code 2011-01-01T00:00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustSecond(int)}.
     *
     * @param amount a number of seconds.
     */
    public final Timestamp addSecond(int amount)
    {
<span class="fc" id="L2396">        long delta = (long) amount * 1000;</span>
<span class="fc" id="L2397">        return addMillisForPrecision(delta, Precision.SECOND, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one minute
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 minute results in {@code 2012-03-31T23:59-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp adjustMinute(int amount)
    {
<span class="fc" id="L2414">        long delta = (long) amount * 60 * 1000;</span>
<span class="fc" id="L2415">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of minutes.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one minute to {@code 2011T} results in
     * {@code 2011-01-01T00:01-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustMinute(int)}.
     *
     * @param amount a number of minutes.
     */
    public final Timestamp addMinute(int amount)
    {
<span class="fc" id="L2430">        long delta = (long) amount * 60 * 1000;</span>
<span class="fc" id="L2431">        return addMillisForPrecision(delta, Precision.MINUTE, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04-01T} by one hour
     * results in {@code 2012-04-01T}; adjusting {@code 2012-04-01T00:00-00:00}
     * by -1 hour results in {@code 2012-03-31T23:00-00:00}. To extend the
     * precision when the original Timestamp has coarser than MINUTE precision,
     * use {@link #addHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp adjustHour(int amount)
    {
<span class="fc" id="L2448">        long delta = (long) amount * 60 * 60 * 1000;</span>
<span class="fc" id="L2449">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of hours.
     * &lt;p&gt;
     * This method always returns a Timestamp with at least MINUTE precision.
     * For example, adding one hour to {@code 2011T} results in
     * {@code 2011-01-01T01:00-00:00}. To receive a Timestamp that always
     * maintains the same precision as the original, use {@link #adjustHour(int)}.
     *
     * @param amount a number of hours.
     */
    public final Timestamp addHour(int amount)
    {
<span class="fc" id="L2464">        long delta = (long) amount * 60 * 60 * 1000;</span>
<span class="fc" id="L2465">        return addMillisForPrecision(delta, Precision.MINUTE, false);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as
     * the original. For example, adjusting {@code 2012-04T} by one day results
     * in {@code 2012-04T}; adjusting {@code 2012-04-01T} by -1 days results in
     * {@code 2012-03-31T}. To extend the precision when the original Timestamp
     * has coarser than DAY precision, use {@link #addDay(int)}.
     *
     * @param amount a number of days.
     */
    public final Timestamp adjustDay(int amount)
    {
<span class="fc" id="L2481">        long delta = (long) amount * 24 * 60 * 60 * 1000;</span>
<span class="fc" id="L2482">        return adjustMillis(delta);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of days.
     *
     * @param amount a number of days.
     */
    public final Timestamp addDay(int amount)
    {
<span class="fc" id="L2492">        long delta = (long) amount * 24 * 60 * 60 * 1000;</span>
<span class="fc" id="L2493">        return addMillisForPrecision(delta, Precision.DAY, false);</span>
    }

    // Shifting month and year are more complicated since the length of a month
    // varies and we want the day-of-month to stay the same when possible.
    // We rely on Calendar for the logic.

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days.
     * &lt;p&gt;
     * This method always returns a Timestamp with the same precision as the
     * original. For example, adjusting {@code 2011T} by one month results in
     * {@code 2011T}; adding 12 months to {@code 2011T} results in {@code 2012T}.
     * To extend the precision when the original Timestamp has coarser than MONTH
     * precision, use {@link #addMonth(int)}.
     *
     * @param amount a number of months.
     */
    public final Timestamp adjustMonth(int amount)
    {
<span class="pc bpc" id="L2515" title="1 of 2 branches missed.">        if (amount == 0) return this;</span>
<span class="fc" id="L2516">        return addMonthForPrecision(amount, _precision);</span>
    }

    /**
     * Adds the given number of months, extending (if necessary) the resulting Timestamp to the given
     * precision.
     * @param amount the number of months to add.
     * @param precision the precision that the Timestamp will be extended to, if it does not already include that
     *                  precision.
     * @return a new Timestamp.
     */
    private Timestamp addMonthForPrecision(int amount, Precision precision) {
<span class="fc" id="L2528">        Calendar cal = calendarValue();</span>
<span class="fc" id="L2529">        cal.add(Calendar.MONTH, amount);</span>
<span class="fc" id="L2530">        return new Timestamp(cal, precision, _fraction, _offset);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of months.
     * The day field may be adjusted to account for different month length and
     * leap days.  For example, adding one month to {@code 2011-01-31}
     * results in {@code 2011-02-28}.
     *
     * @param amount a number of months.
     */
    public final Timestamp addMonth(int amount)
    {
<span class="pc bpc" id="L2543" title="3 of 4 branches missed.">        if (amount == 0 &amp;&amp; _precision.includes(Precision.MONTH)) return this;</span>
<span class="fc bfc" id="L2544" title="All 2 branches covered.">        return addMonthForPrecision(amount, _precision.includes(Precision.MONTH) ? _precision : Precision.MONTH);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days. For example,
     * adjusting {@code 2012-02-29} by one year results in {@code 2013-02-28}.
     * &lt;p&gt;
     * Because YEAR is the coarsest precision possible, this method always
     * returns a Timestamp with the same precision as the original and
     * behaves identically to {@link #addYear(int)}.
     *
     * @param amount a number of years.
     */
    public final Timestamp adjustYear(int amount) {
<span class="fc" id="L2559">        return addYear(amount);</span>
    }

    /**
     * Returns a timestamp relative to this one by the given number of years.
     * The day field may be adjusted to account for leap days.  For example,
     * adding one year to {@code 2012-02-29} results in {@code 2013-02-28}.
     *
     * @param amount a number of years.
     */
    public final Timestamp addYear(int amount)
    {
<span class="pc bpc" id="L2571" title="1 of 2 branches missed.">        if (amount == 0) return this;</span>

<span class="fc" id="L2573">        Calendar cal = calendarValue();</span>
<span class="fc" id="L2574">        cal.add(Calendar.YEAR, amount);</span>
<span class="fc" id="L2575">        return new Timestamp(cal, _precision, _fraction, _offset);</span>
    }


    //=========================================================================

    /**
     * Returns a hash code consistent with {@link #equals(Object)}.
     * &lt;p&gt;
     * {@inheritDoc}
     */
    @Override
    public int hashCode()
    {
        // Performs a Shift-Add-XOR-Rotate hash. Rotating at each step to
        // produce an &quot;Avalanche&quot; effect for timestamps with small deltas, which
        // is found to be a common input data set.

<span class="fc" id="L2593">        final int prime = 8191;</span>
<span class="fc" id="L2594">        int result = HASH_SIGNATURE;</span>

<span class="fc bfc" id="L2596" title="All 2 branches covered.">        result = prime * result + (_fraction != null</span>
<span class="fc" id="L2597">            ? _fraction.hashCode()</span>
<span class="fc" id="L2598">            : 0);</span>

<span class="fc" id="L2600">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2602">        result = prime * result + this._year;</span>
<span class="fc" id="L2603">        result = prime * result + this._month;</span>
<span class="fc" id="L2604">        result = prime * result + this._day;</span>
<span class="fc" id="L2605">        result = prime * result + this._hour;</span>
<span class="fc" id="L2606">        result = prime * result + this._minute;</span>
<span class="fc" id="L2607">        result = prime * result + this._second;</span>

<span class="fc" id="L2609">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc bfc" id="L2611" title="All 2 branches covered.">        Precision precision = this._precision == Precision.FRACTION ? Precision.SECOND : this._precision;</span>
<span class="fc" id="L2612">        result = prime * result + precision.toString().hashCode();</span>

<span class="fc" id="L2614">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc bfc" id="L2616" title="All 2 branches covered.">        result = prime * result + (_offset == null ? 0 : _offset.hashCode());</span>

<span class="fc" id="L2618">        result ^= (result &lt;&lt; 19) ^ (result &gt;&gt; 13);</span>

<span class="fc" id="L2620">        return result;</span>
    }



    /**
     * Performs a comparison of the two points in time represented by two
     * Timestamps.
     * If the point in time represented by this Timestamp precedes that of
     * {@code t}, then {@code -1} is returned.
     * If {@code t} precedes this Timestamp then {@code 1} is returned.
     * If the Timestamps represent the same point in time, then
     * {@code 0} is returned.
     * Note that a {@code 0} result does not imply that the two Timestamps are
     * {@link #equals}, as the local offset or precision of the two Timestamps
     * may be different.
     *
     * &lt;p&gt;
     * This method is provided in preference to individual methods for each of
     * the six boolean comparison operators (&amp;lt;, ==, &amp;gt;, &amp;gt;=, !=, &amp;lt;=).
     * The suggested idiom for performing these comparisons is:
     * {@code (x.compareTo(y)}&lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt;{@code 0)},
     * where &lt;em&gt;&amp;lt;op&amp;gt;&lt;/em&gt; is one of the six comparison operators.
     *
     * &lt;p&gt;
     * For example, the pairs below will return a {@code 0} result:
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2009T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.0Z}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T00:00:00.00Z}&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2008-12-31T16:00-08:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2008-12-31T12:00-12:00}&lt;/li&gt;
     *   &lt;li&gt;{@code 2009-01-01T12:00+12:00}&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #equals(Timestamp)} method to compare the point
     * in time, &lt;em&gt;including&lt;/em&gt; precision and local offset.
     *
     * @param t
     *          the other {@code Timestamp} to compare this {@code Timestamp} to
     *
     * @return
     *          -1, 0, or 1 if this {@code Timestamp}
     *          is less than, equal to, or greater than {@code t} respectively
     *
     * @throws NullPointerException if {@code t} is null.
     *
     * @see #equals(Timestamp)
     */
    public int compareTo(Timestamp t)
    {
        // Test at millisecond precision first.
<span class="fc" id="L2678">        long this_millis = this.getMillis();</span>
<span class="fc" id="L2679">        long arg_millis = t.getMillis();</span>
<span class="fc bfc" id="L2680" title="All 2 branches covered.">        if (this_millis != arg_millis) {</span>
<span class="fc bfc" id="L2681" title="All 2 branches covered.">            return (this_millis &lt; arg_millis) ? -1 : 1;</span>
        }

        // Values are equivalent at millisecond precision, so compare fraction

        BigDecimal this_fraction =
<span class="fc bfc" id="L2687" title="All 2 branches covered.">            ((this._fraction == null) ? BigDecimal.ZERO : this._fraction);</span>
        BigDecimal arg_fraction =
<span class="fc bfc" id="L2689" title="All 2 branches covered.">            (( t._fraction == null) ? BigDecimal.ZERO :  t._fraction);</span>
<span class="fc" id="L2690">        return this_fraction.compareTo(arg_fraction);</span>
    }


    /**
     * Compares this {@link Timestamp} to the specified Object.
     * The result is {@code true} if and only if the parameter is a
     * {@link Timestamp} object that represents the same point in time,
     * precision and local offset as this Timestamp.
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #equals(Timestamp)
     * @see #compareTo(Timestamp)
     */
    @Override
    public boolean equals(Object t)
    {
<span class="pc bpc" id="L2709" title="1 of 2 branches missed.">        if (!(t instanceof Timestamp)) return false;</span>
<span class="fc" id="L2710">        return equals((Timestamp)t);</span>
    }

    /**
     * Compares this {@link Timestamp} to another {@link Timestamp} object.
     * The result is {@code true} if and only if the parameter
     * represents the same point in time and has
     * the same precision and local offset as this object.
     * &lt;p&gt;
     * These pairs are {@link #equals} to each other, as they
     * represent the same points in time, precision and local offset:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22+00:00} (minute precision, in UTC)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T11:22Z} (minute precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * On the other hand, none of these pairs are {@link #equals} to each other,
     * they represent the same points in time, but with different precisions
     * and/or local offsets:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;{@code 2001T} (year precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01T} (month precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T} (day precision, unknown local offset)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00-00:00} (second precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00+00:00} (second precision, in UTC)&lt;/li&gt;
     *
     *   &lt;li&gt;{@code 2001-01-01T00:00.000-00:00} (millisecond precision, unknown local offset)&lt;/li&gt;
     *   &lt;li&gt;{@code 2001-01-01T00:00.000+00:00} (millisecond precision, in UTC)&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     * Use the {@link #compareTo(Timestamp)} method to compare only the point
     * in time, &lt;em&gt;ignoring&lt;/em&gt; precision and local offset.
     *
     * @see #compareTo(Timestamp)
     */
    public boolean equals(Timestamp t)
    {
<span class="fc bfc" id="L2752" title="All 2 branches covered.">        if (this == t) return true;</span>
<span class="pc bpc" id="L2753" title="1 of 2 branches missed.">        if (t == null) return false;</span>

        // FRACTION precision is equivalent to SECOND precision.
<span class="fc bfc" id="L2756" title="All 2 branches covered.">        Precision thisPrecision = this._precision.includes(Precision.SECOND) ? Precision.SECOND : this._precision;</span>
<span class="fc bfc" id="L2757" title="All 2 branches covered.">        Precision thatPrecision = t._precision.includes(Precision.SECOND) ? Precision.SECOND : t._precision;</span>

        // if the precisions are not the same the values are not
        // precision doesn't matter WRT equality
<span class="fc bfc" id="L2761" title="All 2 branches covered.">        if (thisPrecision != thatPrecision) return false;</span>

        // if the local offset are not the same the values are not
<span class="fc bfc" id="L2764" title="All 2 branches covered.">        if (this._offset == null) {</span>
<span class="fc bfc" id="L2765" title="All 2 branches covered.">            if (t._offset != null)  return false;</span>
        }
        else {
<span class="fc bfc" id="L2768" title="All 2 branches covered.">            if (t._offset == null) return false;</span>
        }

        // so now we check the actual time value
<span class="fc bfc" id="L2772" title="All 2 branches covered.">        if (this._year   != t._year)    return false;</span>
<span class="fc bfc" id="L2773" title="All 2 branches covered.">        if (this._month  != t._month)   return false;</span>
<span class="fc bfc" id="L2774" title="All 2 branches covered.">        if (this._day    != t._day)     return false;</span>
<span class="fc bfc" id="L2775" title="All 2 branches covered.">        if (this._hour   != t._hour)    return false;</span>
<span class="fc bfc" id="L2776" title="All 2 branches covered.">        if (this._minute != t._minute)  return false;</span>
<span class="fc bfc" id="L2777" title="All 2 branches covered.">        if (this._second != t._second)  return false;</span>

        // and if we have a local offset, check the value here
<span class="fc bfc" id="L2780" title="All 2 branches covered.">        if (this._offset != null) {</span>
<span class="fc bfc" id="L2781" title="All 2 branches covered.">            if (this._offset.intValue() != t._offset.intValue()) return false;</span>
        }

        // we only look at the fraction if we know that it's actually there
<span class="fc bfc" id="L2785" title="All 8 branches covered.">        if ((this._fraction != null &amp;&amp; t._fraction == null)</span>
                || (this._fraction == null &amp;&amp; t._fraction != null)) {
            // one of the fractions are null
<span class="fc" id="L2788">            return false;</span>
        }
<span class="pc bpc" id="L2790" title="1 of 4 branches missed.">        if (this._fraction == null &amp;&amp; t._fraction == null) {</span>
            // both are null
<span class="fc" id="L2792">            return true;</span>
        }
<span class="fc" id="L2794">        return this._fraction.equals(t._fraction);</span>
    }

    private static short checkAndCastYear(int year)
    {
<span class="fc bfc" id="L2799" title="All 4 branches covered.">        if (year &lt; 1 || year &gt; 9999)</span>
        {
<span class="fc" id="L2801">            throw new IllegalArgumentException(String.format(&quot;Year %s must be between 1 and 9999 inclusive&quot;, year));</span>
        }

<span class="fc" id="L2804">        return (short) year;</span>
    }

    private static byte checkAndCastMonth(int month)
    {
<span class="fc bfc" id="L2809" title="All 4 branches covered.">        if (month &lt; 1 || month &gt; 12)</span>
        {
<span class="fc" id="L2811">            throw new IllegalArgumentException(String.format(&quot;Month %s must be between 1 and 12 inclusive&quot;, month));</span>
        }

<span class="fc" id="L2814">        return (byte) month;</span>
    }

    private static byte checkAndCastDay(int day, int year, int month)
    {
<span class="fc" id="L2819">        int lastDayInMonth = last_day_in_month(year, month);</span>
<span class="fc bfc" id="L2820" title="All 4 branches covered.">        if (day &lt; 1 || day &gt; lastDayInMonth) {</span>
<span class="fc" id="L2821">            throw new IllegalArgumentException(String.format(&quot;Day %s for year %s and month %s must be between 1 and %s inclusive&quot;, day, year, month, lastDayInMonth));</span>
        }

<span class="fc" id="L2824">        return (byte) day;</span>
    }

    private static byte checkAndCastHour(int hour)
    {
<span class="pc bpc" id="L2829" title="1 of 4 branches missed.">        if (hour &lt; 0 || hour &gt; 23)</span>
        {
<span class="fc" id="L2831">            throw new IllegalArgumentException(String.format(&quot;Hour %s must be between 0 and 23 inclusive&quot;, hour));</span>
        }

<span class="fc" id="L2834">        return (byte) hour;</span>
    }

    private static byte checkAndCastMinute(int minute)
    {
<span class="pc bpc" id="L2839" title="1 of 4 branches missed.">        if (minute &lt; 0 || minute &gt; 59)</span>
        {
<span class="fc" id="L2841">            throw new IllegalArgumentException(String.format(&quot;Minute %s must be between between 0 and 59 inclusive&quot;, minute));</span>
        }

<span class="fc" id="L2844">        return (byte) minute;</span>
    }

    private static byte checkAndCastSecond(int second)
    {
<span class="fc bfc" id="L2849" title="All 4 branches covered.">        if (second &lt; 0 || second &gt; 59)</span>
        {
<span class="fc" id="L2851">            throw new IllegalArgumentException(String.format(&quot;Second %s must be between between 0 and 59 inclusive&quot;, second));</span>
        }

<span class="fc" id="L2854">        return (byte) second;</span>
    }

    private static Precision checkFraction(Precision precision, BigDecimal fraction)
    {
<span class="fc bfc" id="L2859" title="All 2 branches covered.">        if (precision.includes(Precision.SECOND)) {</span>
<span class="pc bpc" id="L2860" title="1 of 6 branches missed.">            if (fraction != null &amp;&amp; (fraction.signum() == -1 || BigDecimal.ONE.compareTo(fraction) != 1)) {</span>
<span class="fc" id="L2861">                throw new IllegalArgumentException(String.format(&quot;Fractional seconds %s must be greater than or equal to 0 and less than 1&quot;, fraction));</span>
            }
        }
        else {
<span class="pc bpc" id="L2865" title="1 of 2 branches missed.">            if (fraction != null) {</span>
<span class="nc" id="L2866">                throw new IllegalArgumentException(&quot;Fraction must be null for non-second precision: &quot; + fraction);</span>
            }
        }

<span class="fc" id="L2870">        return precision;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>