<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SharedSymbolTable.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">com.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">com.amazon.ion.impl</a> &gt; <span class="el_source">SharedSymbolTable.java</span></div><h1>SharedSymbolTable.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2007-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed
 * on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazon.ion.impl;

import static com.amazon.ion.SystemSymbols.ION;
import static com.amazon.ion.SystemSymbols.ION_1_0;
import static com.amazon.ion.SystemSymbols.NAME_SID;
import static com.amazon.ion.SystemSymbols.SYMBOLS_SID;
import static com.amazon.ion.SystemSymbols.VERSION_SID;
import static com.amazon.ion.impl._Private_Utils.getSidForSymbolTableField;

import com.amazon.ion.IonException;
import com.amazon.ion.IonReader;
import com.amazon.ion.IonStruct;
import com.amazon.ion.IonSystem;
import com.amazon.ion.IonType;
import com.amazon.ion.IonWriter;
import com.amazon.ion.ReadOnlyValueException;
import com.amazon.ion.SymbolTable;
import com.amazon.ion.SymbolToken;
import com.amazon.ion.SystemSymbols;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * An &lt;em&gt;immutable&lt;/em&gt; shared symbol table, supporting (non-system) shared
 * symbol tables and system symbol tables.
 * &lt;p&gt;
 * Instances of this class are safe for use by multiple threads.
 */
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">final class SharedSymbolTable</span>
    implements SymbolTable
{
    /**
     * The array of system symbols as defined by Ion 1.0.
     */
<span class="fc" id="L56">    private static final String[] SYSTEM_SYMBOLS =</span>
    {
        SystemSymbols.ION,
        SystemSymbols.ION_1_0,
        SystemSymbols.ION_SYMBOL_TABLE,
        SystemSymbols.NAME,
        SystemSymbols.VERSION,
        SystemSymbols.IMPORTS,
        SystemSymbols.SYMBOLS,
        SystemSymbols.MAX_ID,
        SystemSymbols.ION_SHARED_SYMBOL_TABLE
    };

    /**
     * The &lt;b&gt;singleton&lt;/b&gt; instance of Ion 1.0 system symbol table.
     * &lt;p&gt;
     * TODO amzn/ion-java/issues/34 Optimize system symtabs by using our custom backing impl.
     */
    private static final SymbolTable ION_1_0_SYSTEM_SYMTAB;
    static
    {
<span class="fc" id="L77">        Map&lt;String, Integer&gt; systemSymbolsMap = new HashMap&lt;String, Integer&gt;();</span>

<span class="fc bfc" id="L79" title="All 2 branches covered.">        for (int i = 0; i &lt; SYSTEM_SYMBOLS.length; i++)</span>
        {
<span class="fc" id="L81">            systemSymbolsMap.put(SYSTEM_SYMBOLS[i], i+1);</span>
        }

<span class="fc" id="L84">        ION_1_0_SYSTEM_SYMTAB =</span>
            new SharedSymbolTable(ION, 1, SYSTEM_SYMBOLS, systemSymbolsMap);
<span class="fc" id="L86">    }</span>

    /**
     * The name of this shared symbol table. If this is a system symbol
     * table, it is {@link SystemSymbols#ION}.
     */
    private final String                        myName;

    /**
     * The version of this shared symbol table.
     */
    private final int                           myVersion;

    /**
     * The names (aka text) of declared symbols in this shared symbol
     * table (that are not imported from some other symbol table); never null.
     * The sid of the first element is 1.
     * &lt;p&gt;
     * Note that null references are valid elements within this member field,
     * denoting undefined symbol IDs (&quot;gaps&quot;).
     */
    private final String[]                      mySymbolNames;

    /**
     * Map of symbol names to symbol ids of declared symbols.
     */
    private final Map&lt;String, Integer&gt;          mySymbolsMap;

    //==========================================================================
    // Private constructor(s) and static factory methods
    //==========================================================================

    private SharedSymbolTable(String name, int version,
                              List&lt;String&gt; symbolsList,
                              Map&lt;String, Integer&gt; symbolsMap)
<span class="fc" id="L121">    {</span>
<span class="fc" id="L122">        myName          = name;</span>
<span class="fc" id="L123">        myVersion       = version;</span>
<span class="fc" id="L124">        mySymbolsMap    = symbolsMap;</span>

        // Construct primitive fixed-length array from the passed-in List
<span class="fc" id="L127">        mySymbolNames   = symbolsList.toArray(new String[symbolsList.size()]);</span>
<span class="fc" id="L128">    }</span>

    private SharedSymbolTable(String name, int version,
                              String[] symbolNames,
                              Map&lt;String, Integer&gt; symbolsMap)
<span class="fc" id="L133">    {</span>
<span class="fc" id="L134">        myName          = name;</span>
<span class="fc" id="L135">        myVersion       = version;</span>
<span class="fc" id="L136">        mySymbolsMap    = symbolsMap;</span>

<span class="fc" id="L138">        mySymbolNames   = symbolNames;</span>
<span class="fc" id="L139">    }</span>

    /**
     * Constructs a new shared symbol table from the parameters.
     * &lt;p&gt;
     * As per {@link IonSystem#newSharedSymbolTable(String, int, Iterator, SymbolTable...)},
     * any duplicate or null symbol texts are skipped.
     * &lt;p&gt;
     * Therefore, &lt;b&gt;THIS METHOD IS NOT SUITABLE WHEN READING SERIALIZED
     * SHARED SYMBOL TABLES&lt;/b&gt; since that scenario must preserve all sids.
     *
     * @param name              the name of the new shared symbol table
     * @param version           the version of the new shared symbol table
     * @param priorSymtab       may be null
     * @param symbols           never null
     */
    static SymbolTable newSharedSymbolTable(String name, int version,
                                            SymbolTable priorSymtab,
                                            Iterator&lt;String&gt; symbols)
    {
<span class="fc bfc" id="L159" title="All 4 branches covered.">        if (name == null || name.length() &lt; 1)</span>
        {
<span class="fc" id="L161">            throw new IllegalArgumentException(&quot;name must be non-empty&quot;);</span>
        }
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (version &lt; 1)</span>
        {
<span class="fc" id="L165">            throw new IllegalArgumentException(&quot;version must be at least 1&quot;);</span>
        }

<span class="fc" id="L168">        List&lt;String&gt; symbolsList = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L169">        Map&lt;String, Integer&gt; symbolsMap = new HashMap&lt;String, Integer&gt;();</span>

<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        assert version ==</span>
<span class="pc bpc" id="L172" title="1 of 4 branches missed.">            (priorSymtab == null ? 1 : priorSymtab.getVersion() + 1);</span>

<span class="fc" id="L174">        prepSymbolsListAndMap(priorSymtab, symbols, symbolsList, symbolsMap);</span>

        // We have all necessary data, pass it over to the private constructor.
<span class="fc" id="L177">        return new SharedSymbolTable(name, version, symbolsList, symbolsMap);</span>
    }

    /**
     * Constructs a new shared symbol table represented by the passed in
     * {@link IonStruct}.
     *
     * @param ionRep
     *          the {@link IonStruct} representing the new shared symbol table
     * @return
     */
    static SymbolTable newSharedSymbolTable(IonStruct ionRep)
    {
<span class="fc" id="L190">        IonReader reader = new IonReaderTreeSystem(ionRep);</span>
<span class="fc" id="L191">        return newSharedSymbolTable(reader, false);</span>
    }

    /**
     * Constructs a new shared symbol table represented by the current value
     * of the passed in {@link IonReader}.
     *
     * @param reader
     *          the {@link IonReader} positioned on the shared symbol table
     *          represented as an {@link IonStruct}
     * @param isOnStruct
     *          denotes whether the {@link IonReader} is already positioned on
     *          the struct; false if it is positioned before the struct
     * @return
     */
    static SymbolTable newSharedSymbolTable(IonReader reader,
                                            boolean isOnStruct)
    {
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (! isOnStruct)</span>
        {
<span class="fc" id="L211">            IonType t = reader.next();</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (t != IonType.STRUCT)</span>
            {
<span class="nc" id="L214">                throw new IonException(&quot;invalid symbol table image passed &quot; +</span>
                                &quot;into reader, &quot; + t + &quot; encountered when a &quot; +
                                &quot;struct was expected&quot;);
            }
        }

<span class="fc" id="L220">        String name = null;</span>
<span class="fc" id="L221">        int version = -1;</span>
<span class="fc" id="L222">        List&lt;String&gt; symbolsList = new ArrayList&lt;String&gt;();</span>

<span class="fc" id="L224">        reader.stepIn();</span>

<span class="fc" id="L226">        IonType fieldType = null;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        while ((fieldType = reader.next()) != null)</span>
        {
<span class="fc bfc" id="L229" title="All 2 branches covered.">            if (reader.isNullValue()) continue;</span>

<span class="fc" id="L231">            SymbolToken symTok = reader.getFieldNameSymbol();</span>
<span class="fc" id="L232">            int sid = symTok.getSid();</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">            if (sid == SymbolTable.UNKNOWN_SYMBOL_ID)</span>
            {
                // This is a user-defined IonReader or a pure DOM, fall
                // back to text
<span class="nc" id="L237">                final String fieldName = reader.getFieldName();</span>
<span class="nc" id="L238">                sid = getSidForSymbolTableField(fieldName);</span>
            }

            // TODO amzn/ion-java/issues/35 If there's more than one 'symbols' or 'imports'
            //      field, they will be merged together.
            // TODO amzn/ion-java/issues/36 Switching over SIDs doesn't cover the case
            //      where the relevant field names are defined by a prev LST;
            //      the prev LST could have 'symbols' defined locally with a
            //      different SID!
<span class="fc bfc" id="L247" title="All 4 branches covered.">            switch (sid)</span>
            {
                case VERSION_SID:
<span class="fc bfc" id="L250" title="All 2 branches covered.">                    if (fieldType == IonType.INT)</span>
                    {
<span class="fc" id="L252">                        version = reader.intValue();</span>
                    }
                    break;
                case NAME_SID:
<span class="fc bfc" id="L256" title="All 2 branches covered.">                    if (fieldType == IonType.STRING)</span>
                    {
<span class="fc" id="L258">                        name = reader.stringValue();</span>
                    }
                    break;
                case SYMBOLS_SID:
                    // As per the Spec, other field types are treated as
                    // empty lists
<span class="fc bfc" id="L264" title="All 2 branches covered.">                    if (fieldType == IonType.LIST)</span>
                    {
<span class="fc" id="L266">                        reader.stepIn();</span>
                        {
                            IonType t;
<span class="fc bfc" id="L269" title="All 2 branches covered.">                            while ((t = reader.next()) != null)</span>
                            {
<span class="fc" id="L271">                                String text = null;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                                if (t == IonType.STRING</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                                    &amp;&amp; ! reader.isNullValue())</span>
                                {
                                    // As per the Spec, if any element of
                                    // the list is the empty string or any
                                    // other type, treat it as null
<span class="fc" id="L278">                                    text = reader.stringValue();</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                                    if (text.length() == 0) text = null;</span>
                                }
<span class="fc" id="L281">                                symbolsList.add(text);</span>
<span class="fc" id="L282">                            }</span>
                        }
<span class="fc" id="L284">                        reader.stepOut();</span>
                    }
                    break;
                default:
                    break;
            }
<span class="fc" id="L290">        }</span>

<span class="fc" id="L292">        reader.stepOut();</span>

<span class="fc bfc" id="L294" title="All 4 branches covered.">        if (name == null || name.length() == 0)</span>
        {
<span class="fc" id="L296">            String message =</span>
                &quot;shared symbol table is malformed: field 'name' &quot; +
                &quot;must be a non-empty string.&quot;;
<span class="fc" id="L299">            throw new IonException(message);</span>
        }

        // As per the Spec, if 'version' field is missing or not at
        // least 1, treat it as 1.
<span class="fc bfc" id="L304" title="All 2 branches covered.">        version = (version &lt; 1) ? 1 : version;</span>

<span class="fc" id="L306">        Map&lt;String, Integer&gt; symbolsMap = null;</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (! symbolsList.isEmpty())</span>
        {
<span class="fc" id="L309">            symbolsMap = new HashMap&lt;String, Integer&gt;();</span>
<span class="fc" id="L310">            transferNonExistingSymbols(symbolsList, symbolsMap);</span>
        }
        else
        {
            // Empty Map is more efficient than an empty HashMap
<span class="fc" id="L315">            symbolsMap = Collections.emptyMap();</span>
        }

        // We have all necessary data, pass it over to the private constructor.
<span class="fc" id="L319">        return new SharedSymbolTable(name, version, symbolsList, symbolsMap);</span>
    }

    /**
     * Gets a specific version of the system symbol table.
     *
     * @param version
     *          the specified version of the system symbol table; currently,
     *          only version 1 (Ion 1.0) is supported
     * @return
     *
     * @throws IllegalArgumentException if the specified version isn't supported
     */
    static SymbolTable getSystemSymbolTable(int version)
    {
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (version != 1)</span>
        {
<span class="nc" id="L336">            throw new IllegalArgumentException(&quot;only Ion 1.0 system &quot; +</span>
                        &quot;symbols are supported&quot;);
        }

<span class="fc" id="L340">        return ION_1_0_SYSTEM_SYMTAB;</span>
    }

    //==========================================================================
    // Static methods relating to construction
    //==========================================================================

    private static void putToMapIfNotThere(Map&lt;String, Integer&gt; symbolsMap,
                                           String text, int sid)
    {
        // When there's a duplicate mapping for the symbol text, don't
        // replace the lower sid. This pattern avoids double-lookup in the
        // common scenario and only performs a second lookup when there's
        // a duplicate.
<span class="fc" id="L354">        Integer extantSid = symbolsMap.put(text, sid);</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (extantSid != null)</span>
        {
            // We always insert symbols with increasing sids
<span class="pc bpc" id="L358" title="2 of 4 branches missed.">            assert extantSid &lt; sid;</span>
<span class="fc" id="L359">            symbolsMap.put(text, extantSid);</span>
        }
<span class="fc" id="L361">    }</span>

    /**
     * Collects the necessary symbols from {@code priorSymtab} and
     * {@code symbols}, and load them into the passed-in {@code symbolsList} and
     * {@code symbolsMap}.
     */
    private static void
    prepSymbolsListAndMap(SymbolTable priorSymtab, Iterator&lt;String&gt; symbols,
                          List&lt;String&gt; symbolsList,
                          Map&lt;String, Integer&gt; symbolsMap)
    {
<span class="fc" id="L373">        int sid = 1;</span>

        // Collect from passed-in priorSymtab
<span class="fc bfc" id="L376" title="All 2 branches covered.">        if (priorSymtab != null)</span>
        {
<span class="fc" id="L378">            Iterator&lt;String&gt; priorSymbols =</span>
<span class="fc" id="L379">                priorSymtab.iterateDeclaredSymbolNames();</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            while (priorSymbols.hasNext())</span>
            {
<span class="fc" id="L382">                String text = priorSymbols.next();</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                if (text != null)</span>
                {
<span class="pc bpc" id="L385" title="2 of 4 branches missed.">                    assert text.length() &gt; 0;</span>
<span class="fc" id="L386">                    putToMapIfNotThere(symbolsMap, text, sid);</span>
                }

                // NB: Null entries must be added in the sid sequence
                //     to retain compat. with the prior version.
<span class="fc" id="L391">                symbolsList.add(text);</span>

<span class="fc" id="L393">                sid++;</span>
<span class="fc" id="L394">            }</span>
        }

        // Collect from passed-in symbols
<span class="fc bfc" id="L398" title="All 2 branches covered.">        while (symbols.hasNext())</span>
        {
<span class="fc" id="L400">            String text = symbols.next();</span>
            // TODO amzn/ion-java/issues/12 What about empty symbols?
<span class="fc bfc" id="L402" title="All 2 branches covered.">            if (symbolsMap.get(text) == null)</span>
            {
<span class="fc" id="L404">                putToMapIfNotThere(symbolsMap, text, sid);</span>
<span class="fc" id="L405">                symbolsList.add(text);</span>
<span class="fc" id="L406">                sid++;</span>
            }
<span class="fc" id="L408">        }</span>
<span class="fc" id="L409">    }</span>

    /**
     * Transfer symbols from {@code symbolsList} to {@code symbolsMap} that
     * doesn't already exist in the map.
     */
    private static void
    transferNonExistingSymbols(List&lt;String&gt; symbolsList,
                               Map&lt;String, Integer&gt; symbolsMap)
    {
<span class="fc" id="L419">        int sid = 1;</span>
<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (String text : symbolsList)</span>
        {
<span class="pc bpc" id="L422" title="2 of 6 branches missed.">            assert text == null || text.length() &gt; 0;</span>

<span class="fc bfc" id="L424" title="All 2 branches covered.">            if (text != null)</span>
            {
<span class="fc" id="L426">                putToMapIfNotThere(symbolsMap, text, sid);</span>
            }

<span class="fc" id="L429">            sid++;</span>
<span class="fc" id="L430">        }</span>
<span class="fc" id="L431">    }</span>

    //==========================================================================
    // Public methods
    //==========================================================================

    public String getName()
    {
<span class="fc" id="L439">        return myName;</span>
    }

    public int getVersion()
    {
<span class="fc" id="L444">        return myVersion;</span>
    }

    public boolean isLocalTable()
    {
<span class="fc" id="L449">        return false;</span>
    }

    public boolean isSharedTable()
    {
<span class="fc" id="L454">        return true;</span>
    }

    public boolean isSubstitute()
    {
<span class="fc" id="L459">        return false;</span>
    }

    public boolean isSystemTable()
    {
<span class="fc" id="L464">        return ION.equals(myName);</span>
    }

    public boolean isReadOnly()
    {
<span class="fc" id="L469">        return true;</span>
    }

    public void makeReadOnly()
    {
        // No-op
<span class="nc" id="L475">    }</span>

    public SymbolTable getSystemSymbolTable()
    {
<span class="fc bfc" id="L479" title="All 2 branches covered.">        if (isSystemTable()) return this;</span>

<span class="fc" id="L481">        return null; // non-system shared table</span>
    }

    public String getIonVersionId()
    {
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (isSystemTable())</span>
        {
<span class="fc" id="L488">            int id = getVersion();</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">            if (id != 1)</span>
            {
<span class="nc" id="L491">                throw new IonException(&quot;unrecognized system version &quot; +</span>
                		&quot;encountered: &quot; + id);
            }

<span class="fc" id="L495">            return ION_1_0;</span>
        }

<span class="fc" id="L498">        return null; // non-system shared tables aren't tied to an Ion version</span>
    }

    public SymbolTable[] getImportedTables()
    {
<span class="fc" id="L503">        return null;</span>
    }

    public int getImportedMaxId()
    {
<span class="fc" id="L508">        return 0;</span>
    }

    public int getMaxId()
    {
<span class="fc" id="L513">        return mySymbolNames.length;</span>
    }

    public SymbolToken intern(String text)
    {
<span class="fc" id="L518">        SymbolToken symTok = find(text);</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">        if (symTok == null)</span>
        {
<span class="fc" id="L521">            throw new ReadOnlyValueException(SymbolTable.class);</span>
        }

<span class="fc" id="L524">        return symTok;</span>
    }

    public SymbolToken find(String text)
    {
<span class="fc" id="L529">        text.getClass(); // fast null check</span>

<span class="fc" id="L531">        Integer sid = mySymbolsMap.get(text);</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (sid != null)</span>
        {
<span class="pc bpc" id="L534" title="2 of 4 branches missed.">            assert sid != UNKNOWN_SYMBOL_ID;</span>

<span class="fc" id="L536">            int offset = sid - 1;</span>
<span class="fc" id="L537">            String internedText = mySymbolNames[offset];</span>

<span class="pc bpc" id="L539" title="2 of 4 branches missed.">            assert internedText != null;</span>

<span class="fc" id="L541">            return new SymbolTokenImpl(internedText, sid);</span>
        }

<span class="fc" id="L544">        return null;</span>
    }

    public int findSymbol(String name)
    {
<span class="fc" id="L549">        Integer sid = mySymbolsMap.get(name);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">        if (sid != null)</span>
        {
<span class="fc" id="L552">            return sid;</span>
        }

<span class="fc" id="L555">        return UNKNOWN_SYMBOL_ID;</span>
    }

    public String findKnownSymbol(int id)
    {
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">        if (id &lt; 0)</span>
        {
<span class="nc" id="L562">            throw new IllegalArgumentException(&quot;symbol IDs must be &gt;= 0&quot;);</span>
        }

<span class="fc" id="L565">        int offset = id - 1;</span>
<span class="fc bfc" id="L566" title="All 4 branches covered.">        if (id != 0 &amp;&amp; offset &lt; mySymbolNames.length)</span>
        {
<span class="fc" id="L568">            return mySymbolNames[offset];</span>
        }

<span class="fc" id="L571">        return null;</span>
    }

    public Iterator&lt;String&gt; iterateDeclaredSymbolNames()
    {
<span class="fc" id="L576">        return Collections</span>
<span class="fc" id="L577">            .unmodifiableList(Arrays.asList(mySymbolNames)) // unsupported remove()</span>
<span class="fc" id="L578">            .iterator();</span>
    }

    public void writeTo(IonWriter writer) throws IOException
    {
<span class="fc" id="L583">        IonReader reader = new SymbolTableReader(this);</span>
<span class="fc" id="L584">        writer.writeValues(reader);</span>
<span class="fc" id="L585">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>