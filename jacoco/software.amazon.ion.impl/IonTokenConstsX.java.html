<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IonTokenConstsX.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">software.amazon.ion:ion-java</a> &gt; <a href="index.source.html" class="el_package">software.amazon.ion.impl</a> &gt; <span class="el_source">IonTokenConstsX.java</span></div><h1>IonTokenConstsX.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2009-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at:
 *
 *     http://aws.amazon.com/apache2.0/
 *
 * or in the &quot;license&quot; file accompanying this file. This file is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

package software.amazon.ion.impl;

import software.amazon.ion.IonException;
import software.amazon.ion.IonType;
import software.amazon.ion.impl.PrivateScalarConversions.CantConvertException;


/**
 * this is a collection of constants and some static helper functions
 * to support tokenizing Ion text
 */
<span class="pc bpc" id="L26" title="1 of 2 branches missed.">final class IonTokenConstsX</span>
{
<span class="nc" id="L28">    public static class CharacterSequence {</span>
        public static final int CHAR_SEQ_EOF                         = -1; // matches -1 (stream eof)
        public static final int CHAR_SEQ_STRING_TERMINATOR           = -2; // can't be &gt;=0, ==-1 (eof), nor -2 (empty esc)
        public static final int CHAR_SEQ_STRING_NON_TERMINATOR       = -3; // used for a pair of triple quotes treated a nothing

        public static final int CHAR_SEQ_NEWLINE_SEQUENCE_1          = -4;  // single new line
        public static final int CHAR_SEQ_NEWLINE_SEQUENCE_2          = -5;  // single carriage return
        public static final int CHAR_SEQ_NEWLINE_SEQUENCE_3          = -6;  // new line - carriage return pair
        public static final int CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1  = -7;  // escape followed by new line
        public static final int CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2  = -8;  // escape followed by carriage return
        public static final int CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3  = -9;  // escape followed by new line - carriage return pair
    }

    public static final int TOKEN_ERROR                 = -1;
    public static final int TOKEN_EOF                   =  0;

    public static final int TOKEN_UNKNOWN_NUMERIC       =  1;
    public static final int TOKEN_INT                   =  2;
    public static final int TOKEN_HEX                   =  3;
    public static final int TOKEN_DECIMAL               =  4;
    public static final int TOKEN_FLOAT                 =  5;
    public static final int TOKEN_FLOAT_INF             =  6;
    public static final int TOKEN_FLOAT_MINUS_INF       =  7;
    public static final int TOKEN_TIMESTAMP             =  8;

    /**
     * Unquoted identifier symbol, including keywords like {@code true} and
     * {@code nan} as well as SIDs like {@code $123}
     */
    public static final int TOKEN_SYMBOL_IDENTIFIER     =  9;
    /** Single-quoted symbol */
    public static final int TOKEN_SYMBOL_QUOTED         = 10;
    /** Unquoted operator sequence for sexp */
    public static final int TOKEN_SYMBOL_OPERATOR       = 11;

    public static final int TOKEN_STRING_DOUBLE_QUOTE   = 12;
    public static final int TOKEN_STRING_TRIPLE_QUOTE   = 13;

    public static final int TOKEN_DOT                   = 14;
    public static final int TOKEN_COMMA                 = 15;
    public static final int TOKEN_COLON                 = 16;
    public static final int TOKEN_DOUBLE_COLON          = 17;

    public static final int TOKEN_OPEN_PAREN            = 18;
    public static final int TOKEN_CLOSE_PAREN           = 19;
    public static final int TOKEN_OPEN_BRACE            = 20;
    public static final int TOKEN_CLOSE_BRACE           = 21;
    public static final int TOKEN_OPEN_SQUARE           = 22;
    public static final int TOKEN_CLOSE_SQUARE          = 23;

    public static final int TOKEN_OPEN_DOUBLE_BRACE     = 24;
    public static final int TOKEN_CLOSE_DOUBLE_BRACE    = 25;

    public static final int TOKEN_BINARY                = 26;

    public static final int TOKEN_MAX                   = 26;
    public static final int TOKEN_count                 = 27;

    public static final int KEYWORD_unrecognized = -1;
    public static final int KEYWORD_none         =  0;
    public static final int KEYWORD_TRUE      =  1;
    public static final int KEYWORD_FALSE     =  2;
    public static final int KEYWORD_NULL      =  3;
    public static final int KEYWORD_BOOL      =  4;
    public static final int KEYWORD_INT       =  5;
    public static final int KEYWORD_FLOAT     =  6;
    public static final int KEYWORD_DECIMAL   =  7;
    public static final int KEYWORD_TIMESTAMP =  8;
    public static final int KEYWORD_SYMBOL    =  9;
    public static final int KEYWORD_STRING    = 10;
    public static final int KEYWORD_BLOB      = 11;
    public static final int KEYWORD_CLOB      = 12;
    public static final int KEYWORD_LIST      = 13;
    public static final int KEYWORD_SEXP      = 14;
    public static final int KEYWORD_STRUCT    = 15;
    public static final int KEYWORD_NAN       = 16;
    public static final int KEYWORD_sid       = 17;

    public final static String getTokenName(int t) {
<span class="pc bpc" id="L107" title="17 of 28 branches missed.">        switch (t) {</span>
<span class="nc" id="L108">        case TOKEN_ERROR:              return &quot;TOKEN_ERROR&quot;;</span>
<span class="fc" id="L109">        case TOKEN_EOF:                return &quot;TOKEN_EOF&quot;;</span>

<span class="fc" id="L111">        case TOKEN_UNKNOWN_NUMERIC:    return &quot;TOKEN_UNKNOWN_NUMERIC&quot;;</span>
<span class="nc" id="L112">        case TOKEN_INT:                return &quot;TOKEN_INT&quot;;</span>
<span class="nc" id="L113">        case TOKEN_HEX:                return &quot;TOKEN_HEX&quot;;</span>
<span class="nc" id="L114">        case TOKEN_DECIMAL:            return &quot;TOKEN_DECIMAL&quot;;</span>
<span class="nc" id="L115">        case TOKEN_FLOAT:              return &quot;TOKEN_FLOAT&quot;;</span>
<span class="nc" id="L116">        case TOKEN_FLOAT_INF:          return &quot;TOKEN_FLOAT_INF&quot;;</span>
<span class="nc" id="L117">        case TOKEN_FLOAT_MINUS_INF:    return &quot;TOKEN_FLOAT_MINUS_INF&quot;;</span>
<span class="nc" id="L118">        case TOKEN_TIMESTAMP:          return &quot;TOKEN_TIMESTAMP&quot;;</span>

<span class="fc" id="L120">        case TOKEN_SYMBOL_IDENTIFIER:  return &quot;TOKEN_SYMBOL_IDENTIFIER&quot;;</span>
<span class="nc" id="L121">        case TOKEN_SYMBOL_QUOTED:      return &quot;TOKEN_SYMBOL_QUOTED&quot;;</span>
<span class="fc" id="L122">        case TOKEN_SYMBOL_OPERATOR:    return &quot;TOKEN_SYMBOL_OPERATOR&quot;;</span>
<span class="nc" id="L123">        case TOKEN_STRING_DOUBLE_QUOTE:return &quot;TOKEN_STRING_DOUBLE_QUOTE&quot;;</span>
<span class="nc" id="L124">        case TOKEN_STRING_TRIPLE_QUOTE:return &quot;TOKEN_STRING_TRIPLE_QUOTE&quot;;</span>

<span class="fc" id="L126">        case TOKEN_DOT:                return &quot;TOKEN_DOT&quot;;</span>
<span class="fc" id="L127">        case TOKEN_COMMA:              return &quot;TOKEN_COMMA&quot;;</span>
<span class="fc" id="L128">        case TOKEN_COLON:              return &quot;TOKEN_COLON&quot;;</span>
<span class="fc" id="L129">        case TOKEN_DOUBLE_COLON:       return &quot;TOKEN_DOUBLE_COLON&quot;;</span>

<span class="fc" id="L131">        case TOKEN_OPEN_PAREN:         return &quot;TOKEN_OPEN_PAREN&quot;;</span>
<span class="nc" id="L132">        case TOKEN_CLOSE_PAREN:        return &quot;TOKEN_CLOSE_PAREN&quot;;</span>
<span class="nc" id="L133">        case TOKEN_OPEN_BRACE:         return &quot;TOKEN_OPEN_BRACE&quot;;</span>
<span class="fc" id="L134">        case TOKEN_CLOSE_BRACE:        return &quot;TOKEN_CLOSE_BRACE&quot;;</span>
<span class="fc" id="L135">        case TOKEN_OPEN_SQUARE:        return &quot;TOKEN_OPEN_SQUARE&quot;;</span>
<span class="nc" id="L136">        case TOKEN_CLOSE_SQUARE:       return &quot;TOKEN_CLOSE_SQUARE&quot;;</span>

<span class="nc" id="L138">        case TOKEN_OPEN_DOUBLE_BRACE:  return &quot;TOKEN_OPEN_DOUBLE_BRACE&quot;;</span>
<span class="nc" id="L139">        case TOKEN_CLOSE_DOUBLE_BRACE: return &quot;TOKEN_CLOSE_DOUBLE_BRACE&quot;;</span>

<span class="nc" id="L141">        default: return &quot;&lt;invalid token &quot;+t+&quot;&gt;&quot;;</span>
        }
    }
    public final static String describeToken(int t) {
<span class="pc bpc" id="L145" title="6 of 9 branches missed.">        switch (t) {</span>
<span class="nc" id="L146">        case TOKEN_OPEN_PAREN:         return &quot;(&quot;;</span>
<span class="fc" id="L147">        case TOKEN_CLOSE_PAREN:        return &quot;)&quot;;</span>
<span class="nc" id="L148">        case TOKEN_OPEN_BRACE:         return &quot;{&quot;;</span>
<span class="fc" id="L149">        case TOKEN_CLOSE_BRACE:        return &quot;}&quot;;</span>
<span class="nc" id="L150">        case TOKEN_OPEN_SQUARE:        return &quot;[&quot;;</span>
<span class="fc" id="L151">        case TOKEN_CLOSE_SQUARE:       return &quot;]&quot;;</span>

<span class="nc" id="L153">        case TOKEN_OPEN_DOUBLE_BRACE:  return &quot;{{&quot;;</span>
<span class="nc" id="L154">        case TOKEN_CLOSE_DOUBLE_BRACE: return &quot;}}&quot;;</span>

<span class="nc" id="L156">        default: return getTokenName(t);</span>
        }
    }
    public static final IonType ion_type_of_scalar(int token) {
<span class="pc bpc" id="L160" title="1 of 12 branches missed.">        switch(token) {</span>
<span class="fc" id="L161">        case TOKEN_INT:                 return IonType.INT;</span>
<span class="fc" id="L162">        case TOKEN_BINARY:              return IonType.INT;</span>
<span class="fc" id="L163">        case TOKEN_HEX:                 return IonType.INT;</span>
<span class="fc" id="L164">        case TOKEN_DECIMAL:             return IonType.DECIMAL;</span>
<span class="fc" id="L165">        case TOKEN_FLOAT:               return IonType.FLOAT;</span>
<span class="fc" id="L166">        case TOKEN_TIMESTAMP:           return IonType.TIMESTAMP;</span>
<span class="nc" id="L167">        case TOKEN_SYMBOL_IDENTIFIER:   return IonType.SYMBOL;</span>
<span class="fc" id="L168">        case TOKEN_SYMBOL_QUOTED:       return IonType.SYMBOL;</span>
<span class="fc" id="L169">        case TOKEN_SYMBOL_OPERATOR:     return IonType.SYMBOL;</span>
<span class="fc" id="L170">        case TOKEN_STRING_DOUBLE_QUOTE: return IonType.STRING;</span>
<span class="fc" id="L171">        case TOKEN_STRING_TRIPLE_QUOTE: return IonType.STRING;</span>
<span class="fc" id="L172">        default:                        return null;</span>
        }
    }

<span class="fc" id="L176">    public static final char[] BLOB_TERMINATOR               = new char[]  { '}', '}' };</span>
<span class="fc" id="L177">    public static final char[] CLOB_DOUBLE_QUOTED_TERMINATOR = new char[]  { '\'', '\'', '\'' };</span>
<span class="fc" id="L178">    public static final char[] CLOB_TRIPLE_QUOTED_TERMINATOR = new char[]  { '&quot;' };</span>

    public static final boolean is8bitValue(int v) {
<span class="fc bfc" id="L181" title="All 2 branches covered.">        return (v &amp; ~0xff) == 0;</span>
    }
    public static final boolean is7bitValue(int v) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        return (v &amp; ~0x7f) == 0;</span>
    }
    public static final boolean isWhitespace(int c) {
<span class="pc bpc" id="L187" title="3 of 8 branches missed.">        return (c == ' ' || c == '\t' || c == '\n' || c == '\r');</span>
    }

<span class="fc" id="L190">    public final static boolean[] isBase64Character = makeBase64Array();</span>
    public final static int       base64FillerCharacter = '=';
    private static boolean[] makeBase64Array()
    {
<span class="fc" id="L194">        boolean[] base64 = new boolean[256];</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L197">            base64[ii] = true;</span>
        }
<span class="fc bfc" id="L199" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L200">            base64[ii] = true;</span>
        }
<span class="fc bfc" id="L202" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L203">            base64[ii] = true;</span>
        }
<span class="fc" id="L205">        base64['+'] = true;</span>
<span class="fc" id="L206">        base64['/'] = true;</span>
<span class="fc" id="L207">        return base64;</span>
    }

<span class="fc" id="L210">    public final static int[] hexValue = makeHexValueArray();</span>
<span class="fc" id="L211">    public final static boolean[] isHexDigit = makeHexDigitTestArray(hexValue);</span>
    private final static int[] makeHexValueArray() {
<span class="fc" id="L213">        int[] hex = new int[256];</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">        for (int ii=0; ii&lt;256; ii++) {</span>
<span class="fc" id="L215">            hex[ii] = -1;</span>
        }
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L218">            hex[ii] = ii - '0';</span>
        }
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='f'; ii++) {</span>
<span class="fc" id="L221">            hex[ii] = ii - 'a' + 10;</span>
        }
<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='F'; ii++) {</span>
<span class="fc" id="L224">            hex[ii] = ii - 'A' + 10;</span>
        }
<span class="fc" id="L226">        return hex;</span>
    }
    private final static boolean[] makeHexDigitTestArray(int [] hex_characters) {
<span class="fc" id="L229">        boolean[] is_hex = new boolean[hex_characters.length];</span>
<span class="fc bfc" id="L230" title="All 2 branches covered.">        for (int ii=0; ii&lt;hex_characters.length; ii++) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            is_hex[ii] = (hex_characters[ii] &gt;= 0);</span>
        }
<span class="fc" id="L233">        return is_hex;</span>
    }

    public static final boolean isBinaryDigit(int c) {
<span class="fc bfc" id="L237" title="All 4 branches covered.">        return c =='0' || c == '1';</span>
    }

    public final static boolean isHexDigit(int c) {
<span class="pc bpc" id="L241" title="1 of 4 branches missed.">        return isHexDigit[c &amp; 0xff] &amp;&amp; is8bitValue(c);</span>
    }

    public final static int hexDigitValue(int c) {
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (!isHexDigit(c)) {</span>
<span class="fc" id="L246">            IllegalArgumentException e = new IllegalArgumentException(&quot;character '&quot;+((char)c)+&quot;' is not a hex digit&quot;);</span>
<span class="fc" id="L247">            throw new IonException(e);</span>
        }
<span class="fc" id="L249">        return hexValue[c];</span>
    }
/*
    public final static int[] decimalValue = makeDecimalValueArray();
    public final static boolean[] isDecimalDigit = makeDecimalDigitTestArray(decimalValue);
    private final static int[] makeDecimalValueArray() {
        int[] dec = new int[256];
        for (int ii=0; ii&lt;256; ii++) {
            dec[ii] = -1;
        }
        for (int ii='0'; ii&lt;='9'; ii++) {
            dec[ii] = ii - '0';
        }
        return dec;
    }
    private final static boolean[] makeDecimalDigitTestArray(int [] dec_characters) {
        boolean[] is_hex = new boolean[dec_characters.length];
        for (int ii=0; ii&lt;dec_characters.length; ii++) {
            is_hex[ii] = (dec_characters[ii] &gt;= 0);
        }
        return is_hex;
    }
*/
    public final static boolean isDigit(int c) {
<span class="fc bfc" id="L273" title="All 4 branches covered.">        return (c &gt;= '0' &amp;&amp; c &lt;= '9');</span>
    }
    public final static int decimalDigitValue(int c) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (!isDigit(c)) {</span>
<span class="nc" id="L277">            throw new IllegalArgumentException(&quot;character '&quot;+((char)c)+&quot;' is not a hex digit&quot;);</span>
        }
<span class="nc" id="L279">        return c - '0'; // decimalValue[c];</span>
    }

    public static final int CLOB_CHARACTER_LIMIT = 0xFF;
    public static final int ESCAPE_LITTLE_U_MINIMUM = 0x100;
    public static final int ESCAPE_BIG_U_MINIMUM = 0x10000;

    public static final int ESCAPE_HEX = -16;
    public static final int ESCAPE_BIG_U = -15;
    public static final int ESCAPE_LITTLE_U = -14;
    public static final int ESCAPE_REMOVES_NEWLINE2 = -13;
    public static final int ESCAPE_REMOVES_NEWLINE = -12;
    public static final int ESCAPE_NOT_DEFINED = -11;

<span class="fc" id="L293">    private static final int escapeCharactersValues[] = makeEscapeCharacterValuesArray();</span>
    private static final int[] makeEscapeCharacterValuesArray() {
<span class="fc" id="L295">        int[] values = new int[256];</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        for (int ii=0; ii&lt;256; ii++) {</span>
<span class="fc" id="L297">            values[ii] = ESCAPE_NOT_DEFINED;</span>
        }
<span class="fc" id="L299">        values['0'] = 0;        //    \u0000  \0  alert NUL</span>
<span class="fc" id="L300">        values['a'] = 7;        //    \u0007  \a  alert BEL</span>
<span class="fc" id="L301">        values['b'] = 8;        //    \u0008  \b  backspace BS</span>
<span class="fc" id="L302">        values['t'] = 9;        //    \u0009  \t  horizontal tab HT</span>
<span class="fc" id="L303">        values['n'] = '\n';     //    \ u000A  \ n  linefeed LF</span>
<span class="fc" id="L304">        values['f'] = 0x0c;     //    \u000C  \f  form feed FF</span>
<span class="fc" id="L305">        values['r'] = '\r';     //    \ u000D  \ r  carriage return CR</span>
<span class="fc" id="L306">        values['v'] = 0x0b;     //    \u000B  \v  vertical tab VT</span>
<span class="fc" id="L307">        values['&quot;'] = '&quot;';      //    \u0022  \&quot;  double quote</span>
<span class="fc" id="L308">        values['\''] = '\'';    //    \u0027  \'  single quote</span>
<span class="fc" id="L309">        values['?'] = '?';      //    \u003F  \?  question mark</span>
<span class="fc" id="L310">        values['\\'] = '\\';    //    \u005C  \\  backslash</span>
<span class="fc" id="L311">        values['/'] = '/';      //    \u002F  \/  forward slash nothing  \NL  escaped NL expands to nothing</span>
<span class="fc" id="L312">        values['\n'] = ESCAPE_REMOVES_NEWLINE;  // slash-new line the new line eater</span>
<span class="fc" id="L313">        values['\r'] = ESCAPE_REMOVES_NEWLINE2;  // slash-new line the new line eater</span>
<span class="fc" id="L314">        values['x'] = ESCAPE_HEX; //    any  \xHH  2-digit hexadecimal unicode character equivalent to \ u00HH</span>
<span class="fc" id="L315">        values['u'] = ESCAPE_LITTLE_U; //    any  \ uHHHH  4-digit hexadecimal unicode character</span>
<span class="fc" id="L316">        values['U'] = ESCAPE_BIG_U;</span>
<span class="fc" id="L317">        return values;</span>
    }
<span class="fc" id="L319">    private static final String escapeCharacterImage[] = makeEscapeCharacterImageArray();</span>
    public final static String [] makeEscapeCharacterImageArray() {
<span class="fc" id="L321">        String [] values = new String[256];</span>

<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (int ii=0; ii&lt;256; ii++) {</span>
<span class="fc" id="L324">            values[ii] = null;</span>
        }

<span class="fc" id="L327">        values['0'] = &quot;\\0&quot;;        //    \u0000  \0  alert NUL</span>
<span class="fc" id="L328">        values['a'] = &quot;\\a&quot;;        //    \u0007  \a  alert BEL</span>
<span class="fc" id="L329">        values['b'] = &quot;\\b&quot;;        //    \u0008  \b  backspace BS</span>
<span class="fc" id="L330">        values['t'] = &quot;\\t&quot;;        //    \u0009  \t  horizontal tab HT</span>
<span class="fc" id="L331">        values['n'] = &quot;\\n&quot;;        //    \ u000A \n line feed LF</span>
<span class="fc" id="L332">        values['f'] = &quot;\\f&quot;;        //    \u000C  \f  form feed FF</span>
<span class="fc" id="L333">        values['r'] = &quot;\\r&quot;;        //    \ u000D \r  carriage return CR</span>
<span class="fc" id="L334">        values['v'] = &quot;\\v&quot;;        //    \u000B  \v  vertical tab VT</span>
<span class="fc" id="L335">        values['&quot;'] = &quot;\\\&quot;&quot;;       //    \u0022  \&quot;  double quote</span>
<span class="fc" id="L336">        values['\''] = &quot;\\&quot;+&quot;'&quot;;    //    \u0027  \'  single quote</span>
<span class="fc" id="L337">        values['?'] = &quot;\\?&quot;;        //    \u003F  \?  question mark</span>
<span class="fc" id="L338">        values['\\'] = &quot;\\&quot;+&quot;\\&quot;;   //    \u005C  \\  backslash</span>
<span class="fc" id="L339">        values['/'] = &quot;\\/&quot;;        //    \u002F  \/  forward slash nothing  \NL  escaped NL expands to nothing</span>

<span class="fc" id="L341">        return values;</span>
    }
    public final static String getEscapeCharacterImage(int c) {
<span class="nc bnc" id="L344" title="All 4 branches missed.">        if (c &lt; 0 || c &gt; 255) {</span>
<span class="nc" id="L345">            throw new IllegalArgumentException(&quot;character is outside escapable range (0-255 inclusive)&quot;);</span>
        }
<span class="nc" id="L347">        return escapeCharacterImage[c];</span>
    }

    public final static boolean isValidEscapeStart(int c) {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        return (escapeCharactersValues[c &amp; 0xff] != ESCAPE_NOT_DEFINED)</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">         &amp;&amp; is8bitValue(c);</span>
    }
    public final static int escapeReplacementCharacter(int c) {
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">        if (!isValidEscapeStart(c)) {</span>
<span class="nc" id="L356">            throw new IllegalArgumentException(&quot;not a valid escape sequence character: &quot;+c);</span>
        }
<span class="fc" id="L358">        return escapeCharactersValues[c];</span>
    }

    // escapeType
<span class="nc" id="L362">    public enum EscapeType {</span>
<span class="nc" id="L363">                    ESCAPE_DESTINATION_NONE,</span>
<span class="nc" id="L364">                    ESCAPE_DESTINATION_STRING,</span>
<span class="nc" id="L365">                    ESCAPE_DESTINATION_SYMBOL,</span>
<span class="nc" id="L366">                    ESCAPE_DESTINATION_CLOB</span>
    }
    public final static boolean needsIonEscape(EscapeType escapeType, int c) {
<span class="nc bnc" id="L369" title="All 5 branches missed.">        switch(escapeType) {</span>
<span class="nc" id="L370">        case ESCAPE_DESTINATION_NONE:   return false;</span>
<span class="nc" id="L371">        case ESCAPE_DESTINATION_STRING: return needsStringEscape(c);</span>
<span class="nc" id="L372">        case ESCAPE_DESTINATION_SYMBOL: return needsSymbolEscape(c);</span>
<span class="nc" id="L373">        case ESCAPE_DESTINATION_CLOB:   return needsClobEscape(c);</span>
<span class="nc" id="L374">        default:                        throw new IllegalArgumentException(&quot;escapeType &quot;+escapeType+&quot; is unrecognized&quot;);</span>
        }
    }
    public final static boolean needsSymbolEscape(int c) {
<span class="nc bnc" id="L378" title="All 6 branches missed.">        return (c &lt; 32 || c == '\'' || c == '\\');</span>
    }
    public final static boolean needsStringEscape(int c) {
<span class="nc bnc" id="L381" title="All 6 branches missed.">        return (c &lt; 32 || c == '&quot;' || c == '\\');</span>
    }
    public final static boolean needsClobEscape(int c) {
<span class="nc bnc" id="L384" title="All 8 branches missed.">        return (c &lt; 32 || c == '&quot;' || c == '\\' || c &gt; 127);</span>
    }
    public static String escapeSequence(int c) {
<span class="nc bnc" id="L387" title="All 4 branches missed.">        if (c &gt;= 0 || c &lt;= 0x10FFFF) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (c &lt; 128) {</span>
<span class="nc" id="L389">                return escapeCharacterImage[c];</span>
            }
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (c &lt; 0xFFFF) {</span>
<span class="nc" id="L392">                String short_hex = Integer.toHexString(c);</span>
<span class="nc" id="L393">                int    short_len = short_hex.length();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                if (short_len &lt; 4) {</span>
<span class="nc" id="L395">                    short_hex = &quot;0000&quot;.substring(short_len);</span>
                }
<span class="nc" id="L397">                return &quot;\\u&quot;+short_hex;</span>
            }
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (c &lt; 0xFFFF) {</span>
<span class="nc" id="L400">                String long_hex = Integer.toHexString(c);</span>
<span class="nc" id="L401">                int    long_len = long_hex.length();</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (long_len &lt; 4) {</span>
<span class="nc" id="L403">                    long_hex = &quot;00000000&quot;.substring(long_len);</span>
                }
<span class="nc" id="L405">                return &quot;\\U&quot;+long_hex;</span>
            }
        }
<span class="nc" id="L408">        throw new IllegalArgumentException(&quot;the value &quot;+c+&quot; isn't a valid character&quot;);</span>
    }

<span class="fc" id="L411">    private static final boolean invalidTerminatingCharsForInf[] = makeInvalidTerminatingCharsForInfArray();</span>
    private static final boolean [] makeInvalidTerminatingCharsForInfArray() {
<span class="fc" id="L413">        boolean [] values = new boolean [256];</span>

<span class="fc bfc" id="L415" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L416">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L419">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L422">            values[ii] = true;</span>
        }
<span class="fc" id="L424">        values['$'] = true;</span>
<span class="fc" id="L425">        values['_'] = true;</span>

<span class="fc" id="L427">        return values;</span>
    }
    public final static boolean isValidTerminatingCharForInf(int c) {
<span class="pc bpc" id="L430" title="1 of 4 branches missed.">        return !is8bitValue(c) || !invalidTerminatingCharsForInf[c &amp; 0xff];</span>
    }

<span class="fc" id="L433">    private static final boolean isValidExtendedSymbolCharacter[] = makeIsValidExtendedSymbolCharacterArray();</span>
    private static final boolean [] makeIsValidExtendedSymbolCharacterArray() {
<span class="fc" id="L435">        boolean [] values = new boolean [256];</span>

<span class="fc" id="L437">        values['!'] = true;</span>
<span class="fc" id="L438">        values['#'] = true;</span>
<span class="fc" id="L439">        values['%'] = true;</span>
<span class="fc" id="L440">        values['&amp;'] = true;</span>
<span class="fc" id="L441">        values['*'] = true;</span>
<span class="fc" id="L442">        values['+'] = true;</span>
<span class="fc" id="L443">        values['-'] = true;</span>
<span class="fc" id="L444">        values['.'] = true;</span>
<span class="fc" id="L445">        values['/'] = true;</span>
<span class="fc" id="L446">        values[';'] = true;</span>
<span class="fc" id="L447">        values['&lt;'] = true;</span>
<span class="fc" id="L448">        values['='] = true;</span>
<span class="fc" id="L449">        values['&gt;'] = true;</span>
<span class="fc" id="L450">        values['?'] = true;</span>
<span class="fc" id="L451">        values['@'] = true;</span>
<span class="fc" id="L452">        values['^'] = true;</span>
<span class="fc" id="L453">        values['`'] = true;</span>
<span class="fc" id="L454">        values['|'] = true;</span>
<span class="fc" id="L455">        values['~'] = true;</span>

<span class="fc" id="L457">        return values;</span>
    }
    public final static boolean isValidExtendedSymbolCharacter(int c)
    {
<span class="pc bpc" id="L461" title="1 of 4 branches missed.">        return (isValidExtendedSymbolCharacter[c &amp; 0xff] &amp;&amp; is8bitValue(c));</span>
    }

<span class="fc" id="L464">    private static final boolean isValidSymbolCharacter[] = makeIsValidSymbolCharacterArray();</span>
    private static final boolean [] makeIsValidSymbolCharacterArray() {
<span class="fc" id="L466">        boolean [] values = new boolean [256];</span>

<span class="fc bfc" id="L468" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L469">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L471" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L472">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L474" title="All 2 branches covered.">        for (int ii='0'; ii&lt;='9'; ii++) {</span>
<span class="fc" id="L475">            values[ii] = true;</span>
        }
<span class="fc" id="L477">        values['$'] = true;</span>
<span class="fc" id="L478">        values['_'] = true;</span>

<span class="fc" id="L480">        return values;</span>
    }
    public final static boolean isValidSymbolCharacter(int c)
    {
<span class="pc bpc" id="L484" title="1 of 4 branches missed.">        return (isValidSymbolCharacter[c &amp; 0xff] &amp;&amp; is8bitValue(c));</span>
    }

<span class="fc" id="L487">    private static final boolean isValidStartSymbolCharacter[] = makeIsValidStartSymbolCharacterArray();</span>
    private static final boolean [] makeIsValidStartSymbolCharacterArray() {
<span class="fc" id="L489">        boolean [] values = new boolean [256];</span>

<span class="fc bfc" id="L491" title="All 2 branches covered.">        for (int ii='a'; ii&lt;='z'; ii++) {</span>
<span class="fc" id="L492">            values[ii] = true;</span>
        }
<span class="fc bfc" id="L494" title="All 2 branches covered.">        for (int ii='A'; ii&lt;='Z'; ii++) {</span>
<span class="fc" id="L495">            values[ii] = true;</span>
        }
<span class="fc" id="L497">        values['$'] = true;</span>
<span class="fc" id="L498">        values['_'] = true;</span>

<span class="fc" id="L500">        return values;</span>
    }
    public final static boolean isValidStartSymbolCharacter(int c)
    {
<span class="nc bnc" id="L504" title="All 4 branches missed.">        return (isValidStartSymbolCharacter[c &amp; 0xff] &amp;&amp; is8bitValue(c));</span>
    }

    public static int decodeSid(CharSequence sidToken)
    {
<span class="pc bpc" id="L509" title="2 of 4 branches missed.">        assert sidToken.charAt(0) == '$';</span>

<span class="fc" id="L511">        int length = sidToken.length();</span>
<span class="pc bpc" id="L512" title="2 of 4 branches missed.">        assert length &gt; 1;</span>

<span class="fc" id="L514">        String digits = sidToken.subSequence(1, length).toString();</span>
<span class="fc" id="L515">        return Integer.parseInt(digits);</span>
    }

    static public int keyword(CharSequence word, int start_word, int end_word)
    {
<span class="fc" id="L520">        int c = word.charAt(start_word);</span>
<span class="fc" id="L521">        int len = end_word - start_word; // +1 but we build that into the constants below</span>
<span class="fc bfc" id="L522" title="All 11 branches covered.">        switch (c) {</span>
        case '$':
<span class="fc bfc" id="L524" title="All 2 branches covered.">            if (len &gt; 1) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                for (int i = start_word + 1; i &lt; end_word; i++) {</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                    if (! isDigit(word.charAt(i))) return -1;</span>
                }
<span class="fc" id="L528">                return KEYWORD_sid;</span>
            }
<span class="fc" id="L530">            return -1;</span>
        case 'b':
<span class="fc bfc" id="L532" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">                if (word.charAt(start_word+1) == 'o'</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'l'</span>
                ) {
<span class="nc" id="L537">                    return KEYWORD_BOOL;</span>
                }
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                if (word.charAt(start_word+1) == 'l'</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'b'</span>
                ) {
<span class="nc" id="L543">                    return KEYWORD_BLOB;</span>
                }
            }
<span class="fc" id="L546">            return -1;</span>
        case 'c':
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">            if (len == 4) {</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                if (word.charAt(start_word+1) == 'l'</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'b'</span>
                ) {
<span class="nc" id="L553">                    return KEYWORD_CLOB;</span>
                }
            }
<span class="fc" id="L556">            return -1;</span>
        case 'd':
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">            if (len == 7) {</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                if (word.charAt(start_word+1) == 'e'</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'c'</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'i'</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 'm'</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+5) == 'a'</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+6) == 'l'</span>
                ) {
<span class="nc" id="L566">                    return KEYWORD_DECIMAL;</span>
                }
            }
<span class="fc" id="L569">            return -1;</span>
        case 'f':
<span class="fc bfc" id="L571" title="All 2 branches covered.">            if (len == 5) {</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'a'</span>
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'l'</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 's'</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 'e'</span>
                ) {
<span class="fc" id="L577">                    return KEYWORD_FALSE;</span>
                }
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                if (word.charAt(start_word+1) == 'l'</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'o'</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'a'</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 't'</span>
                ) {
<span class="nc" id="L584">                    return KEYWORD_FLOAT;</span>
                }
            }
<span class="fc" id="L587">            return -1;</span>
        case 'i':
<span class="fc bfc" id="L589" title="All 2 branches covered.">            if (len == 3) {</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'n') {</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">                    if (word.charAt(start_word+2) == 't') {</span>
<span class="nc" id="L592">                        return KEYWORD_INT;</span>
                    }
                }
            }
<span class="fc" id="L596">            return -1;</span>
        case 'l':
<span class="fc bfc" id="L598" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'i'</span>
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 's'</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 't'</span>
                ) {
<span class="fc" id="L603">                    return KEYWORD_LIST;</span>
                }
            }
<span class="fc" id="L606">            return -1;</span>
        case 'n':
<span class="fc bfc" id="L608" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'u'</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'l'</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'l'</span>
                ) {
<span class="fc" id="L613">                    return KEYWORD_NULL;</span>
                }
            }
<span class="fc bfc" id="L616" title="All 2 branches covered.">            else if (len == 3) {</span>
<span class="fc bfc" id="L617" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'a'</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">                    &amp;&amp; word.charAt(start_word+2) == 'n'</span>
                   ) {
<span class="fc" id="L620">                       return KEYWORD_NAN;</span>
                   }
            }
<span class="fc" id="L623">            return -1;</span>
        case 's':
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L626" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'e'</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'x'</span>
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'p'</span>
                ) {
<span class="fc" id="L630">                    return KEYWORD_SEXP;</span>
                }
            }
<span class="fc bfc" id="L633" title="All 2 branches covered.">            else if (len == 6) {</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 't'</span>
<span class="pc bpc" id="L635" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'r'</span>
                ) {
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">                    if (word.charAt(start_word+3) == 'i'</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                     &amp;&amp; word.charAt(start_word+4) == 'n'</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                     &amp;&amp; word.charAt(start_word+5) == 'g'</span>
                    ) {
<span class="nc" id="L641">                        return KEYWORD_STRING;</span>
                    }
<span class="pc bpc" id="L643" title="1 of 2 branches missed.">                    if (word.charAt(start_word+3) == 'u'</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">                     &amp;&amp; word.charAt(start_word+4) == 'c'</span>
<span class="pc bpc" id="L645" title="1 of 2 branches missed.">                     &amp;&amp; word.charAt(start_word+5) == 't'</span>
                    ) {
<span class="fc" id="L647">                        return KEYWORD_STRUCT;</span>
                    }
<span class="nc" id="L649">                    return -1;</span>
                }
<span class="fc bfc" id="L651" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'y'</span>
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'm'</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'b'</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 'o'</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+5) == 'l'</span>
                ) {
<span class="fc" id="L657">                    return KEYWORD_SYMBOL;</span>
                }
            }
<span class="fc" id="L660">            return -1;</span>
        case 't':
<span class="fc bfc" id="L662" title="All 2 branches covered.">            if (len == 4) {</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">                if (word.charAt(start_word+1) == 'r'</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'u'</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'e'</span>
                ) {
<span class="fc" id="L667">                    return KEYWORD_TRUE;</span>
                }
            }
<span class="fc bfc" id="L670" title="All 2 branches covered.">            else if (len == 9) {</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">                if (word.charAt(start_word+1) == 'i'</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">                 &amp;&amp; word.charAt(start_word+2) == 'm'</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+3) == 'e'</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+4) == 's'</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+5) == 't'</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+6) == 'a'</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+7) == 'm'</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">                 &amp;&amp; word.charAt(start_word+8) == 'p'</span>
                ) {
<span class="nc" id="L680">                    return KEYWORD_TIMESTAMP;</span>
                }
            }
<span class="fc" id="L683">            return -1;</span>
        default:
<span class="fc" id="L685">            return -1;</span>
        }
    }

    /*
    KW_BIT_BLOB       = 0x0001;
    KW_BIT_BOOL       = 0x0002;
    KW_BIT_CLOB       = 0x0004;
    KW_BIT_DECIMAL    = 0x0008;
    KW_BIT_FLOAT      = 0x0010;
    KW_BIT_INT        = 0x0020;
    KW_BIT_LIST       = 0x0030;
    KW_BIT_NULL       = 0x0080;
    KW_BIT_SEXP       = 0x0100;
    KW_BIT_STRING     = 0x0200;
    KW_BIT_STRUCT     = 0x0400;
    KW_BIT_SYMBOL     = 0x0800;
    KW_BIT_TIMESTAMP  = 0x1000;
    datagram is not included (since these are types that can appear as a null type)

    A  1    F  6    N 11    T 16
    B  2    G  7    O 12    U 17
    C  3    I  8    P 13    X 18
    D  4    L  9    R 14    Y 19
    E  5    M 10    S 15

    */
    // this array is [pos][letter_idx] - if this letter is
    // valid in this position then all the type names that
    // contain the letter at that position are on.  Each
    // keyword is assigned a bit value.
    // however due to the double index expense the index
    // is represented by a 1 dim int array and fn's used
    // to access it (since inline-ing final static small methods
    // is easy for the compiler)
<span class="fc" id="L720">    static final int  TN_MAX_NAME_LENGTH = &quot;TIMESTAMP&quot;.length() + 1; // so anything too long will be 0</span>
    static final int  TN_LETTER_MAX_IDX = 19;

    static final int  KW_BIT_BLOB       = 0x0001;
    static final int  KW_BIT_BOOL       = 0x0002;
    static final int  KW_BIT_CLOB       = 0x0004;
    static final int  KW_BIT_DECIMAL    = 0x0008;
    static final int  KW_BIT_FLOAT      = 0x0010;
    static final int  KW_BIT_INT        = 0x0020;
    static final int  KW_BIT_LIST       = 0x0030;
    static final int  KW_BIT_NULL       = 0x0080;
    static final int  KW_BIT_SEXP       = 0x0100;
    static final int  KW_BIT_STRING     = 0x0200;
    static final int  KW_BIT_STRUCT     = 0x0400;
    static final int  KW_BIT_SYMBOL     = 0x0800;
    static final int  KW_BIT_TIMESTAMP  = 0x1000;
    static final int  KW_ALL_BITS       = 0x1fff;

<span class="fc" id="L738">    static final int[] typeNameBits = new int[] {</span>
        KW_BIT_BLOB,      KW_BIT_BOOL,    KW_BIT_CLOB,
        KW_BIT_DECIMAL,   KW_BIT_FLOAT,   KW_BIT_INT,
        KW_BIT_LIST,      KW_BIT_NULL,    KW_BIT_SEXP,
        KW_BIT_STRING,    KW_BIT_STRUCT,  KW_BIT_SYMBOL,
        KW_BIT_TIMESTAMP
    };

<span class="fc" id="L746">    static final String[] typeNameNames = new String[] {</span>
        &quot;blob&quot;,           &quot;bool&quot;,         &quot;clob&quot;,
        &quot;decimal&quot;,        &quot;float&quot;,        &quot;int&quot;,
        &quot;list&quot;,           &quot;null&quot;,         &quot;sexp&quot;,
        &quot;string&quot;,         &quot;struct&quot;,       &quot;symbol&quot;,
        &quot;timestamp&quot;
    };
<span class="fc" id="L753">    static final int[] typeNameKeyWordIds = new int[] {</span>
        KEYWORD_BLOB,     KEYWORD_BOOL,   KEYWORD_CLOB,
        KEYWORD_DECIMAL,  KEYWORD_FLOAT,  KEYWORD_INT,
        KEYWORD_LIST,     KEYWORD_NULL,   KEYWORD_SEXP,
        KEYWORD_STRING,   KEYWORD_STRUCT, KEYWORD_SYMBOL,
        KEYWORD_TIMESTAMP
    };

<span class="fc" id="L761">    static final int[] TypeNameBitIndex = makeTypeNameBitIndex();</span>
    static final int[] makeTypeNameBitIndex() {
<span class="fc" id="L763">        int[] bits = new int[TN_MAX_NAME_LENGTH*TN_LETTER_MAX_IDX];</span>
        int   typename_bit;
<span class="fc bfc" id="L765" title="All 2 branches covered.">        for (int tt=0; tt&lt;typeNameNames.length; tt++) {</span>
<span class="fc" id="L766">            String typename = typeNameNames[tt];</span>
<span class="fc" id="L767">            typename_bit = typeNameBits[tt];</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">            for (int ii=0; ii&lt;typename.length(); ii++) {</span>
<span class="fc" id="L769">                int c = typename.charAt(ii);</span>
<span class="fc" id="L770">                int l = typeNameLetterIdx(c);</span>
<span class="pc bpc" id="L771" title="2 of 4 branches missed.">                assert(l &gt; 0);</span>
<span class="fc" id="L772">                typename_set_bit(bits, ii, l, typename_bit);</span>
            }
        }
<span class="fc" id="L775">        return bits;</span>
    }
    private final static void typename_set_bit(int[] bits, int ii, int l, int typename_bit)
    {
        // bits[ii][l]
<span class="fc" id="L780">        int idx = (ii * TN_LETTER_MAX_IDX) + l - 1;</span>
<span class="fc" id="L781">        bits[idx] |= typename_bit;</span>
<span class="fc" id="L782">    }</span>
    public final static int typeNameLetterIdx(int c) {
<span class="fc bfc" id="L784" title="All 20 branches covered.">        switch(c) {</span>
<span class="fc" id="L785">        case 'a': return  1;</span>
<span class="fc" id="L786">        case 'b': return  2;</span>
<span class="fc" id="L787">        case 'c': return  3;</span>
<span class="fc" id="L788">        case 'd': return  4;</span>
<span class="fc" id="L789">        case 'e': return  5;</span>
<span class="fc" id="L790">        case 'f': return  6;</span>
<span class="fc" id="L791">        case 'g': return  7;</span>
<span class="fc" id="L792">        case 'i': return  8;</span>
<span class="fc" id="L793">        case 'l': return  9;</span>
<span class="fc" id="L794">        case 'm': return 10;</span>
<span class="fc" id="L795">        case 'n': return 11;</span>
<span class="fc" id="L796">        case 'o': return 12;</span>
<span class="fc" id="L797">        case 'p': return 13;</span>
<span class="fc" id="L798">        case 'r': return 14;</span>
<span class="fc" id="L799">        case 's': return 15;</span>
<span class="fc" id="L800">        case 't': return 16;</span>
<span class="fc" id="L801">        case 'u': return 17;</span>
<span class="fc" id="L802">        case 'x': return 18;</span>
<span class="fc" id="L803">        case 'y': return 19;</span>
<span class="fc" id="L804">        default:  return -1;</span>
        }
    }
    public final static int typeNamePossibilityMask(int pos, int letter_idx) {
<span class="fc" id="L808">        int idx = (pos * TN_LETTER_MAX_IDX) + letter_idx - 1;</span>
<span class="fc" id="L809">        int mask = TypeNameBitIndex[idx];</span>
<span class="fc" id="L810">        return mask;</span>
    }
    // this can be faster but it's pretty unusual to be called.
    public final static int typeNameKeyWordFromMask(int possible_names, int length) {
<span class="fc" id="L814">        int kw = KEYWORD_unrecognized;</span>
<span class="fc bfc" id="L815" title="All 2 branches covered.">        if (possible_names != IonTokenConstsX.KW_ALL_BITS) {</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">            for (int ii=0; ii&lt;typeNameBits.length; ii++) {</span>
<span class="fc" id="L817">                int tb = typeNameBits[ii];</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                if (tb == possible_names) {</span>
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">                    if (typeNameNames[ii].length() == length) {</span>
<span class="fc" id="L820">                        kw = typeNameKeyWordIds[ii];</span>
                    }
                    break;
                }
            }
        }
<span class="fc" id="L826">        return kw;</span>
    }
    public static final String getNullImage(IonType type)
    {
<span class="nc" id="L830">        String nullimage = null;</span>

<span class="nc bnc" id="L832" title="All 14 branches missed.">        switch (type) {</span>
<span class="nc" id="L833">        case NULL:      nullimage = &quot;null&quot;;           break;</span>
<span class="nc" id="L834">        case BOOL:      nullimage = &quot;null.bool&quot;;      break;</span>
<span class="nc" id="L835">        case INT:       nullimage = &quot;null.int&quot;;       break;</span>
<span class="nc" id="L836">        case FLOAT:     nullimage = &quot;null.float&quot;;     break;</span>
<span class="nc" id="L837">        case DECIMAL:   nullimage = &quot;null.decimal&quot;;   break;</span>
<span class="nc" id="L838">        case TIMESTAMP: nullimage = &quot;null.timestamp&quot;; break;</span>
<span class="nc" id="L839">        case SYMBOL:    nullimage = &quot;null.symbol&quot;;    break;</span>
<span class="nc" id="L840">        case STRING:    nullimage = &quot;null.string&quot;;    break;</span>
<span class="nc" id="L841">        case BLOB:      nullimage = &quot;null.blob&quot;;      break;</span>
<span class="nc" id="L842">        case CLOB:      nullimage = &quot;null.clob&quot;;      break;</span>
<span class="nc" id="L843">        case SEXP:      nullimage = &quot;null.sexp&quot;;      break;</span>
<span class="nc" id="L844">        case LIST:      nullimage = &quot;null.list&quot;;      break;</span>
<span class="nc" id="L845">        case STRUCT:    nullimage = &quot;null.struct&quot;;    break;</span>

<span class="nc" id="L847">        default: throw new IllegalStateException(&quot;unexpected type &quot; + type);</span>
        }

<span class="nc" id="L850">        return nullimage;</span>
    }
    public static final IonType getNullType(CharSequence s)
    {
<span class="nc" id="L854">        IonType type = null;</span>
<span class="nc" id="L855">        int     c, ii = 0;</span>
<span class="nc" id="L856">        boolean stop = false;</span>
<span class="nc bnc" id="L857" title="All 4 branches missed.">        while (!stop &amp;&amp; ii&lt;s.length()) {</span>
<span class="nc" id="L858">            c = s.charAt(ii++);</span>
<span class="nc bnc" id="L859" title="All 3 branches missed.">            switch (c) {</span>
            case ' ': case '\t': case '\r': case '\n':
<span class="nc" id="L861">                break;</span>
            case 'n':
<span class="nc" id="L863">                stop = true;</span>
<span class="nc" id="L864">                break;</span>
            default:
<span class="nc" id="L866">                invalid_null_image(s);</span>
            }
        }
<span class="nc bnc" id="L869" title="All 4 branches missed.">        if (ii&gt;=s.length() || s.charAt(ii++) != 'u') invalid_null_image(s);</span>
<span class="nc bnc" id="L870" title="All 4 branches missed.">        if (ii&gt;=s.length() || s.charAt(ii++) != 'l') invalid_null_image(s);</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">        if (ii&gt;=s.length() || s.charAt(ii++) != 'l') invalid_null_image(s);</span>
<span class="nc" id="L872">        boolean dot = false;</span>
<span class="nc bnc" id="L873" title="All 4 branches missed.">        while (!dot &amp;&amp; ii&lt;s.length()) {</span>
<span class="nc" id="L874">            c = s.charAt(ii++);</span>
<span class="nc bnc" id="L875" title="All 3 branches missed.">            switch (c) {</span>
            case ' ': case '\t': case '\r': case '\n':
<span class="nc" id="L877">                break;</span>
            case '.':
<span class="nc" id="L879">                dot = true;</span>
<span class="nc" id="L880">                break;</span>
            default:
<span class="nc" id="L882">                invalid_null_image(s);</span>
            }
        }
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (dot) {</span>
<span class="nc" id="L886">            int kw = IonTokenConstsX.keyword(s, ii, s.length());</span>
<span class="nc bnc" id="L887" title="All 14 branches missed.">            switch (kw) {</span>
                case IonTokenConstsX.KEYWORD_NULL:
<span class="nc" id="L889">                    type = IonType.NULL;</span>
<span class="nc" id="L890">                    break;</span>
                case IonTokenConstsX.KEYWORD_BOOL:
<span class="nc" id="L892">                    type = IonType.BOOL;</span>
<span class="nc" id="L893">                    break;</span>
                case IonTokenConstsX.KEYWORD_INT:
<span class="nc" id="L895">                    type = IonType.INT;</span>
<span class="nc" id="L896">                    break;</span>
                case IonTokenConstsX.KEYWORD_FLOAT:
<span class="nc" id="L898">                    type = IonType.FLOAT;</span>
<span class="nc" id="L899">                    break;</span>
                case IonTokenConstsX.KEYWORD_DECIMAL:
<span class="nc" id="L901">                    type = IonType.DECIMAL;</span>
<span class="nc" id="L902">                    break;</span>
                case IonTokenConstsX.KEYWORD_TIMESTAMP:
<span class="nc" id="L904">                    type = IonType.TIMESTAMP;</span>
<span class="nc" id="L905">                    break;</span>
                case IonTokenConstsX.KEYWORD_SYMBOL:
<span class="nc" id="L907">                    type = IonType.SYMBOL;</span>
<span class="nc" id="L908">                    break;</span>
                case IonTokenConstsX.KEYWORD_STRING:
<span class="nc" id="L910">                    type = IonType.STRING;</span>
<span class="nc" id="L911">                    break;</span>
                case IonTokenConstsX.KEYWORD_CLOB:
<span class="nc" id="L913">                    type = IonType.CLOB;</span>
<span class="nc" id="L914">                    break;</span>
                case IonTokenConstsX.KEYWORD_BLOB:
<span class="nc" id="L916">                    type = IonType.BLOB;</span>
<span class="nc" id="L917">                    break;</span>
                case IonTokenConstsX.KEYWORD_STRUCT:
<span class="nc" id="L919">                    type = IonType.STRUCT;</span>
<span class="nc" id="L920">                    break;</span>
                case IonTokenConstsX.KEYWORD_LIST:
<span class="nc" id="L922">                    type = IonType.LIST;</span>
<span class="nc" id="L923">                    break;</span>
                case IonTokenConstsX.KEYWORD_SEXP:
<span class="nc" id="L925">                    type = IonType.SEXP;</span>
<span class="nc" id="L926">                    break;</span>
                default:
<span class="nc" id="L928">                    invalid_null_image(s);</span>
            }
        }

<span class="nc bnc" id="L932" title="All 2 branches missed.">        while (ii&lt;s.length()) {</span>
<span class="nc" id="L933">            c = s.charAt(ii++);</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">            switch (c) {</span>
            case ' ': case '\t': case '\r': case '\n':
<span class="nc" id="L936">                break;</span>
            default:
<span class="nc" id="L938">                invalid_null_image(s);</span>
            }
        }

<span class="nc" id="L942">        return type;</span>
    }
    private static void invalid_null_image(CharSequence s) {
<span class="nc" id="L945">        throw new CantConvertException(&quot;invalid image &quot;+s.toString());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>